{"version":3,"file":"index.js","sources":["../node_modules/@collabs/core/build/esm/src/core/event_emitter.js","../node_modules/@collabs/core/build/esm/src/core/iruntime.js","../node_modules/@collabs/core/build/esm/src/core/collab.js","../node_modules/@collabs/core/build/esm/src/core/abstract_runtime.js","../node_modules/@collabs/core/build/esm/src/core/collab_id.js","../node_modules/@collabs/core/build/esm/src/core/replica_ids.js","../node_modules/@collabs/core/build/esm/src/util/assertions.js","../node_modules/@collabs/core/build/esm/src/base_collabs/c_object.js","../node_modules/@collabs/core/build/esm/src/base_collabs/c_primitive.js","../node_modules/@collabs/core/build/esm/src/data_types/abstract_list.js","../node_modules/@collabs/core/build/esm/src/data_types/abstract_lists.js","../node_modules/@collabs/core/build/esm/src/data_types/abstract_map.js","../node_modules/@collabs/core/build/esm/src/data_types/abstract_maps.js","../node_modules/@collabs/core/build/esm/src/data_types/abstract_set.js","../node_modules/@collabs/core/build/esm/src/data_types/abstract_sets.js","../node_modules/@collabs/core/build/esm/src/more_collabs/c_const.js","../node_modules/base64-js/index.js","../node_modules/@collabs/core/build/esm/src/util/cursors.js","../node_modules/@protobufjs/aspromise/index.js","../node_modules/@protobufjs/base64/index.js","../node_modules/@protobufjs/eventemitter/index.js","../node_modules/@protobufjs/float/index.js","../node_modules/@protobufjs/inquire/index.js","../node_modules/@protobufjs/utf8/index.js","../node_modules/@protobufjs/pool/index.js","../node_modules/protobufjs/src/util/longbits.js","../node_modules/protobufjs/src/util/minimal.js","../node_modules/protobufjs/src/writer.js","../node_modules/protobufjs/src/writer_buffer.js","../node_modules/protobufjs/src/reader.js","../node_modules/protobufjs/src/reader_buffer.js","../node_modules/protobufjs/src/rpc/service.js","../node_modules/protobufjs/src/rpc.js","../node_modules/protobufjs/src/roots.js","../node_modules/protobufjs/src/index-minimal.js","../node_modules/protobufjs/minimal.js","../node_modules/@collabs/core/build/esm/generated/proto_compiled.js","../node_modules/@collabs/core/build/esm/src/util/safe_weak_ref.js","../node_modules/@collabs/core/build/esm/src/util/serializers.js","../node_modules/@collabs/core/build/esm/src/util/optional.js","../node_modules/@collabs/core/build/esm/src/util/update_serializers.js","../node_modules/@collabs/core/build/esm/src/util/weak_value_map.js","../node_modules/@collabs/core/build/esm/src/more_collabs/c_lazy_map.js","../node_modules/@collabs/core/build/esm/src/more_collabs/c_messenger.js","../node_modules/@collabs/crdts/build/esm/src/base_collabs/primitive_crdt.js","../node_modules/@collabs/crdts/build/esm/src/base_collabs/abstract_lists.js","../node_modules/@collabs/crdts/build/esm/src/base_collabs/abstract_maps.js","../node_modules/@collabs/crdts/build/esm/src/base_collabs/abstract_sets.js","../node_modules/@collabs/crdts/build/esm/generated/proto_compiled.js","../node_modules/@collabs/crdts/build/esm/src/set/c_set.js","../node_modules/@collabs/crdts/build/esm/src/set/c_value_set.js","../node_modules/@collabs/crdts/build/esm/src/map/c_multi_value_map.js","../node_modules/@collabs/crdts/build/esm/src/map/c_value_map.js","../node_modules/@collabs/crdts/build/esm/src/map/c_map.js","../node_modules/@collabs/crdts/build/esm/src/map/c_presence.js","../node_modules/@collabs/crdts/build/esm/src/var/c_var.js","../node_modules/@collabs/crdts/build/esm/src/boolean/c_boolean.js","../node_modules/@collabs/crdts/build/esm/src/list/c_total_order.js","../node_modules/@collabs/crdts/build/esm/src/list/local_list.js","../node_modules/@collabs/crdts/build/esm/src/list/c_list.js","../node_modules/@collabs/crdts/build/esm/src/list/c_span_log.js","../node_modules/@collabs/crdts/build/esm/src/list/c_value_list.js","../node_modules/@collabs/crdts/build/esm/src/list/char_array_serializer.js","../node_modules/@collabs/crdts/build/esm/src/list/c_rich_text.js","../node_modules/@collabs/crdts/build/esm/src/list/c_text.js","../node_modules/@collabs/crdts/build/esm/src/number/c_counter.js","../node_modules/@collabs/crdts/build/esm/src/runtime/crdt_meta_implementations.js","../node_modules/@collabs/crdts/build/esm/src/runtime/message_serializer.js","../node_modules/@collabs/crdts/build/esm/src/runtime/causal_message_buffer.js","../node_modules/@collabs/crdts/build/esm/src/runtime/c_runtime.js","../node_modules/@collabs/crdts/build/esm/src/runtime/abstract_doc.js","../node_modules/@collabs/crdts/build/esm/src/runtime/merge_messages.js","../node_modules/@collabs/crdts/build/esm/src/util/testing_runtimes.js","../node_modules/@collabs/indexeddb/build/esm/src/indexed_db_doc_store.js","../node_modules/@collabs/local-storage/build/esm/src/local_storage_doc_store.js","../node_modules/@collabs/tab-sync/build/esm/src/tab_sync_network.js","../node_modules/@collabs/ws-client/build/esm/generated/proto_compiled.js","../node_modules/@collabs/ws-client/build/esm/src/update_type.js","../node_modules/@collabs/ws-client/build/esm/src/web_socket_network.js","../src/collabs-bundle.ts"],"sourcesContent":["/**\n * Classes extending EventEmitter can emit events, and listeners can listen\n * on events using [[on]].\n *\n * @typeParam Events An interface mapping event names to event types.\n *\n * @remarks\n * Inspired by {@link https://github.com/ai/nanoevents | nanoevents}, but\n * refactored as a class to better fit into our class hierarchy.\n */\nexport class EventEmitter {\n    constructor() {\n        /**\n         * Maps event names to registered handlers.\n         *\n         * Properly, `any` should instead be `this`.  However,\n         * that causes errors when trying to treat a Collab\n         * subclass as an instance of Collab, for reasons\n         * that are not clear to me.\n         */\n        this.handlers = {};\n    }\n    /**\n     * Registers an event handler that is triggered when the event happens.\n     *\n     * @param eventName Name of the event to listen on.\n     * @param handler Callback that handles the event.\n     * @param options.once If true, the event handler is triggered at most\n     * once (the next time the event happens), then unsubscribed.\n     * @return An \"off\" function that removes the event handler when called.\n     */\n    on(eventName, handler, options) {\n        if (options?.once === true) {\n            const unsubscribe = this.on(eventName, (event, caller) => {\n                unsubscribe();\n                handler(event, caller);\n            });\n            return unsubscribe;\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const set = (this.handlers[eventName] =\n                this.handlers[eventName] ?? new Set([handler]));\n            set.add(handler);\n            return () => set.delete(handler);\n        }\n    }\n    /**\n     * Emits an event, which triggers all the registered event handlers.\n     *\n     * Event handlers are called in the order they are added. Errors in\n     * event handlers are captured and logged (with `console.error`),\n     * not propagated to the caller.\n     *\n     * @param eventName Name of the event to emit.\n     * @param event Event object to pass to the event handlers.\n     */\n    emit(eventName, event) {\n        for (const handler of this.handlers[eventName] ?? []) {\n            try {\n                handler(event, this);\n            }\n            catch (err) {\n                console.error(\"Error in Collabs event handler:\\n\", err);\n            }\n        }\n    }\n}\n//# sourceMappingURL=event_emitter.js.map","export function isRuntime(x) {\n    if (typeof x === \"object\") {\n        if (x.isRuntime === true) {\n            return true;\n        }\n    }\n    return false;\n}\n//# sourceMappingURL=iruntime.js.map","import { EventEmitter } from \"./event_emitter\";\nimport { isRuntime } from \"./iruntime\";\n/**\n * Used to initialize a [[Collab]] with the given\n * [[name]] and [[parent]].\n *\n * An InitToken must\n * **only** be created and used by `parent` itself, to construct\n * a Collab that it is adding as a child.\n */\nexport class InitToken {\n    constructor(name, parent) {\n        this.name = name;\n        this.parent = parent;\n        /**\n         * Type guard, to prevent Collab from being an InitToken.\n         */\n        this.isInitToken = true;\n    }\n}\n/**\n * Base class for a collaborative data structure (abbreviated \"Collab\").\n *\n * A Collab is a data structure that is replicated across multiple\n * devices and stays in sync between them: when one device\n * changes a Collab, their changes show up for every other device.\n *\n * Like local (non-collaborative) data structures, library users interact\n * with Collabs through type-specific methods (both mutators and accessors).\n * In addition, a Collab emits events describe state changes, in the style of\n * reactive programming. This allows you to observe changes due to\n * remove operations, although local operations also cause events. See [[on]].\n *\n * This base class provides a framework for implementing and networking\n * Collabs. Most of its properties are not relevant to users of the Collab\n * but are public for technical reasons; these are marked \"Internal use only\".\n *\n * To implement a custom Collab, you will usually extend one of the following\n * classes instead of Collab itself:\n * - [[CObject]]: For object-oriented composition of existing Collabs.\n * - [[CPrimitive]]: For a \"primitive\" Collab that sends its own messages\n * over the network.\n * - [[PrimitiveCRDT]]: CRDT variant of CPrimitive that provides\n * CRDT-specific features.\n *\n * @typeParam Events Events record indicating the names and types of\n * events emitted by this Collab.\n */\nexport class Collab extends EventEmitter {\n    /**\n     * Initializes this Collab with the given [[InitToken]].\n     *\n     * The InitToken must have provided by our parent explicitly for\n     * this constructor call.\n     *\n     * Typically, a Collab subclass takes `init` as its first constructor\n     * argument and calls `super(init)`.\n     */\n    constructor(init) {\n        super();\n        this.runtime = isRuntime(init.parent) ? init.parent : init.parent.runtime;\n        this.parent = init.parent;\n        this.name = init.name;\n    }\n    /**\n     * Emits an event, which triggers all the registered event handlers.\n     *\n     * See [[CollabEventsRecord]] for advice\n     * on what events to emit.\n     *\n     * This is a wrapper around [[EventEmitter.emit]]\n     * that forces events to extend [[CollabEvent]]\n     * and also emits an \"Any\" event.\n     *\n     * @param options.skipAnyEvent Set to true\n     * to skip emitting an \"Any\" event.\n     */\n    emit(eventName, event, options) {\n        super.emit(eventName, event);\n        if (!options?.skipAnyEvent && eventName !== \"Any\") {\n            super.emit(\"Any\", { meta: event.meta });\n        }\n    }\n    /**\n     * Broadcasts a message to other replicas of this Collab.\n     * The message will be delivered to all replicas' [[receive]],\n     * including locally.\n     *\n     * For convenience, the message may be expressed as a stack of\n     * `(Uint8Array | string)`,\n     * instead of just a single Uint8Array. This is\n     * useful for parents sending messages on behalf of their children;\n     * see the implementation of [[CObject]] for an example.\n     *\n     * @param messageStack The message to send, in the form of\n     * a stack of Uint8Arrays. Note that this method\n     * may mutate it in-place.\n     * @param metaRequests A stack of metadata requests. The [[runtime]] will use\n     * the union of these when creating the [[MessageMeta]] for [[receive]].\n     * Note that the stack need not align with `messageStack`, and this method may mutate\n     * it in place.\n     */\n    send(messageStack, metaRequests) {\n        this.parent.childSend(this, messageStack, metaRequests);\n    }\n    /**\n     * Internal (parent) use only.\n     *\n     * If this Collab is in its initial, post-constructor state, then\n     * this method may (but is not required to) return true; otherwise, it returns false.\n     *\n     * By default, this method always returns false; override to change.\n     *\n     * If this method returns true:\n     * 1. The parent may choose to weakly reference this object to save memory\n     * (e.g., [[CLazyMap]] does so). If this becomes garbage\n     * collected, then is needed later, the parent will recreate it using the\n     * same constructor call.\n     * 2. The parent may skip calling [[save]] during saving. When loading\n     * the resulting saved state, the parent will call `load(null, meta)`.\n     * [[load]] should process this as if called with the output of [[save]]\n     * from a garbage-collectable state. For a nontrivial example,\n     * see [[CMultiValueMap.load]]'s implementation.\n     */\n    canGC() {\n        return false;\n    }\n    /**\n     * Internal (parent) use only.\n     *\n     * Called by this Collab's parent when it has been deleted from a\n     * collection on the local\n     * replica and can no longer be used (e.g., due to [[CSet.delete]] on this\n     * or an ancestor). A Collab implementation can\n     * implement this method to clean up\n     * external resources, e.g., associated DOM elements.\n     *\n     * `finalize` has no relation to the JavaScript garbage collector or\n     * [[canGC]].\n     *\n     * By default, this method does nothing.\n     */\n    finalize() {\n        // Default: no-op.\n    }\n}\n//# sourceMappingURL=collab.js.map","import { InitToken } from \"./collab\";\nimport { EventEmitter } from \"./event_emitter\";\n/**\n * Skeletal implementation of [[IRuntime]] that uses\n * a root [[Collab]].\n */\nexport class AbstractRuntime extends EventEmitter {\n    /**\n     * @param replicaID This replica's `replicaID`, usually\n     * obtained from [[ReplicaIDs]]. Must not be `\"\"`.\n     */\n    constructor(replicaID) {\n        super();\n        this.isRuntime = true;\n        if (replicaID === \"\") {\n            throw new Error('replicaID must not be \"\"');\n        }\n        this.replicaID = replicaID;\n    }\n    setRootCollab(rootCallback) {\n        const rootCollab = rootCallback(new InitToken(\"\", this));\n        this.rootCollab = rootCollab;\n        return rootCollab;\n    }\n    idOf(collab) {\n        if (collab.runtime !== this) {\n            throw new Error(\"idOf called with Collab from different Runtime\");\n        }\n        return this.rootCollab.idOf(collab);\n    }\n    fromID(id) {\n        return this.rootCollab.fromID(id);\n    }\n}\n//# sourceMappingURL=abstract_runtime.js.map","import { isRuntime } from \"./iruntime\";\n/**\n * Utility function to help custom parents implement [[IParent.idOf]].\n * Other callers should instead call `ancestor.idOf(descendant)`.\n */\nexport function collabIDOf(descendant, ancestor) {\n    let current = descendant;\n    const collabIDPath = [];\n    while (current !== ancestor) {\n        collabIDPath.push(current.name);\n        if (isRuntime(current.parent)) {\n            throw new Error(\"collabIDOf called on non-descendant\");\n        }\n        current = current.parent;\n    }\n    return { collabIDPath };\n}\n//# sourceMappingURL=collab_id.js.map","/**\n * Utitilies for generating [[IRuntime.replicaID]]s.\n */\nexport class ReplicaIDs {\n    constructor() {\n        // Not instantiable.\n    }\n    /**\n     * Returns a cryptographically random replicaID made of base64 characters.\n     */\n    static random(length = this.DEFAULT_LENGTH) {\n        const arr = new Array(length);\n        let randomValues = new Uint8Array(length);\n        if (typeof window === \"undefined\") {\n            // Use Node crypto library.\n            // Next line is a workaround to avoid bundling \"crypto\" in web builds;\n            // see https://github.com/composablesys/collabs/issues/236\n            const cryptoReal = (eval(\"require\")(\"crypto\"));\n            const randomBuffer = cryptoReal.randomBytes(length);\n            randomValues = new Uint8Array(randomBuffer);\n        }\n        else {\n            // Use browser crypto library.\n            window.crypto.getRandomValues(randomValues);\n        }\n        for (let i = 0; i < length; i++) {\n            // Here we exploit the fact that 64 divides 256.\n            // This would be biased otherwise.\n            arr[i] = this.CHARS[randomValues[i] % 64];\n        }\n        return arr.join(\"\");\n    }\n    /**\n     * Returns a pseudorandom replicaID made of base64 characters\n     * generated from `rng` (npm package \"seedrandom\").\n     *\n     * For tests and benchmarks, it is recommended to use such a\n     * replicaID with a fixed seed. You can supply the replicaID\n     * to [[CRuntime]] using its `options.debugReplicaID` constructor\n     * arg.\n     */\n    static pseudoRandom(rng, length = this.DEFAULT_LENGTH) {\n        const arr = new Array(length);\n        for (let i = 0; i < arr.length; i++) {\n            arr[i] = this.CHARS[Math.floor(rng() * 64)];\n        }\n        return arr.join(\"\");\n    }\n}\n/**\n * Characters used for generated replicaIDs: the base64 chars.\n */\nReplicaIDs.CHARS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n/*\n * Rationale for value 10:\n * Each character of the replicaID gives us 6 bits of entropy,\n * for a total of 60 bits.  This gives a < 1%\n * probability that two replicas in the same conversation\n * will ever choose the same replicaID's, even if we\n * consider the total probability across 100,000,000\n * conversations with 10,000 replicaIDs each\n * (= 10 users * 1,000 days * 1 replica/user/day).\n */\n/**\n * The default length of a replicaID, in characters.\n */\nReplicaIDs.DEFAULT_LENGTH = 10;\n//# sourceMappingURL=replica_ids.js.map","/**\n * Safe version of TypeScript's non-null asertion (`value!`) that throws\n * an error if `value` is actually null or undefined.\n */\nexport function nonNull(value) {\n    if (value === null || value === undefined) {\n        throw new Error(\"Internal error: non-null assertion failed\");\n    }\n    return value;\n}\n//# sourceMappingURL=assertions.js.map","import { Collab, collabIDOf, InitToken, } from \"../core\";\nimport { nonNull } from \"../util/assertions\";\n/**\n * Base class for a collaborative object, containing\n * properties that are themselves [[Collab]]s.\n *\n * See [Data Modeling](https://collabs.readthedocs.io/en/latest/guide/data_modeling.html)\n * for a guide and examples of how to extend this class.\n *\n * Extending CObject lets you create a reusable object-oriented\n * unit out of one or more existing Collabs.\n * In particular, you can:\n * - Wrap existing Collabs in a domain-specific API.\n * - Implement a complex Collab as a composition of simple ones,\n * without the need to send your own messages over the network.\n *\n * To use CObject:\n * 1. In your constructor, register any\n * Collab properties using [[registerCollab]]. The registrations\n * must be identical across all replicas.\n * We call the registered properties our [[children]].\n * 2. Implement your methods by calling methods\n * on the Collab properties; operations called this way\n * are collaborative as usual.\n * 3. You may also register event\n * handlers on your Collab properties that emit your\n * own events in response (in your constructor).\n * For simple CObjects,\n * it may be easier to instead expose Collab properties\n * publicly (so users can add their own event handlers)\n * or have users listen on [[CRuntime]]'s \"Change\" event.\n *\n * A CObject may have non-Collab properties, but they\n * are not automatically collaborative. Typically, such\n * properties will all be `readonly`. You can also store\n * functional \"views\" of the Collab properties' states that\n * update in response to events (e.g., a cached `length`\n * field).\n */\nexport class CObject extends Collab {\n    constructor() {\n        super(...arguments);\n        /**\n         * The children (registered Collab properties), keyed by name.\n         *\n         * This map should only be read, not mutated.\n         * It is exposed to subclasses as a convenience for methods\n         * that loop over all children.\n         */\n        this.children = new Map();\n    }\n    /**\n     * Registers a [[Collab]] property of this CObject\n     * with the given name, making it one of our [[children]].\n     *\n     * Typically, you will call this method during the\n     * constructor in the style:\n     * ```ts\n     * this.foo = this.registerCollab(\"foo\", (init) => new FooClass(init, constructor args...));\n     * ```\n     * where `readonly foo: FooClass;` is a Collab property. See\n     * [Data Modeling](https://collabs.readthedocs.io/en/latest/guide/data_modeling.html)\n     * for examples.\n     *\n     * Registrations must be identical across all replicas.\n     *\n     * See also: [[CRuntime.registerCollab]].\n     *\n     * @param name A name for this property, unique among\n     * this class's `registerCollab` calls.\n     * We recommend using the same name as the property,\n     * but you can also use short strings to reduce\n     * network usage (\"\", \"0\", \"1\", ...).\n     * @param collabCallback A callback that uses the\n     * given [[InitToken]] to construct the registered [[Collab]].\n     * @return The registered Collab.\n     */\n    registerCollab(name, collabCallback) {\n        if (this.children.has(name)) {\n            throw new Error('Duplicate child name: \"' + name + '\"');\n        }\n        const child = collabCallback(new InitToken(name, this));\n        this.children.set(name, child);\n        return child;\n    }\n    childSend(child, messageStack, metaRequests) {\n        if (child.parent !== this) {\n            throw new Error(`childSend called by non-child: ${child}`);\n        }\n        messageStack.push(child.name);\n        this.send(messageStack, metaRequests);\n    }\n    receive(messageStack, meta) {\n        if (messageStack.length === 0) {\n            // We are the target\n            throw new Error(\"CObject received message for itself\");\n        }\n        const child = this.children.get(messageStack.pop());\n        if (child === undefined) {\n            // Assume this is a version issue; ignore the child (protobuf3-style).\n            return;\n        }\n        child.receive(messageStack, meta);\n    }\n    /**\n     * Internal (parent) use only.\n     *\n     * Returns saved state describing the current state of this CObject.\n     * See [[Collab.save]].\n     *\n     * A CObject subclass may override this method to save additional state.\n     * It is recommended to do so as follows:\n     * ```ts\n     * save() {\n     *   const ans = super.save();\n     *   // Put your extra saved state in ans.self, which is otherwise unused.\n     *   ans.self = <subclass's saved state>;\n     *   return ans;\n     * }\n     * ```\n     */\n    save() {\n        const childSaves = new Map();\n        for (const [name, child] of this.children) {\n            childSaves.set(name, child.save());\n        }\n        return {\n            children: childSaves,\n        };\n    }\n    /**\n     * Internal (parent) use only.\n     *\n     * Called by this Collab's parent to load saved state. See [[Collab.load]].\n     *\n     * A CObject subclass may override this method to load additional state from\n     * [[Collab.save]] or to perform extra setup - e.g., refreshing functional\n     * views that were not automatically updated by children's load events.\n     * It is recommended to do so as follows:\n     * ```ts\n     * load(savedStateTree: SavedStateTree | null, meta: SavedStateMeta) {\n     *   super.load(savedStateTree, meta);\n     *   // Process your extra saved state from savedStateTree.self.\n     *   const savedState = savedStateTree === null? null: savedStateTree.self!;\n     *   ...\n     *   // Perform extra setup as needed.\n     *   ...\n     * }\n     * ```\n     */\n    load(savedStateTree, meta) {\n        if (savedStateTree === null) {\n            // Pass the null on to children that might override canGC().\n            // For consistency with CLazyMap, only do this for nontrivial children.\n            for (const child of this.children.values()) {\n                if (!child.canGC())\n                    child.load(null, meta);\n            }\n            return;\n        }\n        for (const [name, childSave] of nonNull(savedStateTree.children)) {\n            const child = this.children.get(name);\n            // For versioning purposes, skip loading children that we don't have.\n            if (child !== undefined) {\n                child.load(childSave, meta);\n            }\n            // Note that this will also skip loading children that did not\n            // exist in the saved state's app version.\n        }\n    }\n    idOf(descendant) {\n        return collabIDOf(descendant, this);\n    }\n    fromID(id, startIndex = 0) {\n        const name = id.collabIDPath[startIndex];\n        const child = this.children.get(name);\n        if (child === undefined) {\n            // Return undefined instead of an erroring, in case it is\n            // caused by versioning (child deleted in current version).\n            return undefined;\n        }\n        // Terminal case.\n        // Note that this cast is unsafe, but convenient.\n        if (startIndex === id.collabIDPath.length - 1)\n            return child;\n        // Recursive case.\n        if (child.fromID === undefined) {\n            throw new Error(\"child is not a parent, but CollabID is its descendant\");\n        }\n        return child.fromID(id, startIndex + 1);\n    }\n    /**\n     * Internal (parent) use only.\n     *\n     * By default, this method returns true if `canGC` returns true\n     * on every child. Override to change this behavior.\n     *\n     * See [[Collab.canGC]].\n     */\n    canGC() {\n        for (const child of this.children.values()) {\n            if (!child.canGC())\n                return false;\n        }\n        return true;\n    }\n    /**\n     * Internal (parent) use only.\n     *\n     * By default, this methods calls `finalize` on every child.\n     * Override to change this behavior,\n     * e.g., to add your own finalization steps\n     * (but consider calling `super.finalize()`).\n     */\n    finalize() {\n        for (const child of this.children.values()) {\n            child.finalize();\n        }\n    }\n}\n//# sourceMappingURL=c_object.js.map","import { Collab, } from \"../core\";\nimport { nonNull } from \"../util/assertions\";\n/**\n * Convenience base class for a [[Collab]] implementation that sends\n * its own messages over the network.\n *\n * Extend this class to implement a \"primitive\" Collab with a simple\n * broadcast interface ([[sendPrimitive]]/[[receivePrimitive]]) and no child\n * Collabs. This matches how most collaborative data structures\n * are described algorithmically.\n *\n * See also:\n * - [[CObject]], for an \"object\" Collab that does not need to send its own\n * messages.\n * - [[PrimitiveCRDT]], for a primitive CRDT.\n *\n * @typeParam Events Events record indicating the names and types of\n * events emitted by this Collab.\n */\nexport class CPrimitive extends Collab {\n    /**\n     * Broadcasts a message to other replicas of this Collab.\n     * The message will be delivered to all replicas' [[receivePrimitive]],\n     * including locally.\n     *\n     * Call this method instead of [[Collab.send]].\n     *\n     * @param message The message to send.\n     * @param metaRequest A metadata request. The [[runtime]] will use\n     * this when creating the [[MessageMeta]] for [[receivePrimitive]].\n     */\n    sendPrimitive(message, metaRequest) {\n        this.send([message], metaRequest === undefined ? [] : [metaRequest]);\n    }\n    receive(messageStack, meta) {\n        if (messageStack.length !== 1) {\n            // We are not the target\n            throw new Error(\"CPrimitive received message for child\");\n        }\n        this.receivePrimitive(messageStack[0], meta);\n    }\n    save() {\n        return { self: this.savePrimitive() };\n    }\n    load(savedState, meta) {\n        this.loadPrimitive(savedState === null ? null : nonNull(savedState.self), meta);\n    }\n}\n//# sourceMappingURL=c_primitive.js.map","/**\n * Mixin that adds default implementations of [[IList]]\n * methods to a base class `Base`. `Base` is assumed to extend [[Collab]]\n * and implement the remaining IList methods (or leave them abstract).\n *\n * The implemented methods are those in [[MakeAbstractList_Methods]].\n * You may override their implementations in subclasses.\n *\n * Typically, you do not need to use this mixin directly. Instead,\n * use our predefined instances for the most common `Base` classes:\n * [[AbstractList_Collab]], [[AbstractList_CObject]], [[AbstractList_CPrimitive]],\n * [[AbstractList_PrimitiveCRDT]].\n *\n * If you do need to apply this mixin to a different `Base`, beware that\n * it tricky to use in TypeScript. Specifically, the mixin requires generic type\n * parameters, but you cannot pass a class's generic type parameters to\n * a mixin that it extends. To work around this, we recommend:\n * 1. Declare the mixin usage and its type separately, in `.js`\n * and `.d.ts` files. See the source of [[AbstractList_Collab]]\n * for an example.\n * 2. In `tsconfig.json`, set `\"allowJs\": true`.\n * 3. In your build script, after running `tsc`, copy the `.d.ts` file to the\n * output folder. Otherwise, by default TypeScript auto-generates its own\n * `.d.ts` file from the `.js` file\n * (see [https://github.com/microsoft/TypeScript/issues/39231](https://github.com/microsoft/TypeScript/issues/39231)).\n */\nexport function MakeAbstractList(Base) {\n    class Mixin extends Base {\n        constructor(...args) {\n            super(...args);\n        }\n        hasPosition(position) {\n            return this.indexOfPosition(position) !== -1;\n        }\n        getByPosition(position) {\n            const index = this.indexOfPosition(position);\n            return index === -1 ? undefined : this.get(index);\n        }\n        positionOf(searchElement) {\n            const index = this.indexOf(searchElement);\n            return index === -1 ? undefined : this.getPosition(index);\n        }\n        clear() {\n            for (let i = this.length - 1; i >= 0; i--) {\n                this.delete(i);\n            }\n        }\n        [Symbol.iterator]() {\n            return this.values();\n        }\n        *values() {\n            for (const [, value] of this.entries()) {\n                yield value;\n            }\n        }\n        *positions() {\n            for (const [, , position] of this.entries()) {\n                yield position;\n            }\n        }\n        toString() {\n            return [...this.values()].toString();\n        }\n        // Convenience mutators\n        push(...args) {\n            return this.insert(this.length, ...args);\n        }\n        unshift(...args) {\n            return this.insert(0, ...args);\n        }\n        // Convenience accessors\n        // For tree-based list CRDTs, iterating with entries()\n        // is generally faster than calling get(i) for every i\n        // (O(n) vs O(nlog(n))).\n        // Hence we use entries()/values() in these accessors when possible.\n        forEach(callbackfn, thisArg // eslint-disable-line @typescript-eslint/no-explicit-any\n        ) {\n            for (const [i, value] of this.entries()) {\n                callbackfn.call(thisArg, value, i, this);\n            }\n        }\n        map(callbackfn, thisArg // eslint-disable-line @typescript-eslint/no-explicit-any\n        ) {\n            const ans = new Array(this.length);\n            for (const [i, value] of this.entries()) {\n                ans[i] = callbackfn.call(thisArg, value, i, this);\n            }\n            return ans;\n        }\n        slice(start, end) {\n            const len = this.length;\n            if (start === undefined || start < -len) {\n                start = 0;\n            }\n            else if (start < 0) {\n                start += len;\n            }\n            else if (start >= len) {\n                return [];\n            }\n            if (end === undefined || end >= len) {\n                end = len;\n            }\n            else if (end < -len) {\n                end = 0;\n            }\n            else if (end < 0) {\n                end += len;\n            }\n            if (end <= start)\n                return [];\n            // Optimize common case (slice()).\n            if (start === 0 && end === len) {\n                return [...this.values()];\n            }\n            else {\n                const ans = new Array(end - start);\n                for (let i = 0; i < end - start; i++) {\n                    ans[i] = this.get(start + i);\n                }\n                return ans;\n            }\n        }\n        indexOf(searchElement, fromIndex = 0) {\n            if (fromIndex < 0)\n                fromIndex += this.length;\n            if (fromIndex < 0)\n                fromIndex = 0;\n            if (fromIndex === 0) {\n                // Optimize common case (indexOf(searchElement)).\n                for (const [i, value] of this.entries()) {\n                    if (value === searchElement)\n                        return i;\n                }\n            }\n            else {\n                for (let i = fromIndex; i < this.length; i++) {\n                    if (this.get(i) === searchElement)\n                        return i;\n                }\n            }\n            return -1;\n        }\n    }\n    return Mixin;\n}\n//# sourceMappingURL=abstract_list.js.map","import { CObject, CPrimitive } from \"../base_collabs\";\nimport { Collab } from \"../core\";\nimport { MakeAbstractList } from \"./abstract_list\";\nexport const AbstractList_Collab = MakeAbstractList(Collab);\nexport const AbstractList_CObject = MakeAbstractList(CObject);\nexport const AbstractList_CPrimitive = MakeAbstractList(CPrimitive);\n//# sourceMappingURL=abstract_lists.js.map","/**\n * Mixin that adds default implementations of [[IMap]]\n * methods to a base class `Base`. `Base` is assumed to extend [[Collab]]\n * and implement the remaining IMap methods (or leave them abstract).\n *\n * The implemented methods are those in [[MakeAbstractMap_Methods]].\n * You may override their implementations in subclasses.\n *\n * Typically, you do not need to use this mixin directly. Instead,\n * use our predefined instances for the most common `Base` classes:\n * [[AbstractMap_Collab]], [[AbstractMap_CObject]], [[AbstractMap_CPrimitive]],\n * [[AbstractMap_PrimitiveCRDT]].\n *\n * If you do need to apply this mixin to a different `Base`, beware that\n * it tricky to use in TypeScript. Specifically, the mixin requires generic type\n * parameters, but you cannot pass a class's generic type parameters to\n * a mixin that it extends. To work around this, we recommend:\n * 1. Declare the mixin usage and its type separately, in `.js`\n * and `.d.ts` files. See the source of [[AbstractMap_Collab]]\n * for an example.\n * 2. In `tsconfig.json`, set `\"allowJs\": true`.\n * 3. In your build script, after running `tsc`, copy the `.d.ts` file to the\n * output folder. Otherwise, by default TypeScript auto-generates its own\n * `.d.ts` file from the `.js` file\n * (see [https://github.com/microsoft/TypeScript/issues/39231](https://github.com/microsoft/TypeScript/issues/39231)).\n */\nexport function MakeAbstractMap(Base) {\n    class Mixin extends Base {\n        constructor(...args) {\n            super(...args);\n        }\n        clear() {\n            for (const key of this.keys())\n                this.delete(key);\n        }\n        forEach(callbackfn, thisArg // eslint-disable-line @typescript-eslint/no-explicit-any\n        ) {\n            // Not sure if this gives the exact same semantics\n            // as Map if callbackfn modifies this during the\n            // loop.  (Given that Array.forEach has a rather\n            // funky polyfill on MDN, I expect Map.forEach is\n            // similarly funky.)  Although users probably shouldn't\n            // be doing that anyway.\n            for (const [key, value] of this) {\n                callbackfn.call(thisArg, value, key, this);\n            }\n        }\n        [Symbol.iterator]() {\n            return this.entries();\n        }\n        *keys() {\n            for (const [key] of this)\n                yield key;\n        }\n        *values() {\n            for (const [, value] of this)\n                yield value;\n        }\n        toString() {\n            return [...this].toString();\n        }\n        keyOf(searchElement) {\n            for (const [key, value] of this) {\n                if (value === searchElement)\n                    return key;\n            }\n            return undefined;\n        }\n    }\n    return Mixin;\n}\n//# sourceMappingURL=abstract_map.js.map","import { CObject, CPrimitive } from \"../base_collabs\";\nimport { Collab } from \"../core\";\nimport { MakeAbstractMap } from \"./abstract_map\";\nexport const AbstractMap_Collab = MakeAbstractMap(Collab);\nexport const AbstractMap_CObject = MakeAbstractMap(CObject);\nexport const AbstractMap_CPrimitive = MakeAbstractMap(CPrimitive);\n//# sourceMappingURL=abstract_maps.js.map","/**\n * Mixin that adds default implementations of [[ISet]]\n * methods to a base class `Base`. `Base` is assumed to extend [[Collab]]\n * and implement the remaining ISet methods (or leave them abstract).\n *\n * The implemented methods are those in [[MakeAbstractSet_Methods]].\n * You may override their implementations in subclasses.\n *\n * Typically, you do not need to use this mixin directly. Instead,\n * use our predefined instances for the most common `Base` classes:\n * [[AbstractSet_Collab]], [[AbstractSet_CObject]], [[AbstractSet_CPrimitive]],\n * [[AbstractSet_PrimitiveCRDT]].\n *\n * If you do need to apply this mixin to a different `Base`, beware that\n * it tricky to use in TypeScript. Specifically, the mixin requires generic type\n * parameters, but you cannot pass a class's generic type parameters to\n * a mixin that it extends. To work around this, we recommend:\n * 1. Declare the mixin usage and its type separately, in `.js`\n * and `.d.ts` files. See the source of [[AbstractSet_Collab]]\n * for an example.\n * 2. In `tsconfig.json`, set `\"allowJs\": true`.\n * 3. In your build script, after running `tsc`, copy the `.d.ts` file to the\n * output folder. Otherwise, by default TypeScript auto-generates its own\n * `.d.ts` file from the `.js` file\n * (see [https://github.com/microsoft/TypeScript/issues/39231](https://github.com/microsoft/TypeScript/issues/39231)).\n */\nexport function MakeAbstractSet(Base) {\n    class Mixin extends Base {\n        constructor(...args) {\n            super(...args);\n        }\n        clear() {\n            for (const value of this)\n                this.delete(value);\n        }\n        forEach(callbackfn, thisArg // eslint-disable-line @typescript-eslint/no-explicit-any\n        ) {\n            // Not sure if this gives the exact same semantics\n            // as Set if callbackfn modifies this during the\n            // loop.  (Given that Array.forEach has a rather\n            // funky polyfill on MDN, I expect Set.forEach is\n            // similarly funky.)  Although users probably shouldn't\n            // be doing that anyway.\n            for (const value of this) {\n                callbackfn.call(thisArg, value, value, this);\n            }\n        }\n        [Symbol.iterator]() {\n            return this.values();\n        }\n        toString() {\n            return [...this].toString();\n        }\n    }\n    return Mixin;\n}\n//# sourceMappingURL=abstract_set.js.map","import { CObject, CPrimitive } from \"../base_collabs\";\nimport { Collab } from \"../core\";\nimport { MakeAbstractSet } from \"./abstract_set\";\nexport const AbstractSet_Collab = MakeAbstractSet(Collab);\nexport const AbstractSet_CObject = MakeAbstractSet(CObject);\nexport const AbstractSet_CPrimitive = MakeAbstractSet(CPrimitive);\n//# sourceMappingURL=abstract_sets.js.map","import { CPrimitive } from \"../base_collabs/c_primitive\";\n/**\n * [[Collab]] wrapper for a constant value.\n *\n * This class lets you use constant values in contexts that require\n * a Collab, e.g., [[CList]]. In most cases, though, you can instead\n * use a \"Value\" collection like [[CValueList]], which will be more\n * memory-efficient.\n */\nexport class CConst extends CPrimitive {\n    constructor(init, value) {\n        super(init);\n        this.value = value;\n    }\n    receivePrimitive() {\n        // No-op.\n    }\n    savePrimitive() {\n        return new Uint8Array();\n    }\n    loadPrimitive() {\n        // No-op.\n    }\n    canGC() {\n        return true;\n    }\n}\n//# sourceMappingURL=c_const.js.map","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/**\n * Utilities for working with [[Cursor]]s.\n */\nexport class Cursors {\n    constructor() {\n        // Not instantiable.\n    }\n    /**\n     * Returns the [[Cursor]] at `index` within the given list.\n     * Invert with [[toIndex]].\n     *\n     * That is, the cursor is between the list elements at `index - 1` and `index`.\n     *\n     * @param list The target list.\n     */\n    static fromIndex(index, list) {\n        return index === 0 ? \"START\" : list.getPosition(index - 1);\n    }\n    /**\n     * Returns the current index of `cursor` within the given list. Inverse of [[fromIndex]].\n     *\n     * That is, the cursor is between the list elements at `index - 1` and `index`.\n     *\n     * @param cursor The [[Cursor]].\n     * @param list The target list.\n     */\n    static toIndex(cursor, list) {\n        return cursor === \"START\" ? 0 : list.indexOfPosition(cursor, \"left\") + 1;\n    }\n}\n//# sourceMappingURL=cursors.js.map","\"use strict\";\r\nmodule.exports = asPromise;\r\n\r\n/**\r\n * Callback as used by {@link util.asPromise}.\r\n * @typedef asPromiseCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {...*} params Additional arguments\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Returns a promise from a node-style callback function.\r\n * @memberof util\r\n * @param {asPromiseCallback} fn Function to call\r\n * @param {*} ctx Function context\r\n * @param {...*} params Function arguments\r\n * @returns {Promise<*>} Promisified function\r\n */\r\nfunction asPromise(fn, ctx/*, varargs */) {\r\n    var params  = new Array(arguments.length - 1),\r\n        offset  = 0,\r\n        index   = 2,\r\n        pending = true;\r\n    while (index < arguments.length)\r\n        params[offset++] = arguments[index++];\r\n    return new Promise(function executor(resolve, reject) {\r\n        params[offset] = function callback(err/*, varargs */) {\r\n            if (pending) {\r\n                pending = false;\r\n                if (err)\r\n                    reject(err);\r\n                else {\r\n                    var params = new Array(arguments.length - 1),\r\n                        offset = 0;\r\n                    while (offset < params.length)\r\n                        params[offset++] = arguments[offset];\r\n                    resolve.apply(null, params);\r\n                }\r\n            }\r\n        };\r\n        try {\r\n            fn.apply(ctx || null, params);\r\n        } catch (err) {\r\n            if (pending) {\r\n                pending = false;\r\n                reject(err);\r\n            }\r\n        }\r\n    });\r\n}\r\n","\"use strict\";\r\n\r\n/**\r\n * A minimal base64 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar base64 = exports;\r\n\r\n/**\r\n * Calculates the byte length of a base64 encoded string.\r\n * @param {string} string Base64 encoded string\r\n * @returns {number} Byte length\r\n */\r\nbase64.length = function length(string) {\r\n    var p = string.length;\r\n    if (!p)\r\n        return 0;\r\n    var n = 0;\r\n    while (--p % 4 > 1 && string.charAt(p) === \"=\")\r\n        ++n;\r\n    return Math.ceil(string.length * 3) / 4 - n;\r\n};\r\n\r\n// Base64 encoding table\r\nvar b64 = new Array(64);\r\n\r\n// Base64 decoding table\r\nvar s64 = new Array(123);\r\n\r\n// 65..90, 97..122, 48..57, 43, 47\r\nfor (var i = 0; i < 64;)\r\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\r\n\r\n/**\r\n * Encodes a buffer to a base64 encoded string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} Base64 encoded string\r\n */\r\nbase64.encode = function encode(buffer, start, end) {\r\n    var parts = null,\r\n        chunk = [];\r\n    var i = 0, // output index\r\n        j = 0, // goto index\r\n        t;     // temporary\r\n    while (start < end) {\r\n        var b = buffer[start++];\r\n        switch (j) {\r\n            case 0:\r\n                chunk[i++] = b64[b >> 2];\r\n                t = (b & 3) << 4;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                chunk[i++] = b64[t | b >> 4];\r\n                t = (b & 15) << 2;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                chunk[i++] = b64[t | b >> 6];\r\n                chunk[i++] = b64[b & 63];\r\n                j = 0;\r\n                break;\r\n        }\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (j) {\r\n        chunk[i++] = b64[t];\r\n        chunk[i++] = 61;\r\n        if (j === 1)\r\n            chunk[i++] = 61;\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\nvar invalidEncoding = \"invalid encoding\";\r\n\r\n/**\r\n * Decodes a base64 encoded string to a buffer.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Number of bytes written\r\n * @throws {Error} If encoding is invalid\r\n */\r\nbase64.decode = function decode(string, buffer, offset) {\r\n    var start = offset;\r\n    var j = 0, // goto index\r\n        t;     // temporary\r\n    for (var i = 0; i < string.length;) {\r\n        var c = string.charCodeAt(i++);\r\n        if (c === 61 && j > 1)\r\n            break;\r\n        if ((c = s64[c]) === undefined)\r\n            throw Error(invalidEncoding);\r\n        switch (j) {\r\n            case 0:\r\n                t = c;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                buffer[offset++] = t << 2 | (c & 48) >> 4;\r\n                t = c;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\r\n                t = c;\r\n                j = 3;\r\n                break;\r\n            case 3:\r\n                buffer[offset++] = (t & 3) << 6 | c;\r\n                j = 0;\r\n                break;\r\n        }\r\n    }\r\n    if (j === 1)\r\n        throw Error(invalidEncoding);\r\n    return offset - start;\r\n};\r\n\r\n/**\r\n * Tests if the specified string appears to be base64 encoded.\r\n * @param {string} string String to test\r\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\r\n */\r\nbase64.test = function test(string) {\r\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\r\n};\r\n","\"use strict\";\r\nmodule.exports = EventEmitter;\r\n\r\n/**\r\n * Constructs a new event emitter instance.\r\n * @classdesc A minimal event emitter.\r\n * @memberof util\r\n * @constructor\r\n */\r\nfunction EventEmitter() {\r\n\r\n    /**\r\n     * Registered listeners.\r\n     * @type {Object.<string,*>}\r\n     * @private\r\n     */\r\n    this._listeners = {};\r\n}\r\n\r\n/**\r\n * Registers an event listener.\r\n * @param {string} evt Event name\r\n * @param {function} fn Listener\r\n * @param {*} [ctx] Listener context\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.on = function on(evt, fn, ctx) {\r\n    (this._listeners[evt] || (this._listeners[evt] = [])).push({\r\n        fn  : fn,\r\n        ctx : ctx || this\r\n    });\r\n    return this;\r\n};\r\n\r\n/**\r\n * Removes an event listener or any matching listeners if arguments are omitted.\r\n * @param {string} [evt] Event name. Removes all listeners if omitted.\r\n * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.off = function off(evt, fn) {\r\n    if (evt === undefined)\r\n        this._listeners = {};\r\n    else {\r\n        if (fn === undefined)\r\n            this._listeners[evt] = [];\r\n        else {\r\n            var listeners = this._listeners[evt];\r\n            for (var i = 0; i < listeners.length;)\r\n                if (listeners[i].fn === fn)\r\n                    listeners.splice(i, 1);\r\n                else\r\n                    ++i;\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Emits an event by calling its listeners with the specified arguments.\r\n * @param {string} evt Event name\r\n * @param {...*} args Arguments\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.emit = function emit(evt) {\r\n    var listeners = this._listeners[evt];\r\n    if (listeners) {\r\n        var args = [],\r\n            i = 1;\r\n        for (; i < arguments.length;)\r\n            args.push(arguments[i++]);\r\n        for (i = 0; i < listeners.length;)\r\n            listeners[i].fn.apply(listeners[i++].ctx, args);\r\n    }\r\n    return this;\r\n};\r\n","\"use strict\";\r\n\r\nmodule.exports = factory(factory);\r\n\r\n/**\r\n * Reads / writes floats / doubles from / to buffers.\r\n * @name util.float\r\n * @namespace\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using little endian byte order.\r\n * @name util.float.writeFloatLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using big endian byte order.\r\n * @name util.float.writeFloatBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using little endian byte order.\r\n * @name util.float.readFloatLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using big endian byte order.\r\n * @name util.float.readFloatBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using little endian byte order.\r\n * @name util.float.writeDoubleLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using big endian byte order.\r\n * @name util.float.writeDoubleBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using little endian byte order.\r\n * @name util.float.readDoubleLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using big endian byte order.\r\n * @name util.float.readDoubleBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n// Factory function for the purpose of node-based testing in modified global environments\r\nfunction factory(exports) {\r\n\r\n    // float: typed array\r\n    if (typeof Float32Array !== \"undefined\") (function() {\r\n\r\n        var f32 = new Float32Array([ -0 ]),\r\n            f8b = new Uint8Array(f32.buffer),\r\n            le  = f8b[3] === 128;\r\n\r\n        function writeFloat_f32_cpy(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n        }\r\n\r\n        function writeFloat_f32_rev(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[3];\r\n            buf[pos + 1] = f8b[2];\r\n            buf[pos + 2] = f8b[1];\r\n            buf[pos + 3] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\r\n\r\n        function readFloat_f32_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        function readFloat_f32_rev(buf, pos) {\r\n            f8b[3] = buf[pos    ];\r\n            f8b[2] = buf[pos + 1];\r\n            f8b[1] = buf[pos + 2];\r\n            f8b[0] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\r\n\r\n    // float: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0)\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);\r\n            else if (isNaN(val))\r\n                writeUint(2143289344, buf, pos);\r\n            else if (val > 3.4028234663852886e+38) // +-Infinity\r\n                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\r\n            else if (val < 1.1754943508222875e-38) // denormal\r\n                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);\r\n            else {\r\n                var exponent = Math.floor(Math.log(val) / Math.LN2),\r\n                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\r\n                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\r\n            }\r\n        }\r\n\r\n        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\r\n        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\r\n\r\n        function readFloat_ieee754(readUint, buf, pos) {\r\n            var uint = readUint(buf, pos),\r\n                sign = (uint >> 31) * 2 + 1,\r\n                exponent = uint >>> 23 & 255,\r\n                mantissa = uint & 8388607;\r\n            return exponent === 255\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 1.401298464324817e-45 * mantissa\r\n                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\r\n        }\r\n\r\n        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\r\n        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\r\n\r\n    })();\r\n\r\n    // double: typed array\r\n    if (typeof Float64Array !== \"undefined\") (function() {\r\n\r\n        var f64 = new Float64Array([-0]),\r\n            f8b = new Uint8Array(f64.buffer),\r\n            le  = f8b[7] === 128;\r\n\r\n        function writeDouble_f64_cpy(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n            buf[pos + 4] = f8b[4];\r\n            buf[pos + 5] = f8b[5];\r\n            buf[pos + 6] = f8b[6];\r\n            buf[pos + 7] = f8b[7];\r\n        }\r\n\r\n        function writeDouble_f64_rev(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[7];\r\n            buf[pos + 1] = f8b[6];\r\n            buf[pos + 2] = f8b[5];\r\n            buf[pos + 3] = f8b[4];\r\n            buf[pos + 4] = f8b[3];\r\n            buf[pos + 5] = f8b[2];\r\n            buf[pos + 6] = f8b[1];\r\n            buf[pos + 7] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\r\n\r\n        function readDouble_f64_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            f8b[4] = buf[pos + 4];\r\n            f8b[5] = buf[pos + 5];\r\n            f8b[6] = buf[pos + 6];\r\n            f8b[7] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        function readDouble_f64_rev(buf, pos) {\r\n            f8b[7] = buf[pos    ];\r\n            f8b[6] = buf[pos + 1];\r\n            f8b[5] = buf[pos + 2];\r\n            f8b[4] = buf[pos + 3];\r\n            f8b[3] = buf[pos + 4];\r\n            f8b[2] = buf[pos + 5];\r\n            f8b[1] = buf[pos + 6];\r\n            f8b[0] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\r\n\r\n    // double: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);\r\n            } else if (isNaN(val)) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(2146959360, buf, pos + off1);\r\n            } else if (val > 1.7976931348623157e+308) { // +-Infinity\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\r\n            } else {\r\n                var mantissa;\r\n                if (val < 2.2250738585072014e-308) { // denormal\r\n                    mantissa = val / 5e-324;\r\n                    writeUint(mantissa >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\r\n                } else {\r\n                    var exponent = Math.floor(Math.log(val) / Math.LN2);\r\n                    if (exponent === 1024)\r\n                        exponent = 1023;\r\n                    mantissa = val * Math.pow(2, -exponent);\r\n                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\r\n                }\r\n            }\r\n        }\r\n\r\n        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\r\n        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\r\n\r\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\r\n            var lo = readUint(buf, pos + off0),\r\n                hi = readUint(buf, pos + off1);\r\n            var sign = (hi >> 31) * 2 + 1,\r\n                exponent = hi >>> 20 & 2047,\r\n                mantissa = 4294967296 * (hi & 1048575) + lo;\r\n            return exponent === 2047\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 5e-324 * mantissa\r\n                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\r\n        }\r\n\r\n        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\r\n        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\r\n\r\n    })();\r\n\r\n    return exports;\r\n}\r\n\r\n// uint helpers\r\n\r\nfunction writeUintLE(val, buf, pos) {\r\n    buf[pos    ] =  val        & 255;\r\n    buf[pos + 1] =  val >>> 8  & 255;\r\n    buf[pos + 2] =  val >>> 16 & 255;\r\n    buf[pos + 3] =  val >>> 24;\r\n}\r\n\r\nfunction writeUintBE(val, buf, pos) {\r\n    buf[pos    ] =  val >>> 24;\r\n    buf[pos + 1] =  val >>> 16 & 255;\r\n    buf[pos + 2] =  val >>> 8  & 255;\r\n    buf[pos + 3] =  val        & 255;\r\n}\r\n\r\nfunction readUintLE(buf, pos) {\r\n    return (buf[pos    ]\r\n          | buf[pos + 1] << 8\r\n          | buf[pos + 2] << 16\r\n          | buf[pos + 3] << 24) >>> 0;\r\n}\r\n\r\nfunction readUintBE(buf, pos) {\r\n    return (buf[pos    ] << 24\r\n          | buf[pos + 1] << 16\r\n          | buf[pos + 2] << 8\r\n          | buf[pos + 3]) >>> 0;\r\n}\r\n","\"use strict\";\r\nmodule.exports = inquire;\r\n\r\n/**\r\n * Requires a module only if available.\r\n * @memberof util\r\n * @param {string} moduleName Module to require\r\n * @returns {?Object} Required module if available and not empty, otherwise `null`\r\n */\r\nfunction inquire(moduleName) {\r\n    try {\r\n        var mod = eval(\"quire\".replace(/^/,\"re\"))(moduleName); // eslint-disable-line no-eval\r\n        if (mod && (mod.length || Object.keys(mod).length))\r\n            return mod;\r\n    } catch (e) {} // eslint-disable-line no-empty\r\n    return null;\r\n}\r\n","\"use strict\";\r\n\r\n/**\r\n * A minimal UTF8 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar utf8 = exports;\r\n\r\n/**\r\n * Calculates the UTF8 byte length of a string.\r\n * @param {string} string String\r\n * @returns {number} Byte length\r\n */\r\nutf8.length = function utf8_length(string) {\r\n    var len = 0,\r\n        c = 0;\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c = string.charCodeAt(i);\r\n        if (c < 128)\r\n            len += 1;\r\n        else if (c < 2048)\r\n            len += 2;\r\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\r\n            ++i;\r\n            len += 4;\r\n        } else\r\n            len += 3;\r\n    }\r\n    return len;\r\n};\r\n\r\n/**\r\n * Reads UTF8 bytes as a string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} String read\r\n */\r\nutf8.read = function utf8_read(buffer, start, end) {\r\n    var len = end - start;\r\n    if (len < 1)\r\n        return \"\";\r\n    var parts = null,\r\n        chunk = [],\r\n        i = 0, // char offset\r\n        t;     // temporary\r\n    while (start < end) {\r\n        t = buffer[start++];\r\n        if (t < 128)\r\n            chunk[i++] = t;\r\n        else if (t > 191 && t < 224)\r\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\r\n        else if (t > 239 && t < 365) {\r\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\r\n            chunk[i++] = 0xD800 + (t >> 10);\r\n            chunk[i++] = 0xDC00 + (t & 1023);\r\n        } else\r\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\n/**\r\n * Writes a string as UTF8 bytes.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Bytes written\r\n */\r\nutf8.write = function utf8_write(string, buffer, offset) {\r\n    var start = offset,\r\n        c1, // character 1\r\n        c2; // character 2\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c1 = string.charCodeAt(i);\r\n        if (c1 < 128) {\r\n            buffer[offset++] = c1;\r\n        } else if (c1 < 2048) {\r\n            buffer[offset++] = c1 >> 6       | 192;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\r\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n            ++i;\r\n            buffer[offset++] = c1 >> 18      | 240;\r\n            buffer[offset++] = c1 >> 12 & 63 | 128;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else {\r\n            buffer[offset++] = c1 >> 12      | 224;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        }\r\n    }\r\n    return offset - start;\r\n};\r\n","\"use strict\";\r\nmodule.exports = pool;\r\n\r\n/**\r\n * An allocator as used by {@link util.pool}.\r\n * @typedef PoolAllocator\r\n * @type {function}\r\n * @param {number} size Buffer size\r\n * @returns {Uint8Array} Buffer\r\n */\r\n\r\n/**\r\n * A slicer as used by {@link util.pool}.\r\n * @typedef PoolSlicer\r\n * @type {function}\r\n * @param {number} start Start offset\r\n * @param {number} end End offset\r\n * @returns {Uint8Array} Buffer slice\r\n * @this {Uint8Array}\r\n */\r\n\r\n/**\r\n * A general purpose buffer pool.\r\n * @memberof util\r\n * @function\r\n * @param {PoolAllocator} alloc Allocator\r\n * @param {PoolSlicer} slice Slicer\r\n * @param {number} [size=8192] Slab size\r\n * @returns {PoolAllocator} Pooled allocator\r\n */\r\nfunction pool(alloc, slice, size) {\r\n    var SIZE   = size || 8192;\r\n    var MAX    = SIZE >>> 1;\r\n    var slab   = null;\r\n    var offset = SIZE;\r\n    return function pool_alloc(size) {\r\n        if (size < 1 || size > MAX)\r\n            return alloc(size);\r\n        if (offset + size > SIZE) {\r\n            slab = alloc(SIZE);\r\n            offset = 0;\r\n        }\r\n        var buf = slice.call(slab, offset, offset += size);\r\n        if (offset & 7) // align to 32 bit\r\n            offset = (offset | 7) + 1;\r\n        return buf;\r\n    };\r\n}\r\n","\"use strict\";\nmodule.exports = LongBits;\n\nvar util = require(\"../util/minimal\");\n\n/**\n * Constructs new long bits.\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @constructor\n * @param {number} lo Low 32 bits, unsigned\n * @param {number} hi High 32 bits, unsigned\n */\nfunction LongBits(lo, hi) {\n\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n    /**\n     * Low bits.\n     * @type {number}\n     */\n    this.lo = lo >>> 0;\n\n    /**\n     * High bits.\n     * @type {number}\n     */\n    this.hi = hi >>> 0;\n}\n\n/**\n * Zero bits.\n * @memberof util.LongBits\n * @type {util.LongBits}\n */\nvar zero = LongBits.zero = new LongBits(0, 0);\n\nzero.toNumber = function() { return 0; };\nzero.zzEncode = zero.zzDecode = function() { return this; };\nzero.length = function() { return 1; };\n\n/**\n * Zero hash.\n * @memberof util.LongBits\n * @type {string}\n */\nvar zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n\n/**\n * Constructs new long bits from the specified number.\n * @param {number} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.fromNumber = function fromNumber(value) {\n    if (value === 0)\n        return zero;\n    var sign = value < 0;\n    if (sign)\n        value = -value;\n    var lo = value >>> 0,\n        hi = (value - lo) / 4294967296 >>> 0;\n    if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n            lo = 0;\n            if (++hi > 4294967295)\n                hi = 0;\n        }\n    }\n    return new LongBits(lo, hi);\n};\n\n/**\n * Constructs new long bits from a number, long or string.\n * @param {Long|number|string} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.from = function from(value) {\n    if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n    if (util.isString(value)) {\n        /* istanbul ignore else */\n        if (util.Long)\n            value = util.Long.fromString(value);\n        else\n            return LongBits.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n};\n\n/**\n * Converts this long bits to a possibly unsafe JavaScript number.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {number} Possibly unsafe number\n */\nLongBits.prototype.toNumber = function toNumber(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0,\n            hi = ~this.hi     >>> 0;\n        if (!lo)\n            hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n};\n\n/**\n * Converts this long bits to a long.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long} Long\n */\nLongBits.prototype.toLong = function toLong(unsigned) {\n    return util.Long\n        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\n        /* istanbul ignore next */\n        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n};\n\nvar charCodeAt = String.prototype.charCodeAt;\n\n/**\n * Constructs new long bits from the specified 8 characters long hash.\n * @param {string} hash Hash\n * @returns {util.LongBits} Bits\n */\nLongBits.fromHash = function fromHash(hash) {\n    if (hash === zeroHash)\n        return zero;\n    return new LongBits(\n        ( charCodeAt.call(hash, 0)\n        | charCodeAt.call(hash, 1) << 8\n        | charCodeAt.call(hash, 2) << 16\n        | charCodeAt.call(hash, 3) << 24) >>> 0\n    ,\n        ( charCodeAt.call(hash, 4)\n        | charCodeAt.call(hash, 5) << 8\n        | charCodeAt.call(hash, 6) << 16\n        | charCodeAt.call(hash, 7) << 24) >>> 0\n    );\n};\n\n/**\n * Converts this long bits to a 8 characters long hash.\n * @returns {string} Hash\n */\nLongBits.prototype.toHash = function toHash() {\n    return String.fromCharCode(\n        this.lo        & 255,\n        this.lo >>> 8  & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24      ,\n        this.hi        & 255,\n        this.hi >>> 8  & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n    );\n};\n\n/**\n * Zig-zag encodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzEncode = function zzEncode() {\n    var mask =   this.hi >> 31;\n    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Zig-zag decodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Calculates the length of this longbits when encoded as a varint.\n * @returns {number} Length\n */\nLongBits.prototype.length = function length() {\n    var part0 =  this.lo,\n        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\n        part2 =  this.hi >>> 24;\n    return part2 === 0\n         ? part1 === 0\n           ? part0 < 16384\n             ? part0 < 128 ? 1 : 2\n             : part0 < 2097152 ? 3 : 4\n           : part1 < 16384\n             ? part1 < 128 ? 5 : 6\n             : part1 < 2097152 ? 7 : 8\n         : part2 < 128 ? 9 : 10;\n};\n","\"use strict\";\nvar util = exports;\n\n// used to return a Promise where callback is omitted\nutil.asPromise = require(\"@protobufjs/aspromise\");\n\n// converts to / from base64 encoded strings\nutil.base64 = require(\"@protobufjs/base64\");\n\n// base class of rpc.Service\nutil.EventEmitter = require(\"@protobufjs/eventemitter\");\n\n// float handling accross browsers\nutil.float = require(\"@protobufjs/float\");\n\n// requires modules optionally and hides the call from bundlers\nutil.inquire = require(\"@protobufjs/inquire\");\n\n// converts to / from utf8 encoded strings\nutil.utf8 = require(\"@protobufjs/utf8\");\n\n// provides a node-like buffer pool in the browser\nutil.pool = require(\"@protobufjs/pool\");\n\n// utility to work with the low and high bits of a 64 bit value\nutil.LongBits = require(\"./longbits\");\n\n// global object reference\nutil.global = typeof window !== \"undefined\" && window\n           || typeof global !== \"undefined\" && global\n           || typeof self   !== \"undefined\" && self\n           || this; // eslint-disable-line no-invalid-this\n\n/**\n * An immuable empty array.\n * @memberof util\n * @type {Array.<*>}\n * @const\n */\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\n\n/**\n * An immutable empty object.\n * @type {Object}\n * @const\n */\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\n\n/**\n * Whether running within node or not.\n * @memberof util\n * @type {boolean}\n * @const\n */\nutil.isNode = Boolean(util.global.process && util.global.process.versions && util.global.process.versions.node);\n\n/**\n * Tests if the specified value is an integer.\n * @function\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is an integer\n */\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n\n/**\n * Tests if the specified value is a string.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a string\n */\nutil.isString = function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n};\n\n/**\n * Tests if the specified value is a non-null object.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a non-null object\n */\nutil.isObject = function isObject(value) {\n    return value && typeof value === \"object\";\n};\n\n/**\n * Checks if a property on a message is considered to be present.\n * This is an alias of {@link util.isSet}.\n * @function\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isset =\n\n/**\n * Checks if a property on a message is considered to be present.\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isSet = function isSet(obj, prop) {\n    var value = obj[prop];\n    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n    return false;\n};\n\n/**\n * Any compatible Buffer instance.\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\n * @interface Buffer\n * @extends Uint8Array\n */\n\n/**\n * Node's Buffer class if available.\n * @type {Constructor<Buffer>}\n */\nutil.Buffer = (function() {\n    try {\n        var Buffer = util.inquire(\"buffer\").Buffer;\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\n    } catch (e) {\n        /* istanbul ignore next */\n        return null;\n    }\n})();\n\n// Internal alias of or polyfull for Buffer.from.\nutil._Buffer_from = null;\n\n// Internal alias of or polyfill for Buffer.allocUnsafe.\nutil._Buffer_allocUnsafe = null;\n\n/**\n * Creates a new buffer of whatever type supported by the environment.\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n * @returns {Uint8Array|Buffer} Buffer\n */\nutil.newBuffer = function newBuffer(sizeOrArray) {\n    /* istanbul ignore next */\n    return typeof sizeOrArray === \"number\"\n        ? util.Buffer\n            ? util._Buffer_allocUnsafe(sizeOrArray)\n            : new util.Array(sizeOrArray)\n        : util.Buffer\n            ? util._Buffer_from(sizeOrArray)\n            : typeof Uint8Array === \"undefined\"\n                ? sizeOrArray\n                : new Uint8Array(sizeOrArray);\n};\n\n/**\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n * @type {Constructor<Uint8Array>}\n */\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */ : Array;\n\n/**\n * Any compatible Long instance.\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n * @interface Long\n * @property {number} low Low bits\n * @property {number} high High bits\n * @property {boolean} unsigned Whether unsigned or not\n */\n\n/**\n * Long.js's Long class if available.\n * @type {Constructor<Long>}\n */\nutil.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long\n         || /* istanbul ignore next */ util.global.Long\n         || util.inquire(\"long\");\n\n/**\n * Regular expression used to verify 2 bit (`bool`) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key2Re = /^true|false|0|1$/;\n\n/**\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n\n/**\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n\n/**\n * Converts a number or long to an 8 characters long hash string.\n * @param {Long|number} value Value to convert\n * @returns {string} Hash\n */\nutil.longToHash = function longToHash(value) {\n    return value\n        ? util.LongBits.from(value).toHash()\n        : util.LongBits.zeroHash;\n};\n\n/**\n * Converts an 8 characters long hash string to a long or number.\n * @param {string} hash Hash\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long|number} Original value\n */\nutil.longFromHash = function longFromHash(hash, unsigned) {\n    var bits = util.LongBits.fromHash(hash);\n    if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n    return bits.toNumber(Boolean(unsigned));\n};\n\n/**\n * Merges the properties of the source object into the destination object.\n * @memberof util\n * @param {Object.<string,*>} dst Destination object\n * @param {Object.<string,*>} src Source object\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n * @returns {Object.<string,*>} Destination object\n */\nfunction merge(dst, src, ifNotSet) { // used by converters\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === undefined || !ifNotSet)\n            dst[keys[i]] = src[keys[i]];\n    return dst;\n}\n\nutil.merge = merge;\n\n/**\n * Converts the first character of a string to lower case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.lcFirst = function lcFirst(str) {\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\n\n/**\n * Creates a custom error constructor.\n * @memberof util\n * @param {string} name Error name\n * @returns {Constructor<Error>} Custom error constructor\n */\nfunction newError(name) {\n\n    function CustomError(message, properties) {\n\n        if (!(this instanceof CustomError))\n            return new CustomError(message, properties);\n\n        // Error.call(this, message);\n        // ^ just returns a new error instance because the ctor can be called as a function\n\n        Object.defineProperty(this, \"message\", { get: function() { return message; } });\n\n        /* istanbul ignore next */\n        if (Error.captureStackTrace) // node\n            Error.captureStackTrace(this, CustomError);\n        else\n            Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" });\n\n        if (properties)\n            merge(this, properties);\n    }\n\n    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;\n\n    Object.defineProperty(CustomError.prototype, \"name\", { get: function() { return name; } });\n\n    CustomError.prototype.toString = function toString() {\n        return this.name + \": \" + this.message;\n    };\n\n    return CustomError;\n}\n\nutil.newError = newError;\n\n/**\n * Constructs a new protocol error.\n * @classdesc Error subclass indicating a protocol specifc error.\n * @memberof util\n * @extends Error\n * @template T extends Message<T>\n * @constructor\n * @param {string} message Error message\n * @param {Object.<string,*>} [properties] Additional properties\n * @example\n * try {\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\n * } catch (e) {\n *     if (e instanceof ProtocolError && e.instance)\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\n * }\n */\nutil.ProtocolError = newError(\"ProtocolError\");\n\n/**\n * So far decoded message instance.\n * @name util.ProtocolError#instance\n * @type {Message<T>}\n */\n\n/**\n * A OneOf getter as returned by {@link util.oneOfGetter}.\n * @typedef OneOfGetter\n * @type {function}\n * @returns {string|undefined} Set field name, if any\n */\n\n/**\n * Builds a getter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfGetter} Unbound getter\n */\nutil.oneOfGetter = function getOneOf(fieldNames) {\n    var fieldMap = {};\n    for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n\n    /**\n     * @returns {string|undefined} Set field name, if any\n     * @this Object\n     * @ignore\n     */\n    return function() { // eslint-disable-line consistent-return\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\n                return keys[i];\n    };\n};\n\n/**\n * A OneOf setter as returned by {@link util.oneOfSetter}.\n * @typedef OneOfSetter\n * @type {function}\n * @param {string|undefined} value Field name\n * @returns {undefined}\n */\n\n/**\n * Builds a setter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfSetter} Unbound setter\n */\nutil.oneOfSetter = function setOneOf(fieldNames) {\n\n    /**\n     * @param {string} name Field name\n     * @returns {undefined}\n     * @this Object\n     * @ignore\n     */\n    return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n            if (fieldNames[i] !== name)\n                delete this[fieldNames[i]];\n    };\n};\n\n/**\n * Default conversion options used for {@link Message#toJSON} implementations.\n *\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\n *\n * - Longs become strings\n * - Enums become string keys\n * - Bytes become base64 encoded strings\n * - (Sub-)Messages become plain objects\n * - Maps become plain objects with all string keys\n * - Repeated fields become arrays\n * - NaN and Infinity for float and double fields become strings\n *\n * @type {IConversionOptions}\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\n */\nutil.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: true\n};\n\n// Sets up buffer utility according to the environment (called in index-minimal)\nutil._configure = function() {\n    var Buffer = util.Buffer;\n    /* istanbul ignore if */\n    if (!Buffer) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n    }\n    // because node 4.x buffers are incompatible & immutable\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\n        /* istanbul ignore next */\n        function Buffer_from(value, encoding) {\n            return new Buffer(value, encoding);\n        };\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\n        /* istanbul ignore next */\n        function Buffer_allocUnsafe(size) {\n            return new Buffer(size);\n        };\n};\n","\"use strict\";\nmodule.exports = Writer;\n\nvar util      = require(\"./util/minimal\");\n\nvar BufferWriter; // cyclic\n\nvar LongBits  = util.LongBits,\n    base64    = util.base64,\n    utf8      = util.utf8;\n\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */\nfunction Op(fn, len, val) {\n\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */\n    this.fn = fn;\n\n    /**\n     * Value byte length.\n     * @type {number}\n     */\n    this.len = len;\n\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */\n    this.next = undefined;\n\n    /**\n     * Value to write.\n     * @type {*}\n     */\n    this.val = val; // type varies\n}\n\n/* istanbul ignore next */\nfunction noop() {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */\nfunction State(writer) {\n\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */\n    this.head = writer.head;\n\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */\n    this.tail = writer.tail;\n\n    /**\n     * Current buffer length.\n     * @type {number}\n     */\n    this.len = writer.len;\n\n    /**\n     * Next state.\n     * @type {State|null}\n     */\n    this.next = writer.states;\n}\n\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */\nfunction Writer() {\n\n    /**\n     * Current length.\n     * @type {number}\n     */\n    this.len = 0;\n\n    /**\n     * Operations head.\n     * @type {Object}\n     */\n    this.head = new Op(noop, 0, 0);\n\n    /**\n     * Operations tail\n     * @type {Object}\n     */\n    this.tail = this.head;\n\n    /**\n     * Linked forked states.\n     * @type {Object|null}\n     */\n    this.states = null;\n\n    // When a value is written, the writer calculates its byte length and puts it into a linked\n    // list of operations to perform when finish() is called. This both allows us to allocate\n    // buffers of the exact required size and reduces the amount of work we have to do compared\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\n    // part is just a linked list walk calling operations with already prepared values.\n}\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup() {\n            return (Writer.create = function create_buffer() {\n                return new BufferWriter();\n            })();\n        }\n        /* istanbul ignore next */\n        : function create_array() {\n            return new Writer();\n        };\n};\n\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */\nWriter.create = create();\n\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\nWriter.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */\nif (util.Array !== Array)\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */\nWriter.prototype._push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\n\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\n\nfunction writeVarint32(val, buf, pos) {\n    while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */\nfunction VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\n\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0)\n                < 128       ? 1\n        : value < 16384     ? 2\n        : value < 2097152   ? 3\n        : value < 268435456 ? 4\n        :                     5,\n    value)).len;\n    return this;\n};\n\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.int32 = function write_int32(value) {\n    return value < 0\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n        : this.uint32(value);\n};\n\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\n\nfunction writeVarint64(val, buf, pos) {\n    while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.int64 = Writer.prototype.uint64;\n\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bool = function write_bool(value) {\n    return this._push(writeByte, 1, value ? 1 : 0);\n};\n\nfunction writeFixed32(val, buf, pos) {\n    buf[pos    ] =  val         & 255;\n    buf[pos + 1] =  val >>> 8   & 255;\n    buf[pos + 2] =  val >>> 16  & 255;\n    buf[pos + 3] =  val >>> 24;\n}\n\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.fixed32 = function write_fixed32(value) {\n    return this._push(writeFixed32, 4, value >>> 0);\n};\n\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\n\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\n\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.float = function write_float(value) {\n    return this._push(util.float.writeFloatLE, 4, value);\n};\n\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.double = function write_double(value) {\n    return this._push(util.float.writeDoubleLE, 8, value);\n};\n\nvar writeBytes = util.Array.prototype.set\n    ? function writeBytes_set(val, buf, pos) {\n        buf.set(val, pos); // also works for plain array values\n    }\n    /* istanbul ignore next */\n    : function writeBytes_for(val, buf, pos) {\n        for (var i = 0; i < val.length; ++i)\n            buf[pos + i] = val[i];\n    };\n\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len)\n        return this._push(writeByte, 1, 0);\n    if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len)._push(writeBytes, len, value);\n};\n\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len\n        ? this.uint32(len)._push(utf8.write, len, value)\n        : this._push(writeByte, 1, 0);\n};\n\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */\nWriter.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */\nWriter.prototype.reset = function reset() {\n    if (this.states) {\n        this.head   = this.states.head;\n        this.tail   = this.states.tail;\n        this.len    = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len  = 0;\n    }\n    return this;\n};\n\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */\nWriter.prototype.ldelim = function ldelim() {\n    var head = this.head,\n        tail = this.tail,\n        len  = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */\nWriter.prototype.finish = function finish() {\n    var head = this.head.next, // skip noop\n        buf  = this.constructor.alloc(this.len),\n        pos  = 0;\n    while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\n\nWriter._configure = function(BufferWriter_) {\n    BufferWriter = BufferWriter_;\n    Writer.create = create();\n    BufferWriter._configure();\n};\n","\"use strict\";\nmodule.exports = BufferWriter;\n\n// extends Writer\nvar Writer = require(\"./writer\");\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n\nvar util = require(\"./util/minimal\");\n\n/**\n * Constructs a new buffer writer instance.\n * @classdesc Wire format writer using node buffers.\n * @extends Writer\n * @constructor\n */\nfunction BufferWriter() {\n    Writer.call(this);\n}\n\nBufferWriter._configure = function () {\n    /**\n     * Allocates a buffer of the specified size.\n     * @function\n     * @param {number} size Buffer size\n     * @returns {Buffer} Buffer\n     */\n    BufferWriter.alloc = util._Buffer_allocUnsafe;\n\n    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\"\n        ? function writeBytesBuffer_set(val, buf, pos) {\n          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n          // also works for plain array values\n        }\n        /* istanbul ignore next */\n        : function writeBytesBuffer_copy(val, buf, pos) {\n          if (val.copy) // Buffer values\n            val.copy(buf, pos, 0, val.length);\n          else for (var i = 0; i < val.length;) // plain array values\n            buf[pos++] = val[i++];\n        };\n};\n\n\n/**\n * @override\n */\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n    if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n    var len = value.length >>> 0;\n    this.uint32(len);\n    if (len)\n        this._push(BufferWriter.writeBytesBuffer, len, value);\n    return this;\n};\n\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\n        util.utf8.write(val, buf, pos);\n    else if (buf.utf8Write)\n        buf.utf8Write(val, pos);\n    else\n        buf.write(val, pos);\n}\n\n/**\n * @override\n */\nBufferWriter.prototype.string = function write_string_buffer(value) {\n    var len = util.Buffer.byteLength(value);\n    this.uint32(len);\n    if (len)\n        this._push(writeStringBuffer, len, value);\n    return this;\n};\n\n\n/**\n * Finishes the write operation.\n * @name BufferWriter#finish\n * @function\n * @returns {Buffer} Finished buffer\n */\n\nBufferWriter._configure();\n","\"use strict\";\nmodule.exports = Reader;\n\nvar util      = require(\"./util/minimal\");\n\nvar BufferReader; // cyclic\n\nvar LongBits  = util.LongBits,\n    utf8      = util.utf8;\n\n/* istanbul ignore next */\nfunction indexOutOfRange(reader, writeLength) {\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n}\n\n/**\n * Constructs a new reader instance using the specified buffer.\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n * @param {Uint8Array} buffer Buffer to read from\n */\nfunction Reader(buffer) {\n\n    /**\n     * Read buffer.\n     * @type {Uint8Array}\n     */\n    this.buf = buffer;\n\n    /**\n     * Read buffer position.\n     * @type {number}\n     */\n    this.pos = 0;\n\n    /**\n     * Read buffer length.\n     * @type {number}\n     */\n    this.len = buffer.length;\n}\n\nvar create_array = typeof Uint8Array !== \"undefined\"\n    ? function create_typed_array(buffer) {\n        if (buffer instanceof Uint8Array || Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    }\n    /* istanbul ignore next */\n    : function create_array(buffer) {\n        if (Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    };\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup(buffer) {\n            return (Reader.create = function create_buffer(buffer) {\n                return util.Buffer.isBuffer(buffer)\n                    ? new BufferReader(buffer)\n                    /* istanbul ignore next */\n                    : create_array(buffer);\n            })(buffer);\n        }\n        /* istanbul ignore next */\n        : create_array;\n};\n\n/**\n * Creates a new reader using the specified buffer.\n * @function\n * @param {Uint8Array|Buffer} buffer Buffer to read from\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\n * @throws {Error} If `buffer` is not a valid buffer\n */\nReader.create = create();\n\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\n\n/**\n * Reads a varint as an unsigned 32 bit value.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.uint32 = (function read_uint32_setup() {\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\n    return function read_uint32() {\n        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;\n\n        /* istanbul ignore if */\n        if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    };\n})();\n\n/**\n * Reads a varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.int32 = function read_int32() {\n    return this.uint32() | 0;\n};\n\n/**\n * Reads a zig-zag encoded varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.sint32 = function read_sint32() {\n    var value = this.uint32();\n    return value >>> 1 ^ -(value & 1) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readLongVarint() {\n    // tends to deopt with local vars for octet etc.\n    var bits = new LongBits(0, 0);\n    var i = 0;\n    if (this.len - this.pos > 4) { // fast route (lo)\n        for (; i < 4; ++i) {\n            // 1st..4th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 5th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return bits;\n        i = 0;\n    } else {\n        for (; i < 3; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 1st..3th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 4th\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n        for (; i < 5; ++i) {\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    } else {\n        for (; i < 5; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    }\n    /* istanbul ignore next */\n    throw Error(\"invalid varint encoding\");\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads a varint as a signed 64 bit value.\n * @name Reader#int64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as an unsigned 64 bit value.\n * @name Reader#uint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a zig-zag encoded varint as a signed 64 bit value.\n * @name Reader#sint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as a boolean.\n * @returns {boolean} Value read\n */\nReader.prototype.bool = function read_bool() {\n    return this.uint32() !== 0;\n};\n\nfunction readFixed32_end(buf, end) { // note that this uses `end`, not `pos`\n    return (buf[end - 4]\n          | buf[end - 3] << 8\n          | buf[end - 2] << 16\n          | buf[end - 1] << 24) >>> 0;\n}\n\n/**\n * Reads fixed 32 bits as an unsigned 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.fixed32 = function read_fixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4);\n};\n\n/**\n * Reads fixed 32 bits as a signed 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.sfixed32 = function read_sfixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readFixed64(/* this: Reader */) {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads fixed 64 bits.\n * @name Reader#fixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads zig-zag encoded fixed 64 bits.\n * @name Reader#sfixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a float (32 bit) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.float = function read_float() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readFloatLE(this.buf, this.pos);\n    this.pos += 4;\n    return value;\n};\n\n/**\n * Reads a double (64 bit float) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.double = function read_double() {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readDoubleLE(this.buf, this.pos);\n    this.pos += 8;\n    return value;\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @returns {Uint8Array} Value read\n */\nReader.prototype.bytes = function read_bytes() {\n    var length = this.uint32(),\n        start  = this.pos,\n        end    = this.pos + length;\n\n    /* istanbul ignore if */\n    if (end > this.len)\n        throw indexOutOfRange(this, length);\n\n    this.pos += length;\n    if (Array.isArray(this.buf)) // plain array\n        return this.buf.slice(start, end);\n    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1\n        ? new this.buf.constructor(0)\n        : this._slice.call(this.buf, start, end);\n};\n\n/**\n * Reads a string preceeded by its byte length as a varint.\n * @returns {string} Value read\n */\nReader.prototype.string = function read_string() {\n    var bytes = this.bytes();\n    return utf8.read(bytes, 0, bytes.length);\n};\n\n/**\n * Skips the specified number of bytes if specified, otherwise skips a varint.\n * @param {number} [length] Length if known, otherwise a varint is assumed\n * @returns {Reader} `this`\n */\nReader.prototype.skip = function skip(length) {\n    if (typeof length === \"number\") {\n        /* istanbul ignore if */\n        if (this.pos + length > this.len)\n            throw indexOutOfRange(this, length);\n        this.pos += length;\n    } else {\n        do {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n    }\n    return this;\n};\n\n/**\n * Skips the next element of the specified wire type.\n * @param {number} wireType Wire type received\n * @returns {Reader} `this`\n */\nReader.prototype.skipType = function(wireType) {\n    switch (wireType) {\n        case 0:\n            this.skip();\n            break;\n        case 1:\n            this.skip(8);\n            break;\n        case 2:\n            this.skip(this.uint32());\n            break;\n        case 3:\n            while ((wireType = this.uint32() & 7) !== 4) {\n                this.skipType(wireType);\n            }\n            break;\n        case 5:\n            this.skip(4);\n            break;\n\n        /* istanbul ignore next */\n        default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n    }\n    return this;\n};\n\nReader._configure = function(BufferReader_) {\n    BufferReader = BufferReader_;\n    Reader.create = create();\n    BufferReader._configure();\n\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\n    util.merge(Reader.prototype, {\n\n        int64: function read_int64() {\n            return readLongVarint.call(this)[fn](false);\n        },\n\n        uint64: function read_uint64() {\n            return readLongVarint.call(this)[fn](true);\n        },\n\n        sint64: function read_sint64() {\n            return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n\n        fixed64: function read_fixed64() {\n            return readFixed64.call(this)[fn](true);\n        },\n\n        sfixed64: function read_sfixed64() {\n            return readFixed64.call(this)[fn](false);\n        }\n\n    });\n};\n","\"use strict\";\nmodule.exports = BufferReader;\n\n// extends Reader\nvar Reader = require(\"./reader\");\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n\nvar util = require(\"./util/minimal\");\n\n/**\n * Constructs a new buffer reader instance.\n * @classdesc Wire format reader using node buffers.\n * @extends Reader\n * @constructor\n * @param {Buffer} buffer Buffer to read from\n */\nfunction BufferReader(buffer) {\n    Reader.call(this, buffer);\n\n    /**\n     * Read buffer.\n     * @name BufferReader#buf\n     * @type {Buffer}\n     */\n}\n\nBufferReader._configure = function () {\n    /* istanbul ignore else */\n    if (util.Buffer)\n        BufferReader.prototype._slice = util.Buffer.prototype.slice;\n};\n\n\n/**\n * @override\n */\nBufferReader.prototype.string = function read_string_buffer() {\n    var len = this.uint32(); // modifies pos\n    return this.buf.utf8Slice\n        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))\n        : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @name BufferReader#bytes\n * @function\n * @returns {Buffer} Value read\n */\n\nBufferReader._configure();\n","\"use strict\";\nmodule.exports = Service;\n\nvar util = require(\"../util/minimal\");\n\n// Extends EventEmitter\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n\n/**\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\n *\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\n * @typedef rpc.ServiceMethodCallback\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {TRes} [response] Response message\n * @returns {undefined}\n */\n\n/**\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\n * @typedef rpc.ServiceMethod\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\n */\n\n/**\n * Constructs a new RPC service instance.\n * @classdesc An RPC service as returned by {@link Service#create}.\n * @exports rpc.Service\n * @extends util.EventEmitter\n * @constructor\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n */\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\n\n    if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n\n    util.EventEmitter.call(this);\n\n    /**\n     * RPC implementation. Becomes `null` once the service is ended.\n     * @type {RPCImpl|null}\n     */\n    this.rpcImpl = rpcImpl;\n\n    /**\n     * Whether requests are length-delimited.\n     * @type {boolean}\n     */\n    this.requestDelimited = Boolean(requestDelimited);\n\n    /**\n     * Whether responses are length-delimited.\n     * @type {boolean}\n     */\n    this.responseDelimited = Boolean(responseDelimited);\n}\n\n/**\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\n * @param {Constructor<TReq>} requestCtor Request constructor\n * @param {Constructor<TRes>} responseCtor Response constructor\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\n * @returns {undefined}\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n */\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n\n    if (!request)\n        throw TypeError(\"request must be specified\");\n\n    var self = this;\n    if (!callback)\n        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n\n    if (!self.rpcImpl) {\n        setTimeout(function() { callback(Error(\"already ended\")); }, 0);\n        return undefined;\n    }\n\n    try {\n        return self.rpcImpl(\n            method,\n            requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n            function rpcCallback(err, response) {\n\n                if (err) {\n                    self.emit(\"error\", err, method);\n                    return callback(err);\n                }\n\n                if (response === null) {\n                    self.end(/* endedByRPC */ true);\n                    return undefined;\n                }\n\n                if (!(response instanceof responseCtor)) {\n                    try {\n                        response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n                    } catch (err) {\n                        self.emit(\"error\", err, method);\n                        return callback(err);\n                    }\n                }\n\n                self.emit(\"data\", response, method);\n                return callback(null, response);\n            }\n        );\n    } catch (err) {\n        self.emit(\"error\", err, method);\n        setTimeout(function() { callback(err); }, 0);\n        return undefined;\n    }\n};\n\n/**\n * Ends this service and emits the `end` event.\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\n * @returns {rpc.Service} `this`\n */\nService.prototype.end = function end(endedByRPC) {\n    if (this.rpcImpl) {\n        if (!endedByRPC) // signal end to rpcImpl\n            this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n    }\n    return this;\n};\n","\"use strict\";\n\n/**\n * Streaming RPC helpers.\n * @namespace\n */\nvar rpc = exports;\n\n/**\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\n * @typedef RPCImpl\n * @type {function}\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\n * @param {Uint8Array} requestData Request data\n * @param {RPCImplCallback} callback Callback function\n * @returns {undefined}\n * @example\n * function rpcImpl(method, requestData, callback) {\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\n *         throw Error(\"no such method\");\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\n *         callback(err, responseData);\n *     });\n * }\n */\n\n/**\n * Node-style callback as used by {@link RPCImpl}.\n * @typedef RPCImplCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error\n * @returns {undefined}\n */\n\nrpc.Service = require(\"./rpc/service\");\n","\"use strict\";\nmodule.exports = {};\n\n/**\n * Named roots.\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\n * Can also be used manually to make roots available accross modules.\n * @name roots\n * @type {Object.<string,Root>}\n * @example\n * // pbjs -r myroot -o compiled.js ...\n *\n * // in another module:\n * require(\"./compiled.js\");\n *\n * // in any subsequent module:\n * var root = protobuf.roots[\"myroot\"];\n */\n","\"use strict\";\nvar protobuf = exports;\n\n/**\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\n * @name build\n * @type {string}\n * @const\n */\nprotobuf.build = \"minimal\";\n\n// Serialization\nprotobuf.Writer       = require(\"./writer\");\nprotobuf.BufferWriter = require(\"./writer_buffer\");\nprotobuf.Reader       = require(\"./reader\");\nprotobuf.BufferReader = require(\"./reader_buffer\");\n\n// Utility\nprotobuf.util         = require(\"./util/minimal\");\nprotobuf.rpc          = require(\"./rpc\");\nprotobuf.roots        = require(\"./roots\");\nprotobuf.configure    = configure;\n\n/* istanbul ignore next */\n/**\n * Reconfigures the library according to the environment.\n * @returns {undefined}\n */\nfunction configure() {\n    protobuf.util._configure();\n    protobuf.Writer._configure(protobuf.BufferWriter);\n    protobuf.Reader._configure(protobuf.BufferReader);\n}\n\n// Set up buffer utility according to the environment\nconfigure();\n","// minimal library entry point.\n\n\"use strict\";\nmodule.exports = require(\"./src/index-minimal\");\n","/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\nimport * as $protobuf from \"protobufjs/minimal\";\n\n// Common aliases\nconst $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n// Exported root namespace\nconst $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\nexport const MessageStacksMessage = /*@__PURE__*/ (() => {\n\n    /**\n     * Properties of a MessageStacksMessage.\n     * @exports IMessageStacksMessage\n     * @interface IMessageStacksMessage\n     * @property {Uint8Array} edgeLabelsPacked MessageStacksMessage edgeLabelsPacked\n     * @property {Array.<number>|null} [edgeLabelLengths] MessageStacksMessage edgeLabelLengths\n     * @property {Array.<number>|null} [edgeParents] MessageStacksMessage edgeParents\n     * @property {Array.<number>|null} [messageStackIDs] MessageStacksMessage messageStackIDs\n     */\n\n    /**\n     * Constructs a new MessageStacksMessage.\n     * @exports MessageStacksMessage\n     * @classdesc Represents a MessageStacksMessage.\n     * @implements IMessageStacksMessage\n     * @constructor\n     * @param {IMessageStacksMessage=} [properties] Properties to set\n     */\n    function MessageStacksMessage(properties) {\n        this.edgeLabelLengths = [];\n        this.edgeParents = [];\n        this.messageStackIDs = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * MessageStacksMessage edgeLabelsPacked.\n     * @member {Uint8Array} edgeLabelsPacked\n     * @memberof MessageStacksMessage\n     * @instance\n     */\n    MessageStacksMessage.prototype.edgeLabelsPacked = $util.newBuffer([]);\n\n    /**\n     * MessageStacksMessage edgeLabelLengths.\n     * @member {Array.<number>} edgeLabelLengths\n     * @memberof MessageStacksMessage\n     * @instance\n     */\n    MessageStacksMessage.prototype.edgeLabelLengths = $util.emptyArray;\n\n    /**\n     * MessageStacksMessage edgeParents.\n     * @member {Array.<number>} edgeParents\n     * @memberof MessageStacksMessage\n     * @instance\n     */\n    MessageStacksMessage.prototype.edgeParents = $util.emptyArray;\n\n    /**\n     * MessageStacksMessage messageStackIDs.\n     * @member {Array.<number>} messageStackIDs\n     * @memberof MessageStacksMessage\n     * @instance\n     */\n    MessageStacksMessage.prototype.messageStackIDs = $util.emptyArray;\n\n    /**\n     * Creates a new MessageStacksMessage instance using the specified properties.\n     * @function create\n     * @memberof MessageStacksMessage\n     * @static\n     * @param {IMessageStacksMessage=} [properties] Properties to set\n     * @returns {MessageStacksMessage} MessageStacksMessage instance\n     */\n    MessageStacksMessage.create = function create(properties) {\n        return new MessageStacksMessage(properties);\n    };\n\n    /**\n     * Encodes the specified MessageStacksMessage message. Does not implicitly {@link MessageStacksMessage.verify|verify} messages.\n     * @function encode\n     * @memberof MessageStacksMessage\n     * @static\n     * @param {IMessageStacksMessage} message MessageStacksMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    MessageStacksMessage.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.edgeLabelsPacked);\n        if (message.edgeLabelLengths != null && message.edgeLabelLengths.length) {\n            writer.uint32(/* id 2, wireType 2 =*/18).fork();\n            for (let i = 0; i < message.edgeLabelLengths.length; ++i)\n                writer.sint32(message.edgeLabelLengths[i]);\n            writer.ldelim();\n        }\n        if (message.edgeParents != null && message.edgeParents.length) {\n            writer.uint32(/* id 3, wireType 2 =*/26).fork();\n            for (let i = 0; i < message.edgeParents.length; ++i)\n                writer.uint32(message.edgeParents[i]);\n            writer.ldelim();\n        }\n        if (message.messageStackIDs != null && message.messageStackIDs.length) {\n            writer.uint32(/* id 4, wireType 2 =*/34).fork();\n            for (let i = 0; i < message.messageStackIDs.length; ++i)\n                writer.uint32(message.messageStackIDs[i]);\n            writer.ldelim();\n        }\n        return writer;\n    };\n\n    /**\n     * Encodes the specified MessageStacksMessage message, length delimited. Does not implicitly {@link MessageStacksMessage.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof MessageStacksMessage\n     * @static\n     * @param {IMessageStacksMessage} message MessageStacksMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    MessageStacksMessage.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a MessageStacksMessage message from the specified reader or buffer.\n     * @function decode\n     * @memberof MessageStacksMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {MessageStacksMessage} MessageStacksMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    MessageStacksMessage.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new MessageStacksMessage();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.edgeLabelsPacked = reader.bytes();\n                break;\n            case 2:\n                if (!(message.edgeLabelLengths && message.edgeLabelLengths.length))\n                    message.edgeLabelLengths = [];\n                if ((tag & 7) === 2) {\n                    let end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.edgeLabelLengths.push(reader.sint32());\n                } else\n                    message.edgeLabelLengths.push(reader.sint32());\n                break;\n            case 3:\n                if (!(message.edgeParents && message.edgeParents.length))\n                    message.edgeParents = [];\n                if ((tag & 7) === 2) {\n                    let end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.edgeParents.push(reader.uint32());\n                } else\n                    message.edgeParents.push(reader.uint32());\n                break;\n            case 4:\n                if (!(message.messageStackIDs && message.messageStackIDs.length))\n                    message.messageStackIDs = [];\n                if ((tag & 7) === 2) {\n                    let end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.messageStackIDs.push(reader.uint32());\n                } else\n                    message.messageStackIDs.push(reader.uint32());\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        if (!message.hasOwnProperty(\"edgeLabelsPacked\"))\n            throw $util.ProtocolError(\"missing required 'edgeLabelsPacked'\", { instance: message });\n        return message;\n    };\n\n    /**\n     * Decodes a MessageStacksMessage message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof MessageStacksMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {MessageStacksMessage} MessageStacksMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    MessageStacksMessage.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a MessageStacksMessage message.\n     * @function verify\n     * @memberof MessageStacksMessage\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    MessageStacksMessage.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (!(message.edgeLabelsPacked && typeof message.edgeLabelsPacked.length === \"number\" || $util.isString(message.edgeLabelsPacked)))\n            return \"edgeLabelsPacked: buffer expected\";\n        if (message.edgeLabelLengths != null && message.hasOwnProperty(\"edgeLabelLengths\")) {\n            if (!Array.isArray(message.edgeLabelLengths))\n                return \"edgeLabelLengths: array expected\";\n            for (let i = 0; i < message.edgeLabelLengths.length; ++i)\n                if (!$util.isInteger(message.edgeLabelLengths[i]))\n                    return \"edgeLabelLengths: integer[] expected\";\n        }\n        if (message.edgeParents != null && message.hasOwnProperty(\"edgeParents\")) {\n            if (!Array.isArray(message.edgeParents))\n                return \"edgeParents: array expected\";\n            for (let i = 0; i < message.edgeParents.length; ++i)\n                if (!$util.isInteger(message.edgeParents[i]))\n                    return \"edgeParents: integer[] expected\";\n        }\n        if (message.messageStackIDs != null && message.hasOwnProperty(\"messageStackIDs\")) {\n            if (!Array.isArray(message.messageStackIDs))\n                return \"messageStackIDs: array expected\";\n            for (let i = 0; i < message.messageStackIDs.length; ++i)\n                if (!$util.isInteger(message.messageStackIDs[i]))\n                    return \"messageStackIDs: integer[] expected\";\n        }\n        return null;\n    };\n\n    /**\n     * Creates a MessageStacksMessage message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof MessageStacksMessage\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {MessageStacksMessage} MessageStacksMessage\n     */\n    MessageStacksMessage.fromObject = function fromObject(object) {\n        if (object instanceof MessageStacksMessage)\n            return object;\n        let message = new MessageStacksMessage();\n        if (object.edgeLabelsPacked != null)\n            if (typeof object.edgeLabelsPacked === \"string\")\n                $util.base64.decode(object.edgeLabelsPacked, message.edgeLabelsPacked = $util.newBuffer($util.base64.length(object.edgeLabelsPacked)), 0);\n            else if (object.edgeLabelsPacked.length)\n                message.edgeLabelsPacked = object.edgeLabelsPacked;\n        if (object.edgeLabelLengths) {\n            if (!Array.isArray(object.edgeLabelLengths))\n                throw TypeError(\".MessageStacksMessage.edgeLabelLengths: array expected\");\n            message.edgeLabelLengths = [];\n            for (let i = 0; i < object.edgeLabelLengths.length; ++i)\n                message.edgeLabelLengths[i] = object.edgeLabelLengths[i] | 0;\n        }\n        if (object.edgeParents) {\n            if (!Array.isArray(object.edgeParents))\n                throw TypeError(\".MessageStacksMessage.edgeParents: array expected\");\n            message.edgeParents = [];\n            for (let i = 0; i < object.edgeParents.length; ++i)\n                message.edgeParents[i] = object.edgeParents[i] >>> 0;\n        }\n        if (object.messageStackIDs) {\n            if (!Array.isArray(object.messageStackIDs))\n                throw TypeError(\".MessageStacksMessage.messageStackIDs: array expected\");\n            message.messageStackIDs = [];\n            for (let i = 0; i < object.messageStackIDs.length; ++i)\n                message.messageStackIDs[i] = object.messageStackIDs[i] >>> 0;\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a MessageStacksMessage message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof MessageStacksMessage\n     * @static\n     * @param {MessageStacksMessage} message MessageStacksMessage\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    MessageStacksMessage.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults) {\n            object.edgeLabelLengths = [];\n            object.edgeParents = [];\n            object.messageStackIDs = [];\n        }\n        if (options.defaults)\n            if (options.bytes === String)\n                object.edgeLabelsPacked = \"\";\n            else {\n                object.edgeLabelsPacked = [];\n                if (options.bytes !== Array)\n                    object.edgeLabelsPacked = $util.newBuffer(object.edgeLabelsPacked);\n            }\n        if (message.edgeLabelsPacked != null && message.hasOwnProperty(\"edgeLabelsPacked\"))\n            object.edgeLabelsPacked = options.bytes === String ? $util.base64.encode(message.edgeLabelsPacked, 0, message.edgeLabelsPacked.length) : options.bytes === Array ? Array.prototype.slice.call(message.edgeLabelsPacked) : message.edgeLabelsPacked;\n        if (message.edgeLabelLengths && message.edgeLabelLengths.length) {\n            object.edgeLabelLengths = [];\n            for (let j = 0; j < message.edgeLabelLengths.length; ++j)\n                object.edgeLabelLengths[j] = message.edgeLabelLengths[j];\n        }\n        if (message.edgeParents && message.edgeParents.length) {\n            object.edgeParents = [];\n            for (let j = 0; j < message.edgeParents.length; ++j)\n                object.edgeParents[j] = message.edgeParents[j];\n        }\n        if (message.messageStackIDs && message.messageStackIDs.length) {\n            object.messageStackIDs = [];\n            for (let j = 0; j < message.messageStackIDs.length; ++j)\n                object.messageStackIDs[j] = message.messageStackIDs[j];\n        }\n        return object;\n    };\n\n    /**\n     * Converts this MessageStacksMessage to JSON.\n     * @function toJSON\n     * @memberof MessageStacksMessage\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    MessageStacksMessage.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return MessageStacksMessage;\n})();\n\nexport const SavedStateTreeMessage = /*@__PURE__*/ (() => {\n\n    /**\n     * Properties of a SavedStateTreeMessage.\n     * @exports ISavedStateTreeMessage\n     * @interface ISavedStateTreeMessage\n     * @property {Uint8Array|null} [self] SavedStateTreeMessage self\n     * @property {Array.<string>|null} [childrenKeys] SavedStateTreeMessage childrenKeys\n     * @property {Array.<ISavedStateTreeMessage>|null} [childrenValues] SavedStateTreeMessage childrenValues\n     */\n\n    /**\n     * Constructs a new SavedStateTreeMessage.\n     * @exports SavedStateTreeMessage\n     * @classdesc Represents a SavedStateTreeMessage.\n     * @implements ISavedStateTreeMessage\n     * @constructor\n     * @param {ISavedStateTreeMessage=} [properties] Properties to set\n     */\n    function SavedStateTreeMessage(properties) {\n        this.childrenKeys = [];\n        this.childrenValues = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * SavedStateTreeMessage self.\n     * @member {Uint8Array} self\n     * @memberof SavedStateTreeMessage\n     * @instance\n     */\n    SavedStateTreeMessage.prototype.self = $util.newBuffer([]);\n\n    /**\n     * SavedStateTreeMessage childrenKeys.\n     * @member {Array.<string>} childrenKeys\n     * @memberof SavedStateTreeMessage\n     * @instance\n     */\n    SavedStateTreeMessage.prototype.childrenKeys = $util.emptyArray;\n\n    /**\n     * SavedStateTreeMessage childrenValues.\n     * @member {Array.<ISavedStateTreeMessage>} childrenValues\n     * @memberof SavedStateTreeMessage\n     * @instance\n     */\n    SavedStateTreeMessage.prototype.childrenValues = $util.emptyArray;\n\n    /**\n     * Creates a new SavedStateTreeMessage instance using the specified properties.\n     * @function create\n     * @memberof SavedStateTreeMessage\n     * @static\n     * @param {ISavedStateTreeMessage=} [properties] Properties to set\n     * @returns {SavedStateTreeMessage} SavedStateTreeMessage instance\n     */\n    SavedStateTreeMessage.create = function create(properties) {\n        return new SavedStateTreeMessage(properties);\n    };\n\n    /**\n     * Encodes the specified SavedStateTreeMessage message. Does not implicitly {@link SavedStateTreeMessage.verify|verify} messages.\n     * @function encode\n     * @memberof SavedStateTreeMessage\n     * @static\n     * @param {ISavedStateTreeMessage} message SavedStateTreeMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    SavedStateTreeMessage.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.self != null && Object.hasOwnProperty.call(message, \"self\"))\n            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.self);\n        if (message.childrenKeys != null && message.childrenKeys.length)\n            for (let i = 0; i < message.childrenKeys.length; ++i)\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.childrenKeys[i]);\n        if (message.childrenValues != null && message.childrenValues.length)\n            for (let i = 0; i < message.childrenValues.length; ++i)\n                SavedStateTreeMessage.encode(message.childrenValues[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n        return writer;\n    };\n\n    /**\n     * Encodes the specified SavedStateTreeMessage message, length delimited. Does not implicitly {@link SavedStateTreeMessage.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof SavedStateTreeMessage\n     * @static\n     * @param {ISavedStateTreeMessage} message SavedStateTreeMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    SavedStateTreeMessage.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a SavedStateTreeMessage message from the specified reader or buffer.\n     * @function decode\n     * @memberof SavedStateTreeMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {SavedStateTreeMessage} SavedStateTreeMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    SavedStateTreeMessage.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new SavedStateTreeMessage();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.self = reader.bytes();\n                break;\n            case 2:\n                if (!(message.childrenKeys && message.childrenKeys.length))\n                    message.childrenKeys = [];\n                message.childrenKeys.push(reader.string());\n                break;\n            case 3:\n                if (!(message.childrenValues && message.childrenValues.length))\n                    message.childrenValues = [];\n                message.childrenValues.push(SavedStateTreeMessage.decode(reader, reader.uint32()));\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a SavedStateTreeMessage message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof SavedStateTreeMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {SavedStateTreeMessage} SavedStateTreeMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    SavedStateTreeMessage.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a SavedStateTreeMessage message.\n     * @function verify\n     * @memberof SavedStateTreeMessage\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    SavedStateTreeMessage.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.self != null && message.hasOwnProperty(\"self\"))\n            if (!(message.self && typeof message.self.length === \"number\" || $util.isString(message.self)))\n                return \"self: buffer expected\";\n        if (message.childrenKeys != null && message.hasOwnProperty(\"childrenKeys\")) {\n            if (!Array.isArray(message.childrenKeys))\n                return \"childrenKeys: array expected\";\n            for (let i = 0; i < message.childrenKeys.length; ++i)\n                if (!$util.isString(message.childrenKeys[i]))\n                    return \"childrenKeys: string[] expected\";\n        }\n        if (message.childrenValues != null && message.hasOwnProperty(\"childrenValues\")) {\n            if (!Array.isArray(message.childrenValues))\n                return \"childrenValues: array expected\";\n            for (let i = 0; i < message.childrenValues.length; ++i) {\n                let error = SavedStateTreeMessage.verify(message.childrenValues[i]);\n                if (error)\n                    return \"childrenValues.\" + error;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Creates a SavedStateTreeMessage message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof SavedStateTreeMessage\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {SavedStateTreeMessage} SavedStateTreeMessage\n     */\n    SavedStateTreeMessage.fromObject = function fromObject(object) {\n        if (object instanceof SavedStateTreeMessage)\n            return object;\n        let message = new SavedStateTreeMessage();\n        if (object.self != null)\n            if (typeof object.self === \"string\")\n                $util.base64.decode(object.self, message.self = $util.newBuffer($util.base64.length(object.self)), 0);\n            else if (object.self.length)\n                message.self = object.self;\n        if (object.childrenKeys) {\n            if (!Array.isArray(object.childrenKeys))\n                throw TypeError(\".SavedStateTreeMessage.childrenKeys: array expected\");\n            message.childrenKeys = [];\n            for (let i = 0; i < object.childrenKeys.length; ++i)\n                message.childrenKeys[i] = String(object.childrenKeys[i]);\n        }\n        if (object.childrenValues) {\n            if (!Array.isArray(object.childrenValues))\n                throw TypeError(\".SavedStateTreeMessage.childrenValues: array expected\");\n            message.childrenValues = [];\n            for (let i = 0; i < object.childrenValues.length; ++i) {\n                if (typeof object.childrenValues[i] !== \"object\")\n                    throw TypeError(\".SavedStateTreeMessage.childrenValues: object expected\");\n                message.childrenValues[i] = SavedStateTreeMessage.fromObject(object.childrenValues[i]);\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a SavedStateTreeMessage message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof SavedStateTreeMessage\n     * @static\n     * @param {SavedStateTreeMessage} message SavedStateTreeMessage\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    SavedStateTreeMessage.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults) {\n            object.childrenKeys = [];\n            object.childrenValues = [];\n        }\n        if (options.defaults)\n            if (options.bytes === String)\n                object.self = \"\";\n            else {\n                object.self = [];\n                if (options.bytes !== Array)\n                    object.self = $util.newBuffer(object.self);\n            }\n        if (message.self != null && message.hasOwnProperty(\"self\"))\n            object.self = options.bytes === String ? $util.base64.encode(message.self, 0, message.self.length) : options.bytes === Array ? Array.prototype.slice.call(message.self) : message.self;\n        if (message.childrenKeys && message.childrenKeys.length) {\n            object.childrenKeys = [];\n            for (let j = 0; j < message.childrenKeys.length; ++j)\n                object.childrenKeys[j] = message.childrenKeys[j];\n        }\n        if (message.childrenValues && message.childrenValues.length) {\n            object.childrenValues = [];\n            for (let j = 0; j < message.childrenValues.length; ++j)\n                object.childrenValues[j] = SavedStateTreeMessage.toObject(message.childrenValues[j], options);\n        }\n        return object;\n    };\n\n    /**\n     * Converts this SavedStateTreeMessage to JSON.\n     * @function toJSON\n     * @memberof SavedStateTreeMessage\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    SavedStateTreeMessage.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return SavedStateTreeMessage;\n})();\n\nexport const ArrayMessage = /*@__PURE__*/ (() => {\n\n    /**\n     * Properties of an ArrayMessage.\n     * @exports IArrayMessage\n     * @interface IArrayMessage\n     * @property {Array.<Uint8Array>|null} [elements] ArrayMessage elements\n     */\n\n    /**\n     * Constructs a new ArrayMessage.\n     * @exports ArrayMessage\n     * @classdesc Represents an ArrayMessage.\n     * @implements IArrayMessage\n     * @constructor\n     * @param {IArrayMessage=} [properties] Properties to set\n     */\n    function ArrayMessage(properties) {\n        this.elements = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * ArrayMessage elements.\n     * @member {Array.<Uint8Array>} elements\n     * @memberof ArrayMessage\n     * @instance\n     */\n    ArrayMessage.prototype.elements = $util.emptyArray;\n\n    /**\n     * Creates a new ArrayMessage instance using the specified properties.\n     * @function create\n     * @memberof ArrayMessage\n     * @static\n     * @param {IArrayMessage=} [properties] Properties to set\n     * @returns {ArrayMessage} ArrayMessage instance\n     */\n    ArrayMessage.create = function create(properties) {\n        return new ArrayMessage(properties);\n    };\n\n    /**\n     * Encodes the specified ArrayMessage message. Does not implicitly {@link ArrayMessage.verify|verify} messages.\n     * @function encode\n     * @memberof ArrayMessage\n     * @static\n     * @param {IArrayMessage} message ArrayMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ArrayMessage.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.elements != null && message.elements.length)\n            for (let i = 0; i < message.elements.length; ++i)\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.elements[i]);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified ArrayMessage message, length delimited. Does not implicitly {@link ArrayMessage.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ArrayMessage\n     * @static\n     * @param {IArrayMessage} message ArrayMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ArrayMessage.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes an ArrayMessage message from the specified reader or buffer.\n     * @function decode\n     * @memberof ArrayMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ArrayMessage} ArrayMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ArrayMessage.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new ArrayMessage();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                if (!(message.elements && message.elements.length))\n                    message.elements = [];\n                message.elements.push(reader.bytes());\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes an ArrayMessage message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ArrayMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ArrayMessage} ArrayMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ArrayMessage.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies an ArrayMessage message.\n     * @function verify\n     * @memberof ArrayMessage\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    ArrayMessage.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.elements != null && message.hasOwnProperty(\"elements\")) {\n            if (!Array.isArray(message.elements))\n                return \"elements: array expected\";\n            for (let i = 0; i < message.elements.length; ++i)\n                if (!(message.elements[i] && typeof message.elements[i].length === \"number\" || $util.isString(message.elements[i])))\n                    return \"elements: buffer[] expected\";\n        }\n        return null;\n    };\n\n    /**\n     * Creates an ArrayMessage message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ArrayMessage\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ArrayMessage} ArrayMessage\n     */\n    ArrayMessage.fromObject = function fromObject(object) {\n        if (object instanceof ArrayMessage)\n            return object;\n        let message = new ArrayMessage();\n        if (object.elements) {\n            if (!Array.isArray(object.elements))\n                throw TypeError(\".ArrayMessage.elements: array expected\");\n            message.elements = [];\n            for (let i = 0; i < object.elements.length; ++i)\n                if (typeof object.elements[i] === \"string\")\n                    $util.base64.decode(object.elements[i], message.elements[i] = $util.newBuffer($util.base64.length(object.elements[i])), 0);\n                else if (object.elements[i].length)\n                    message.elements[i] = object.elements[i];\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from an ArrayMessage message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ArrayMessage\n     * @static\n     * @param {ArrayMessage} message ArrayMessage\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    ArrayMessage.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults)\n            object.elements = [];\n        if (message.elements && message.elements.length) {\n            object.elements = [];\n            for (let j = 0; j < message.elements.length; ++j)\n                object.elements[j] = options.bytes === String ? $util.base64.encode(message.elements[j], 0, message.elements[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.elements[j]) : message.elements[j];\n        }\n        return object;\n    };\n\n    /**\n     * Converts this ArrayMessage to JSON.\n     * @function toJSON\n     * @memberof ArrayMessage\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    ArrayMessage.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return ArrayMessage;\n})();\n\nexport const ObjectMessage = /*@__PURE__*/ (() => {\n\n    /**\n     * Properties of an ObjectMessage.\n     * @exports IObjectMessage\n     * @interface IObjectMessage\n     * @property {Object.<string,Uint8Array>|null} [properties] ObjectMessage properties\n     */\n\n    /**\n     * Constructs a new ObjectMessage.\n     * @exports ObjectMessage\n     * @classdesc Represents an ObjectMessage.\n     * @implements IObjectMessage\n     * @constructor\n     * @param {IObjectMessage=} [properties] Properties to set\n     */\n    function ObjectMessage(properties) {\n        this.properties = {};\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * ObjectMessage properties.\n     * @member {Object.<string,Uint8Array>} properties\n     * @memberof ObjectMessage\n     * @instance\n     */\n    ObjectMessage.prototype.properties = $util.emptyObject;\n\n    /**\n     * Creates a new ObjectMessage instance using the specified properties.\n     * @function create\n     * @memberof ObjectMessage\n     * @static\n     * @param {IObjectMessage=} [properties] Properties to set\n     * @returns {ObjectMessage} ObjectMessage instance\n     */\n    ObjectMessage.create = function create(properties) {\n        return new ObjectMessage(properties);\n    };\n\n    /**\n     * Encodes the specified ObjectMessage message. Does not implicitly {@link ObjectMessage.verify|verify} messages.\n     * @function encode\n     * @memberof ObjectMessage\n     * @static\n     * @param {IObjectMessage} message ObjectMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ObjectMessage.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.properties != null && Object.hasOwnProperty.call(message, \"properties\"))\n            for (let keys = Object.keys(message.properties), i = 0; i < keys.length; ++i)\n                writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).bytes(message.properties[keys[i]]).ldelim();\n        return writer;\n    };\n\n    /**\n     * Encodes the specified ObjectMessage message, length delimited. Does not implicitly {@link ObjectMessage.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ObjectMessage\n     * @static\n     * @param {IObjectMessage} message ObjectMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ObjectMessage.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes an ObjectMessage message from the specified reader or buffer.\n     * @function decode\n     * @memberof ObjectMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ObjectMessage} ObjectMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ObjectMessage.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new ObjectMessage(), key;\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                reader.skip().pos++;\n                if (message.properties === $util.emptyObject)\n                    message.properties = {};\n                key = reader.string();\n                reader.pos++;\n                message.properties[key] = reader.bytes();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes an ObjectMessage message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ObjectMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ObjectMessage} ObjectMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ObjectMessage.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies an ObjectMessage message.\n     * @function verify\n     * @memberof ObjectMessage\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    ObjectMessage.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.properties != null && message.hasOwnProperty(\"properties\")) {\n            if (!$util.isObject(message.properties))\n                return \"properties: object expected\";\n            let key = Object.keys(message.properties);\n            for (let i = 0; i < key.length; ++i)\n                if (!(message.properties[key[i]] && typeof message.properties[key[i]].length === \"number\" || $util.isString(message.properties[key[i]])))\n                    return \"properties: buffer{k:string} expected\";\n        }\n        return null;\n    };\n\n    /**\n     * Creates an ObjectMessage message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ObjectMessage\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ObjectMessage} ObjectMessage\n     */\n    ObjectMessage.fromObject = function fromObject(object) {\n        if (object instanceof ObjectMessage)\n            return object;\n        let message = new ObjectMessage();\n        if (object.properties) {\n            if (typeof object.properties !== \"object\")\n                throw TypeError(\".ObjectMessage.properties: object expected\");\n            message.properties = {};\n            for (let keys = Object.keys(object.properties), i = 0; i < keys.length; ++i)\n                if (typeof object.properties[keys[i]] === \"string\")\n                    $util.base64.decode(object.properties[keys[i]], message.properties[keys[i]] = $util.newBuffer($util.base64.length(object.properties[keys[i]])), 0);\n                else if (object.properties[keys[i]].length)\n                    message.properties[keys[i]] = object.properties[keys[i]];\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from an ObjectMessage message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ObjectMessage\n     * @static\n     * @param {ObjectMessage} message ObjectMessage\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    ObjectMessage.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.objects || options.defaults)\n            object.properties = {};\n        let keys2;\n        if (message.properties && (keys2 = Object.keys(message.properties)).length) {\n            object.properties = {};\n            for (let j = 0; j < keys2.length; ++j)\n                object.properties[keys2[j]] = options.bytes === String ? $util.base64.encode(message.properties[keys2[j]], 0, message.properties[keys2[j]].length) : options.bytes === Array ? Array.prototype.slice.call(message.properties[keys2[j]]) : message.properties[keys2[j]];\n        }\n        return object;\n    };\n\n    /**\n     * Converts this ObjectMessage to JSON.\n     * @function toJSON\n     * @memberof ObjectMessage\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    ObjectMessage.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return ObjectMessage;\n})();\n\nexport const DefaultSerializerMessage = /*@__PURE__*/ (() => {\n\n    /**\n     * Properties of a DefaultSerializerMessage.\n     * @exports IDefaultSerializerMessage\n     * @interface IDefaultSerializerMessage\n     * @property {string|null} [stringValue] DefaultSerializerMessage stringValue\n     * @property {number|Long|null} [intValue] DefaultSerializerMessage intValue\n     * @property {number|null} [doubleValue] DefaultSerializerMessage doubleValue\n     * @property {boolean|null} [booleanValue] DefaultSerializerMessage booleanValue\n     * @property {boolean|null} [undefinedValue] DefaultSerializerMessage undefinedValue\n     * @property {boolean|null} [nullValue] DefaultSerializerMessage nullValue\n     * @property {IArrayMessage|null} [arrayValue] DefaultSerializerMessage arrayValue\n     * @property {IObjectMessage|null} [objectValue] DefaultSerializerMessage objectValue\n     * @property {Uint8Array|null} [bytesValue] DefaultSerializerMessage bytesValue\n     * @property {IOptionalMessage|null} [optionalValue] DefaultSerializerMessage optionalValue\n     */\n\n    /**\n     * Constructs a new DefaultSerializerMessage.\n     * @exports DefaultSerializerMessage\n     * @classdesc Represents a DefaultSerializerMessage.\n     * @implements IDefaultSerializerMessage\n     * @constructor\n     * @param {IDefaultSerializerMessage=} [properties] Properties to set\n     */\n    function DefaultSerializerMessage(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * DefaultSerializerMessage stringValue.\n     * @member {string} stringValue\n     * @memberof DefaultSerializerMessage\n     * @instance\n     */\n    DefaultSerializerMessage.prototype.stringValue = \"\";\n\n    /**\n     * DefaultSerializerMessage intValue.\n     * @member {number|Long} intValue\n     * @memberof DefaultSerializerMessage\n     * @instance\n     */\n    DefaultSerializerMessage.prototype.intValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n    /**\n     * DefaultSerializerMessage doubleValue.\n     * @member {number} doubleValue\n     * @memberof DefaultSerializerMessage\n     * @instance\n     */\n    DefaultSerializerMessage.prototype.doubleValue = 0;\n\n    /**\n     * DefaultSerializerMessage booleanValue.\n     * @member {boolean} booleanValue\n     * @memberof DefaultSerializerMessage\n     * @instance\n     */\n    DefaultSerializerMessage.prototype.booleanValue = false;\n\n    /**\n     * DefaultSerializerMessage undefinedValue.\n     * @member {boolean} undefinedValue\n     * @memberof DefaultSerializerMessage\n     * @instance\n     */\n    DefaultSerializerMessage.prototype.undefinedValue = false;\n\n    /**\n     * DefaultSerializerMessage nullValue.\n     * @member {boolean} nullValue\n     * @memberof DefaultSerializerMessage\n     * @instance\n     */\n    DefaultSerializerMessage.prototype.nullValue = false;\n\n    /**\n     * DefaultSerializerMessage arrayValue.\n     * @member {IArrayMessage|null|undefined} arrayValue\n     * @memberof DefaultSerializerMessage\n     * @instance\n     */\n    DefaultSerializerMessage.prototype.arrayValue = null;\n\n    /**\n     * DefaultSerializerMessage objectValue.\n     * @member {IObjectMessage|null|undefined} objectValue\n     * @memberof DefaultSerializerMessage\n     * @instance\n     */\n    DefaultSerializerMessage.prototype.objectValue = null;\n\n    /**\n     * DefaultSerializerMessage bytesValue.\n     * @member {Uint8Array} bytesValue\n     * @memberof DefaultSerializerMessage\n     * @instance\n     */\n    DefaultSerializerMessage.prototype.bytesValue = $util.newBuffer([]);\n\n    /**\n     * DefaultSerializerMessage optionalValue.\n     * @member {IOptionalMessage|null|undefined} optionalValue\n     * @memberof DefaultSerializerMessage\n     * @instance\n     */\n    DefaultSerializerMessage.prototype.optionalValue = null;\n\n    // OneOf field names bound to virtual getters and setters\n    let $oneOfFields;\n\n    /**\n     * DefaultSerializerMessage value.\n     * @member {\"stringValue\"|\"intValue\"|\"doubleValue\"|\"booleanValue\"|\"undefinedValue\"|\"nullValue\"|\"arrayValue\"|\"objectValue\"|\"bytesValue\"|\"optionalValue\"|undefined} value\n     * @memberof DefaultSerializerMessage\n     * @instance\n     */\n    Object.defineProperty(DefaultSerializerMessage.prototype, \"value\", {\n        get: $util.oneOfGetter($oneOfFields = [\"stringValue\", \"intValue\", \"doubleValue\", \"booleanValue\", \"undefinedValue\", \"nullValue\", \"arrayValue\", \"objectValue\", \"bytesValue\", \"optionalValue\"]),\n        set: $util.oneOfSetter($oneOfFields)\n    });\n\n    /**\n     * Creates a new DefaultSerializerMessage instance using the specified properties.\n     * @function create\n     * @memberof DefaultSerializerMessage\n     * @static\n     * @param {IDefaultSerializerMessage=} [properties] Properties to set\n     * @returns {DefaultSerializerMessage} DefaultSerializerMessage instance\n     */\n    DefaultSerializerMessage.create = function create(properties) {\n        return new DefaultSerializerMessage(properties);\n    };\n\n    /**\n     * Encodes the specified DefaultSerializerMessage message. Does not implicitly {@link DefaultSerializerMessage.verify|verify} messages.\n     * @function encode\n     * @memberof DefaultSerializerMessage\n     * @static\n     * @param {IDefaultSerializerMessage} message DefaultSerializerMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    DefaultSerializerMessage.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.stringValue != null && Object.hasOwnProperty.call(message, \"stringValue\"))\n            writer.uint32(/* id 1, wireType 2 =*/10).string(message.stringValue);\n        if (message.intValue != null && Object.hasOwnProperty.call(message, \"intValue\"))\n            writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.intValue);\n        if (message.doubleValue != null && Object.hasOwnProperty.call(message, \"doubleValue\"))\n            writer.uint32(/* id 3, wireType 1 =*/25).double(message.doubleValue);\n        if (message.booleanValue != null && Object.hasOwnProperty.call(message, \"booleanValue\"))\n            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.booleanValue);\n        if (message.undefinedValue != null && Object.hasOwnProperty.call(message, \"undefinedValue\"))\n            writer.uint32(/* id 5, wireType 0 =*/40).bool(message.undefinedValue);\n        if (message.nullValue != null && Object.hasOwnProperty.call(message, \"nullValue\"))\n            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.nullValue);\n        if (message.arrayValue != null && Object.hasOwnProperty.call(message, \"arrayValue\"))\n            ArrayMessage.encode(message.arrayValue, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();\n        if (message.objectValue != null && Object.hasOwnProperty.call(message, \"objectValue\"))\n            ObjectMessage.encode(message.objectValue, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();\n        if (message.bytesValue != null && Object.hasOwnProperty.call(message, \"bytesValue\"))\n            writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.bytesValue);\n        if (message.optionalValue != null && Object.hasOwnProperty.call(message, \"optionalValue\"))\n            OptionalMessage.encode(message.optionalValue, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();\n        return writer;\n    };\n\n    /**\n     * Encodes the specified DefaultSerializerMessage message, length delimited. Does not implicitly {@link DefaultSerializerMessage.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof DefaultSerializerMessage\n     * @static\n     * @param {IDefaultSerializerMessage} message DefaultSerializerMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    DefaultSerializerMessage.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a DefaultSerializerMessage message from the specified reader or buffer.\n     * @function decode\n     * @memberof DefaultSerializerMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {DefaultSerializerMessage} DefaultSerializerMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    DefaultSerializerMessage.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new DefaultSerializerMessage();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.stringValue = reader.string();\n                break;\n            case 2:\n                message.intValue = reader.sint64();\n                break;\n            case 3:\n                message.doubleValue = reader.double();\n                break;\n            case 4:\n                message.booleanValue = reader.bool();\n                break;\n            case 5:\n                message.undefinedValue = reader.bool();\n                break;\n            case 6:\n                message.nullValue = reader.bool();\n                break;\n            case 7:\n                message.arrayValue = ArrayMessage.decode(reader, reader.uint32());\n                break;\n            case 8:\n                message.objectValue = ObjectMessage.decode(reader, reader.uint32());\n                break;\n            case 9:\n                message.bytesValue = reader.bytes();\n                break;\n            case 10:\n                message.optionalValue = OptionalMessage.decode(reader, reader.uint32());\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a DefaultSerializerMessage message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof DefaultSerializerMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {DefaultSerializerMessage} DefaultSerializerMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    DefaultSerializerMessage.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a DefaultSerializerMessage message.\n     * @function verify\n     * @memberof DefaultSerializerMessage\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    DefaultSerializerMessage.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        let properties = {};\n        if (message.stringValue != null && message.hasOwnProperty(\"stringValue\")) {\n            properties.value = 1;\n            if (!$util.isString(message.stringValue))\n                return \"stringValue: string expected\";\n        }\n        if (message.intValue != null && message.hasOwnProperty(\"intValue\")) {\n            if (properties.value === 1)\n                return \"value: multiple values\";\n            properties.value = 1;\n            if (!$util.isInteger(message.intValue) && !(message.intValue && $util.isInteger(message.intValue.low) && $util.isInteger(message.intValue.high)))\n                return \"intValue: integer|Long expected\";\n        }\n        if (message.doubleValue != null && message.hasOwnProperty(\"doubleValue\")) {\n            if (properties.value === 1)\n                return \"value: multiple values\";\n            properties.value = 1;\n            if (typeof message.doubleValue !== \"number\")\n                return \"doubleValue: number expected\";\n        }\n        if (message.booleanValue != null && message.hasOwnProperty(\"booleanValue\")) {\n            if (properties.value === 1)\n                return \"value: multiple values\";\n            properties.value = 1;\n            if (typeof message.booleanValue !== \"boolean\")\n                return \"booleanValue: boolean expected\";\n        }\n        if (message.undefinedValue != null && message.hasOwnProperty(\"undefinedValue\")) {\n            if (properties.value === 1)\n                return \"value: multiple values\";\n            properties.value = 1;\n            if (typeof message.undefinedValue !== \"boolean\")\n                return \"undefinedValue: boolean expected\";\n        }\n        if (message.nullValue != null && message.hasOwnProperty(\"nullValue\")) {\n            if (properties.value === 1)\n                return \"value: multiple values\";\n            properties.value = 1;\n            if (typeof message.nullValue !== \"boolean\")\n                return \"nullValue: boolean expected\";\n        }\n        if (message.arrayValue != null && message.hasOwnProperty(\"arrayValue\")) {\n            if (properties.value === 1)\n                return \"value: multiple values\";\n            properties.value = 1;\n            {\n                let error = ArrayMessage.verify(message.arrayValue);\n                if (error)\n                    return \"arrayValue.\" + error;\n            }\n        }\n        if (message.objectValue != null && message.hasOwnProperty(\"objectValue\")) {\n            if (properties.value === 1)\n                return \"value: multiple values\";\n            properties.value = 1;\n            {\n                let error = ObjectMessage.verify(message.objectValue);\n                if (error)\n                    return \"objectValue.\" + error;\n            }\n        }\n        if (message.bytesValue != null && message.hasOwnProperty(\"bytesValue\")) {\n            if (properties.value === 1)\n                return \"value: multiple values\";\n            properties.value = 1;\n            if (!(message.bytesValue && typeof message.bytesValue.length === \"number\" || $util.isString(message.bytesValue)))\n                return \"bytesValue: buffer expected\";\n        }\n        if (message.optionalValue != null && message.hasOwnProperty(\"optionalValue\")) {\n            if (properties.value === 1)\n                return \"value: multiple values\";\n            properties.value = 1;\n            {\n                let error = OptionalMessage.verify(message.optionalValue);\n                if (error)\n                    return \"optionalValue.\" + error;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Creates a DefaultSerializerMessage message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof DefaultSerializerMessage\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {DefaultSerializerMessage} DefaultSerializerMessage\n     */\n    DefaultSerializerMessage.fromObject = function fromObject(object) {\n        if (object instanceof DefaultSerializerMessage)\n            return object;\n        let message = new DefaultSerializerMessage();\n        if (object.stringValue != null)\n            message.stringValue = String(object.stringValue);\n        if (object.intValue != null)\n            if ($util.Long)\n                (message.intValue = $util.Long.fromValue(object.intValue)).unsigned = false;\n            else if (typeof object.intValue === \"string\")\n                message.intValue = parseInt(object.intValue, 10);\n            else if (typeof object.intValue === \"number\")\n                message.intValue = object.intValue;\n            else if (typeof object.intValue === \"object\")\n                message.intValue = new $util.LongBits(object.intValue.low >>> 0, object.intValue.high >>> 0).toNumber();\n        if (object.doubleValue != null)\n            message.doubleValue = Number(object.doubleValue);\n        if (object.booleanValue != null)\n            message.booleanValue = Boolean(object.booleanValue);\n        if (object.undefinedValue != null)\n            message.undefinedValue = Boolean(object.undefinedValue);\n        if (object.nullValue != null)\n            message.nullValue = Boolean(object.nullValue);\n        if (object.arrayValue != null) {\n            if (typeof object.arrayValue !== \"object\")\n                throw TypeError(\".DefaultSerializerMessage.arrayValue: object expected\");\n            message.arrayValue = ArrayMessage.fromObject(object.arrayValue);\n        }\n        if (object.objectValue != null) {\n            if (typeof object.objectValue !== \"object\")\n                throw TypeError(\".DefaultSerializerMessage.objectValue: object expected\");\n            message.objectValue = ObjectMessage.fromObject(object.objectValue);\n        }\n        if (object.bytesValue != null)\n            if (typeof object.bytesValue === \"string\")\n                $util.base64.decode(object.bytesValue, message.bytesValue = $util.newBuffer($util.base64.length(object.bytesValue)), 0);\n            else if (object.bytesValue.length)\n                message.bytesValue = object.bytesValue;\n        if (object.optionalValue != null) {\n            if (typeof object.optionalValue !== \"object\")\n                throw TypeError(\".DefaultSerializerMessage.optionalValue: object expected\");\n            message.optionalValue = OptionalMessage.fromObject(object.optionalValue);\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a DefaultSerializerMessage message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof DefaultSerializerMessage\n     * @static\n     * @param {DefaultSerializerMessage} message DefaultSerializerMessage\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    DefaultSerializerMessage.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (message.stringValue != null && message.hasOwnProperty(\"stringValue\")) {\n            object.stringValue = message.stringValue;\n            if (options.oneofs)\n                object.value = \"stringValue\";\n        }\n        if (message.intValue != null && message.hasOwnProperty(\"intValue\")) {\n            if (typeof message.intValue === \"number\")\n                object.intValue = options.longs === String ? String(message.intValue) : message.intValue;\n            else\n                object.intValue = options.longs === String ? $util.Long.prototype.toString.call(message.intValue) : options.longs === Number ? new $util.LongBits(message.intValue.low >>> 0, message.intValue.high >>> 0).toNumber() : message.intValue;\n            if (options.oneofs)\n                object.value = \"intValue\";\n        }\n        if (message.doubleValue != null && message.hasOwnProperty(\"doubleValue\")) {\n            object.doubleValue = options.json && !isFinite(message.doubleValue) ? String(message.doubleValue) : message.doubleValue;\n            if (options.oneofs)\n                object.value = \"doubleValue\";\n        }\n        if (message.booleanValue != null && message.hasOwnProperty(\"booleanValue\")) {\n            object.booleanValue = message.booleanValue;\n            if (options.oneofs)\n                object.value = \"booleanValue\";\n        }\n        if (message.undefinedValue != null && message.hasOwnProperty(\"undefinedValue\")) {\n            object.undefinedValue = message.undefinedValue;\n            if (options.oneofs)\n                object.value = \"undefinedValue\";\n        }\n        if (message.nullValue != null && message.hasOwnProperty(\"nullValue\")) {\n            object.nullValue = message.nullValue;\n            if (options.oneofs)\n                object.value = \"nullValue\";\n        }\n        if (message.arrayValue != null && message.hasOwnProperty(\"arrayValue\")) {\n            object.arrayValue = ArrayMessage.toObject(message.arrayValue, options);\n            if (options.oneofs)\n                object.value = \"arrayValue\";\n        }\n        if (message.objectValue != null && message.hasOwnProperty(\"objectValue\")) {\n            object.objectValue = ObjectMessage.toObject(message.objectValue, options);\n            if (options.oneofs)\n                object.value = \"objectValue\";\n        }\n        if (message.bytesValue != null && message.hasOwnProperty(\"bytesValue\")) {\n            object.bytesValue = options.bytes === String ? $util.base64.encode(message.bytesValue, 0, message.bytesValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.bytesValue) : message.bytesValue;\n            if (options.oneofs)\n                object.value = \"bytesValue\";\n        }\n        if (message.optionalValue != null && message.hasOwnProperty(\"optionalValue\")) {\n            object.optionalValue = OptionalMessage.toObject(message.optionalValue, options);\n            if (options.oneofs)\n                object.value = \"optionalValue\";\n        }\n        return object;\n    };\n\n    /**\n     * Converts this DefaultSerializerMessage to JSON.\n     * @function toJSON\n     * @memberof DefaultSerializerMessage\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    DefaultSerializerMessage.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return DefaultSerializerMessage;\n})();\n\nexport const PairSerializerMessage = /*@__PURE__*/ (() => {\n\n    /**\n     * Properties of a PairSerializerMessage.\n     * @exports IPairSerializerMessage\n     * @interface IPairSerializerMessage\n     * @property {Uint8Array} one PairSerializerMessage one\n     * @property {Uint8Array} two PairSerializerMessage two\n     */\n\n    /**\n     * Constructs a new PairSerializerMessage.\n     * @exports PairSerializerMessage\n     * @classdesc Represents a PairSerializerMessage.\n     * @implements IPairSerializerMessage\n     * @constructor\n     * @param {IPairSerializerMessage=} [properties] Properties to set\n     */\n    function PairSerializerMessage(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * PairSerializerMessage one.\n     * @member {Uint8Array} one\n     * @memberof PairSerializerMessage\n     * @instance\n     */\n    PairSerializerMessage.prototype.one = $util.newBuffer([]);\n\n    /**\n     * PairSerializerMessage two.\n     * @member {Uint8Array} two\n     * @memberof PairSerializerMessage\n     * @instance\n     */\n    PairSerializerMessage.prototype.two = $util.newBuffer([]);\n\n    /**\n     * Creates a new PairSerializerMessage instance using the specified properties.\n     * @function create\n     * @memberof PairSerializerMessage\n     * @static\n     * @param {IPairSerializerMessage=} [properties] Properties to set\n     * @returns {PairSerializerMessage} PairSerializerMessage instance\n     */\n    PairSerializerMessage.create = function create(properties) {\n        return new PairSerializerMessage(properties);\n    };\n\n    /**\n     * Encodes the specified PairSerializerMessage message. Does not implicitly {@link PairSerializerMessage.verify|verify} messages.\n     * @function encode\n     * @memberof PairSerializerMessage\n     * @static\n     * @param {IPairSerializerMessage} message PairSerializerMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    PairSerializerMessage.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.one);\n        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.two);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified PairSerializerMessage message, length delimited. Does not implicitly {@link PairSerializerMessage.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof PairSerializerMessage\n     * @static\n     * @param {IPairSerializerMessage} message PairSerializerMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    PairSerializerMessage.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a PairSerializerMessage message from the specified reader or buffer.\n     * @function decode\n     * @memberof PairSerializerMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {PairSerializerMessage} PairSerializerMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    PairSerializerMessage.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new PairSerializerMessage();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.one = reader.bytes();\n                break;\n            case 2:\n                message.two = reader.bytes();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        if (!message.hasOwnProperty(\"one\"))\n            throw $util.ProtocolError(\"missing required 'one'\", { instance: message });\n        if (!message.hasOwnProperty(\"two\"))\n            throw $util.ProtocolError(\"missing required 'two'\", { instance: message });\n        return message;\n    };\n\n    /**\n     * Decodes a PairSerializerMessage message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof PairSerializerMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {PairSerializerMessage} PairSerializerMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    PairSerializerMessage.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a PairSerializerMessage message.\n     * @function verify\n     * @memberof PairSerializerMessage\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    PairSerializerMessage.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (!(message.one && typeof message.one.length === \"number\" || $util.isString(message.one)))\n            return \"one: buffer expected\";\n        if (!(message.two && typeof message.two.length === \"number\" || $util.isString(message.two)))\n            return \"two: buffer expected\";\n        return null;\n    };\n\n    /**\n     * Creates a PairSerializerMessage message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof PairSerializerMessage\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {PairSerializerMessage} PairSerializerMessage\n     */\n    PairSerializerMessage.fromObject = function fromObject(object) {\n        if (object instanceof PairSerializerMessage)\n            return object;\n        let message = new PairSerializerMessage();\n        if (object.one != null)\n            if (typeof object.one === \"string\")\n                $util.base64.decode(object.one, message.one = $util.newBuffer($util.base64.length(object.one)), 0);\n            else if (object.one.length)\n                message.one = object.one;\n        if (object.two != null)\n            if (typeof object.two === \"string\")\n                $util.base64.decode(object.two, message.two = $util.newBuffer($util.base64.length(object.two)), 0);\n            else if (object.two.length)\n                message.two = object.two;\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a PairSerializerMessage message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof PairSerializerMessage\n     * @static\n     * @param {PairSerializerMessage} message PairSerializerMessage\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    PairSerializerMessage.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.defaults) {\n            if (options.bytes === String)\n                object.one = \"\";\n            else {\n                object.one = [];\n                if (options.bytes !== Array)\n                    object.one = $util.newBuffer(object.one);\n            }\n            if (options.bytes === String)\n                object.two = \"\";\n            else {\n                object.two = [];\n                if (options.bytes !== Array)\n                    object.two = $util.newBuffer(object.two);\n            }\n        }\n        if (message.one != null && message.hasOwnProperty(\"one\"))\n            object.one = options.bytes === String ? $util.base64.encode(message.one, 0, message.one.length) : options.bytes === Array ? Array.prototype.slice.call(message.one) : message.one;\n        if (message.two != null && message.hasOwnProperty(\"two\"))\n            object.two = options.bytes === String ? $util.base64.encode(message.two, 0, message.two.length) : options.bytes === Array ? Array.prototype.slice.call(message.two) : message.two;\n        return object;\n    };\n\n    /**\n     * Converts this PairSerializerMessage to JSON.\n     * @function toJSON\n     * @memberof PairSerializerMessage\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    PairSerializerMessage.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return PairSerializerMessage;\n})();\n\nexport const CollabIDMessage = /*@__PURE__*/ (() => {\n\n    /**\n     * Properties of a CollabIDMessage.\n     * @exports ICollabIDMessage\n     * @interface ICollabIDMessage\n     * @property {Array.<string>|null} [collabIDPath] CollabIDMessage collabIDPath\n     */\n\n    /**\n     * Constructs a new CollabIDMessage.\n     * @exports CollabIDMessage\n     * @classdesc Represents a CollabIDMessage.\n     * @implements ICollabIDMessage\n     * @constructor\n     * @param {ICollabIDMessage=} [properties] Properties to set\n     */\n    function CollabIDMessage(properties) {\n        this.collabIDPath = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * CollabIDMessage collabIDPath.\n     * @member {Array.<string>} collabIDPath\n     * @memberof CollabIDMessage\n     * @instance\n     */\n    CollabIDMessage.prototype.collabIDPath = $util.emptyArray;\n\n    /**\n     * Creates a new CollabIDMessage instance using the specified properties.\n     * @function create\n     * @memberof CollabIDMessage\n     * @static\n     * @param {ICollabIDMessage=} [properties] Properties to set\n     * @returns {CollabIDMessage} CollabIDMessage instance\n     */\n    CollabIDMessage.create = function create(properties) {\n        return new CollabIDMessage(properties);\n    };\n\n    /**\n     * Encodes the specified CollabIDMessage message. Does not implicitly {@link CollabIDMessage.verify|verify} messages.\n     * @function encode\n     * @memberof CollabIDMessage\n     * @static\n     * @param {ICollabIDMessage} message CollabIDMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    CollabIDMessage.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.collabIDPath != null && message.collabIDPath.length)\n            for (let i = 0; i < message.collabIDPath.length; ++i)\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.collabIDPath[i]);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified CollabIDMessage message, length delimited. Does not implicitly {@link CollabIDMessage.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof CollabIDMessage\n     * @static\n     * @param {ICollabIDMessage} message CollabIDMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    CollabIDMessage.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a CollabIDMessage message from the specified reader or buffer.\n     * @function decode\n     * @memberof CollabIDMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CollabIDMessage} CollabIDMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CollabIDMessage.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new CollabIDMessage();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                if (!(message.collabIDPath && message.collabIDPath.length))\n                    message.collabIDPath = [];\n                message.collabIDPath.push(reader.string());\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a CollabIDMessage message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof CollabIDMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {CollabIDMessage} CollabIDMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CollabIDMessage.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a CollabIDMessage message.\n     * @function verify\n     * @memberof CollabIDMessage\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    CollabIDMessage.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.collabIDPath != null && message.hasOwnProperty(\"collabIDPath\")) {\n            if (!Array.isArray(message.collabIDPath))\n                return \"collabIDPath: array expected\";\n            for (let i = 0; i < message.collabIDPath.length; ++i)\n                if (!$util.isString(message.collabIDPath[i]))\n                    return \"collabIDPath: string[] expected\";\n        }\n        return null;\n    };\n\n    /**\n     * Creates a CollabIDMessage message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof CollabIDMessage\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {CollabIDMessage} CollabIDMessage\n     */\n    CollabIDMessage.fromObject = function fromObject(object) {\n        if (object instanceof CollabIDMessage)\n            return object;\n        let message = new CollabIDMessage();\n        if (object.collabIDPath) {\n            if (!Array.isArray(object.collabIDPath))\n                throw TypeError(\".CollabIDMessage.collabIDPath: array expected\");\n            message.collabIDPath = [];\n            for (let i = 0; i < object.collabIDPath.length; ++i)\n                message.collabIDPath[i] = String(object.collabIDPath[i]);\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a CollabIDMessage message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof CollabIDMessage\n     * @static\n     * @param {CollabIDMessage} message CollabIDMessage\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    CollabIDMessage.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults)\n            object.collabIDPath = [];\n        if (message.collabIDPath && message.collabIDPath.length) {\n            object.collabIDPath = [];\n            for (let j = 0; j < message.collabIDPath.length; ++j)\n                object.collabIDPath[j] = message.collabIDPath[j];\n        }\n        return object;\n    };\n\n    /**\n     * Converts this CollabIDMessage to JSON.\n     * @function toJSON\n     * @memberof CollabIDMessage\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    CollabIDMessage.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return CollabIDMessage;\n})();\n\nexport const OptionalMessage = /*@__PURE__*/ (() => {\n\n    /**\n     * Properties of an OptionalMessage.\n     * @exports IOptionalMessage\n     * @interface IOptionalMessage\n     * @property {Uint8Array|null} [valueIfPresent] OptionalMessage valueIfPresent\n     */\n\n    /**\n     * Constructs a new OptionalMessage.\n     * @exports OptionalMessage\n     * @classdesc Represents an OptionalMessage.\n     * @implements IOptionalMessage\n     * @constructor\n     * @param {IOptionalMessage=} [properties] Properties to set\n     */\n    function OptionalMessage(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * OptionalMessage valueIfPresent.\n     * @member {Uint8Array} valueIfPresent\n     * @memberof OptionalMessage\n     * @instance\n     */\n    OptionalMessage.prototype.valueIfPresent = $util.newBuffer([]);\n\n    /**\n     * Creates a new OptionalMessage instance using the specified properties.\n     * @function create\n     * @memberof OptionalMessage\n     * @static\n     * @param {IOptionalMessage=} [properties] Properties to set\n     * @returns {OptionalMessage} OptionalMessage instance\n     */\n    OptionalMessage.create = function create(properties) {\n        return new OptionalMessage(properties);\n    };\n\n    /**\n     * Encodes the specified OptionalMessage message. Does not implicitly {@link OptionalMessage.verify|verify} messages.\n     * @function encode\n     * @memberof OptionalMessage\n     * @static\n     * @param {IOptionalMessage} message OptionalMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    OptionalMessage.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.valueIfPresent != null && Object.hasOwnProperty.call(message, \"valueIfPresent\"))\n            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.valueIfPresent);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified OptionalMessage message, length delimited. Does not implicitly {@link OptionalMessage.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof OptionalMessage\n     * @static\n     * @param {IOptionalMessage} message OptionalMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    OptionalMessage.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes an OptionalMessage message from the specified reader or buffer.\n     * @function decode\n     * @memberof OptionalMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {OptionalMessage} OptionalMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    OptionalMessage.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new OptionalMessage();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.valueIfPresent = reader.bytes();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes an OptionalMessage message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof OptionalMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {OptionalMessage} OptionalMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    OptionalMessage.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies an OptionalMessage message.\n     * @function verify\n     * @memberof OptionalMessage\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    OptionalMessage.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.valueIfPresent != null && message.hasOwnProperty(\"valueIfPresent\"))\n            if (!(message.valueIfPresent && typeof message.valueIfPresent.length === \"number\" || $util.isString(message.valueIfPresent)))\n                return \"valueIfPresent: buffer expected\";\n        return null;\n    };\n\n    /**\n     * Creates an OptionalMessage message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof OptionalMessage\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {OptionalMessage} OptionalMessage\n     */\n    OptionalMessage.fromObject = function fromObject(object) {\n        if (object instanceof OptionalMessage)\n            return object;\n        let message = new OptionalMessage();\n        if (object.valueIfPresent != null)\n            if (typeof object.valueIfPresent === \"string\")\n                $util.base64.decode(object.valueIfPresent, message.valueIfPresent = $util.newBuffer($util.base64.length(object.valueIfPresent)), 0);\n            else if (object.valueIfPresent.length)\n                message.valueIfPresent = object.valueIfPresent;\n        return message;\n    };\n\n    /**\n     * Creates a plain object from an OptionalMessage message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof OptionalMessage\n     * @static\n     * @param {OptionalMessage} message OptionalMessage\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    OptionalMessage.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.defaults)\n            if (options.bytes === String)\n                object.valueIfPresent = \"\";\n            else {\n                object.valueIfPresent = [];\n                if (options.bytes !== Array)\n                    object.valueIfPresent = $util.newBuffer(object.valueIfPresent);\n            }\n        if (message.valueIfPresent != null && message.hasOwnProperty(\"valueIfPresent\"))\n            object.valueIfPresent = options.bytes === String ? $util.base64.encode(message.valueIfPresent, 0, message.valueIfPresent.length) : options.bytes === Array ? Array.prototype.slice.call(message.valueIfPresent) : message.valueIfPresent;\n        return object;\n    };\n\n    /**\n     * Converts this OptionalMessage to JSON.\n     * @function toJSON\n     * @memberof OptionalMessage\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    OptionalMessage.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return OptionalMessage;\n})();\n\nexport { $root as default };\n","var _a;\nclass FakeWeakRef {\n    constructor(targetObject) {\n        this.targetObject = targetObject;\n        this[_a] = \"WeakRef\";\n    }\n    deref() {\n        return this.targetObject;\n    }\n}\n_a = Symbol.toStringTag;\n/**\n * WeakRef \"polyfill\" that will use a normal object if WeakRef is not supported.\n */\nexport const SafeWeakRef = typeof WeakRef === \"undefined\" ? FakeWeakRef : WeakRef;\n//# sourceMappingURL=safe_weak_ref.js.map","var _a, _b;\nimport * as utf8 from \"@protobufjs/utf8\";\nimport { ArrayMessage, CollabIDMessage, DefaultSerializerMessage, ObjectMessage, PairSerializerMessage, } from \"../../generated/proto_compiled\";\nimport { Collab } from \"../core\";\nimport { nonNull } from \"./assertions\";\nimport { Optional } from \"./optional\";\nimport { SafeWeakRef } from \"./safe_weak_ref\";\n// In this file, we generally cache instances in case each\n// element of a collection constructs a derived serializer\n// from a fixed given one.\n/**\n * Default [[Serializer]].\n *\n * Supported types are a superset of JSON:\n * - Primitive types (string, number, boolean, undefined, null)\n * - Arrays and plain (non-class) objects, serialized recursively\n * - [[CollabID]]s (covered by the previous case since they are plain objects)\n * - Uint8Array\n * - [[Optional]]<T>, with T serialized recursively.\n *\n * All other types cause an error during [[serialize]].\n *\n * Construct using [[getInstance]].\n */\nexport class DefaultSerializer {\n    constructor() {\n        // Singleton.\n    }\n    /**\n     * Returns an instance of [[DefaultSerializer]].\n     *\n     * Internally, all instances are the same literal object.\n     */\n    static getInstance() {\n        return this.instance;\n    }\n    serialize(value) {\n        let message;\n        switch (typeof value) {\n            case \"string\":\n                message = { stringValue: value };\n                break;\n            case \"number\":\n                if (Number.isSafeInteger(value)) {\n                    message = { intValue: value };\n                }\n                else {\n                    message = { doubleValue: value };\n                }\n                break;\n            case \"boolean\":\n                message = { booleanValue: value };\n                break;\n            case \"undefined\":\n                message = { undefinedValue: true };\n                break;\n            case \"object\":\n                if (value === null) {\n                    message = { nullValue: true };\n                }\n                else if (value instanceof Uint8Array) {\n                    message = {\n                        bytesValue: value,\n                    };\n                }\n                else if (Array.isArray(value)) {\n                    // Technically types are bad for recursive\n                    // call to this.serialize, but it's okay because\n                    // we ignore our generic type.\n                    message = {\n                        arrayValue: ArrayMessage.create({\n                            elements: value.map((element) => this.serialize(element)),\n                        }),\n                    };\n                }\n                else if (value instanceof Optional) {\n                    message = {\n                        optionalValue: {\n                            valueIfPresent: value.isPresent\n                                ? this.serialize(value.get())\n                                : undefined,\n                        },\n                    };\n                }\n                else {\n                    const constructor = value.constructor;\n                    if (constructor === Object) {\n                        // Technically types are bad for recursive\n                        // call to this.serialize, but it's okay because\n                        // we ignore our generic type.\n                        const properties = {};\n                        for (const [key, property] of Object.entries(value)) {\n                            properties[key] = this.serialize(property);\n                        }\n                        message = {\n                            objectValue: ObjectMessage.create({\n                                properties,\n                            }),\n                        };\n                    }\n                    else if (value instanceof Collab) {\n                        throw new Error(\"Collab serialization is not supported; serialize a CollabID instead\");\n                    }\n                    else {\n                        throw new Error(`Unsupported class type for DefaultSerializer: ${constructor.name}; you must use a custom serializer or a plain (non-class) Object`);\n                    }\n                }\n                break;\n            default:\n                throw new Error(`Unsupported type for DefaultSerializer: ${typeof value}; you must use a custom Serializer`);\n        }\n        return DefaultSerializerMessage.encode(message).finish();\n    }\n    deserialize(message) {\n        const decoded = DefaultSerializerMessage.decode(message);\n        let ans;\n        switch (decoded.value) {\n            case \"stringValue\":\n                ans = decoded.stringValue;\n                break;\n            case \"intValue\":\n                ans = int64AsNumber(decoded.intValue);\n                break;\n            case \"doubleValue\":\n                ans = decoded.doubleValue;\n                break;\n            case \"booleanValue\":\n                ans = decoded.booleanValue;\n                break;\n            case \"undefinedValue\":\n                ans = undefined;\n                break;\n            case \"nullValue\":\n                ans = null;\n                break;\n            case \"arrayValue\":\n                ans = nonNull(nonNull(decoded.arrayValue).elements).map((serialized) => this.deserialize(serialized));\n                break;\n            case \"objectValue\":\n                ans = {};\n                for (const [key, serialized] of Object.entries(nonNull(nonNull(decoded.objectValue).properties))) {\n                    ans[key] = this.deserialize(serialized);\n                }\n                break;\n            case \"bytesValue\":\n                ans = decoded.bytesValue;\n                break;\n            case \"optionalValue\": {\n                const optionalValue = nonNull(decoded.optionalValue);\n                if (protobufHas(optionalValue, \"valueIfPresent\")) {\n                    ans = Optional.of(this.deserialize(nonNull(optionalValue.valueIfPresent)));\n                }\n                else\n                    ans = Optional.empty();\n                break;\n            }\n            default:\n                throw new Error(`Bad message format: decoded.value=${decoded.value}`);\n        }\n        // No way of checking if it's really type T.\n        return ans;\n    }\n}\n_a = DefaultSerializer;\nDefaultSerializer.instance = new _a();\n/**\n * Serializer for Uint8Array that is the identity function.\n *\n * This is a singleton class; use [[instance]]\n * instead of the constructor.\n */\nexport class Uint8ArraySerializer {\n    constructor() {\n        // Use Uint8ArraySerializer.instance instead.\n    }\n    serialize(value) {\n        return value;\n    }\n    deserialize(message) {\n        return message;\n    }\n}\nUint8ArraySerializer.instance = new Uint8ArraySerializer();\n/**\n * Serializer for string that uses utf-8 encoding.\n *\n * This is a singleton class; use [[instance]]\n * instead of the constructor.\n */\nexport class StringSerializer {\n    constructor() {\n        // Use StringSerializer.instance instead.\n    }\n    serialize(value) {\n        const ans = new Uint8Array(utf8.length(value));\n        utf8.write(value, ans, 0);\n        return ans;\n    }\n    deserialize(message) {\n        return utf8.read(message, 0, message.length);\n    }\n}\nStringSerializer.instance = new StringSerializer();\n/**\n * Serializes T\\[\\] using a serializer for T. This is slightly more efficient\n * than [[DefaultSerializer]], and it works with arbitrary T.\n *\n * Construct using [[getInstance]].\n */\nexport class ArraySerializer {\n    constructor(valueSerializer) {\n        this.valueSerializer = valueSerializer;\n    }\n    serialize(values) {\n        const message = ArrayMessage.create({\n            elements: values.map((value) => this.valueSerializer.serialize(value)),\n        });\n        return ArrayMessage.encode(message).finish();\n    }\n    deserialize(message) {\n        const decoded = ArrayMessage.decode(message);\n        return decoded.elements.map((bytes) => this.valueSerializer.deserialize(bytes));\n    }\n    /**\n     * Returns an instance of [[ArraySerializer]] that uses valueSerializer\n     * to serialize each value.\n     *\n     * This method may cache instances internally to save memory.\n     */\n    static getInstance(valueSerializer) {\n        const existingWeak = this.cache.get(valueSerializer);\n        if (existingWeak !== undefined) {\n            const existing = existingWeak.deref();\n            if (existing !== undefined)\n                return existing;\n        }\n        const ret = new ArraySerializer(valueSerializer);\n        this.cache.set(valueSerializer, new SafeWeakRef(ret));\n        return ret;\n    }\n}\n// Weak in both keys and values.\nArraySerializer.cache = new WeakMap();\n/**\n * Serializes \\[T, U\\] using serializers for T and U. This is slightly more efficient\n * than [[DefaultSerializer]], and it works with arbitrary T and U.\n */\nexport class PairSerializer {\n    constructor(oneSerializer, twoSerializer) {\n        this.oneSerializer = oneSerializer;\n        this.twoSerializer = twoSerializer;\n    }\n    serialize(value) {\n        const message = PairSerializerMessage.create({\n            one: this.oneSerializer.serialize(value[0]),\n            two: this.twoSerializer.serialize(value[1]),\n        });\n        return PairSerializerMessage.encode(message).finish();\n    }\n    deserialize(message) {\n        const decoded = PairSerializerMessage.decode(message);\n        return [\n            this.oneSerializer.deserialize(decoded.one),\n            this.twoSerializer.deserialize(decoded.two),\n        ];\n    }\n}\nconst emptyUint8Array = new Uint8Array();\n/**\n * Serializes a fixed value as an empty Uint8Array.\n */\nexport class ConstSerializer {\n    /**\n     * @param value The value that [[deserialize]] will always return.\n     */\n    constructor(value) {\n        this.value = value;\n    }\n    serialize(_value) {\n        return emptyUint8Array;\n    }\n    deserialize(_message) {\n        return this.value;\n    }\n}\n/**\n * Serializes [[CollabID]]s. This is slightly more efficient\n * than [[DefaultSerializer]].\n *\n * Construct using [[getInstance]].\n */\nexport class CollabIDSerializer {\n    constructor() {\n        // Singleton.\n    }\n    /**\n     * Returns an instance of [[CollabIDSerializer]].\n     *\n     * Internally, all instances are the same literal object.\n     */\n    static getInstance() {\n        return this.instance;\n    }\n    serialize(value) {\n        const message = CollabIDMessage.create({\n            collabIDPath: value.collabIDPath,\n        });\n        return CollabIDMessage.encode(message).finish();\n    }\n    deserialize(message) {\n        const decoded = CollabIDMessage.decode(message);\n        return { collabIDPath: decoded.collabIDPath };\n    }\n}\n_b = CollabIDSerializer;\nCollabIDSerializer.instance = new _b();\n/**\n * Internal utility for working with protobuf encodings.\n *\n * Apply this function to protobuf.js uint64 and sint64 output values\n * to convert them to the nearest JS number (double).\n * For safe integers, this is exact.\n */\nexport function int64AsNumber(num) {\n    // In theory you can \"request\" protobuf.js to not use\n    // Longs by not depending on the Long library, in which case\n    // you can just cast to number. But that is\n    // flaky because a dependency might import Long.\n    if (typeof num === \"number\")\n        return num;\n    else\n        return num.toNumber();\n}\n/**\n * Internal utility for working with protobuf encodings.\n *\n * Returns whether the optional property `prop` is present in\n * the deserialized protobufjs message `message`. (Accessing a not-present\n * property directly will return its type's default value\n * instead of `undefined`.)\n */\nexport function protobufHas(message, prop) {\n    // message is allowed to be Partial in case it's an I...Message type\n    // (e.g. an inner field of a deserialized protobufjs message),\n    // which has all optional properties.\n    // Despite Partial, TypeScript will still complain if you misspell\n    // prop.\n    return Object.prototype.hasOwnProperty.call(message, prop);\n}\n//# sourceMappingURL=serializers.js.map","import { OptionalMessage, } from \"../../generated/proto_compiled\";\nimport { SafeWeakRef } from \"./safe_weak_ref\";\nimport { protobufHas } from \"./serializers\";\n/**\n * An optional value of type T.\n *\n * Construct using [[Optional.of]] or [[Optional.empty]].\n *\n * Collabs uses this utility type in places where `T | undefined` or\n * `T | null` is inappropriate because T may itself be\n * null/undefined.\n *\n * Local data structure - not a [[Collab]].\n */\nexport class Optional {\n    constructor(\n    /** Whether the value is present. */\n    isPresent, valueIfPresent) {\n        this.isPresent = isPresent;\n        this.valueIfPresent = valueIfPresent;\n    }\n    /**\n     * Returns the value if present, else throwing an error.\n     */\n    get() {\n        if (!this.isPresent) {\n            throw new Error(\"Optional.get() called but isPresent is false\");\n        }\n        // Use ! instead of nonNull because T might allow null.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return this.valueIfPresent;\n    }\n    /**\n     * Returns the value if present, else returning other.\n     */\n    orElse(other) {\n        // Use ! instead of nonNull because T might allow null.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        if (this.isPresent)\n            return this.valueIfPresent;\n        else\n            return other;\n    }\n    /**\n     * Map the value by f if present, else returning an empty Optional.\n     * @param  f               [description]\n     * @return                [description]\n     */\n    map(f) {\n        // Use ! instead of nonNull because T might allow null.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        if (this.isPresent)\n            return Optional.of(f(this.valueIfPresent));\n        else\n            return Optional.empty();\n    }\n    toString() {\n        if (this.isPresent) {\n            return `Optional.of(${this.get()})`;\n        }\n        else\n            return \"Optional.empty()\";\n    }\n    /**\n     * Returns an empty (not present) Optional.\n     *\n     * Internally, all empty Optionals are the same literal object.\n     */\n    static empty() {\n        return Optional.emptyInstance;\n    }\n    /**\n     * Returns a new present Optional representing value.\n     */\n    static of(value) {\n        return new Optional(true, value);\n    }\n}\nOptional.emptyInstance = new Optional(false, undefined);\n/**\n * Serializes [[Optional]]`<T>` using a serializer for T.\n * This is slightly more efficient\n * than [[DefaultSerializer]], and it works with arbitrary T.\n *\n * Construct using [[getInstance]].\n */\nexport class OptionalSerializer {\n    constructor(valueSerializer) {\n        this.valueSerializer = valueSerializer;\n    }\n    serialize(value) {\n        const imessage = {};\n        if (value.isPresent) {\n            imessage.valueIfPresent = this.valueSerializer.serialize(value.get());\n        }\n        const message = OptionalMessage.create(imessage);\n        return OptionalMessage.encode(message).finish();\n    }\n    deserialize(message) {\n        const decoded = OptionalMessage.decode(message);\n        if (protobufHas(decoded, \"valueIfPresent\")) {\n            return Optional.of(this.valueSerializer.deserialize(decoded.valueIfPresent));\n        }\n        else\n            return Optional.empty();\n    }\n    /**\n     * Returns an instance of [[OptionalSerializer]] that uses valueSerializer\n     * to serialize present values.\n     *\n     * This method may cache instances internally to save memory.\n     */\n    static getInstance(valueSerializer) {\n        const existingWeak = OptionalSerializer.cache.get(valueSerializer);\n        if (existingWeak !== undefined) {\n            const existing = existingWeak.deref();\n            if (existing !== undefined)\n                return existing;\n        }\n        const ret = new OptionalSerializer(valueSerializer);\n        OptionalSerializer.cache.set(valueSerializer, new SafeWeakRef(ret));\n        return ret;\n    }\n}\n// Weak in both keys and values.\nOptionalSerializer.cache = new WeakMap();\n//# sourceMappingURL=optional.js.map","var _a, _b;\nimport { util } from \"protobufjs/minimal\";\nimport { MessageStacksMessage, SavedStateTreeMessage, } from \"../../generated/proto_compiled\";\n/**\n * Serializer for a batch of message stacks sent by [[Collab]]s,\n * represented as an array of `(Uint8Array | string)[]`.\n *\n * [[IRuntime]] implementations may use [[instance]]\n * to convert a batch of Collab messages into a single Uint8Array.\n *\n * As a common-case\n * optimization, this serializer applies suffix compression to\n * message stacks: shared (string) suffixes will only appear once\n * in the serialized message. That helps when stacks contain\n * Collab paths and there are multiple messages from Collabs in\n * similar parts of the Collab tree.\n *\n * This is a singleton class; use [[instance]]\n * instead of the constructor.\n */\nexport class MessageStacksSerializer {\n    constructor() {\n        // Singleton.\n    }\n    serialize(value) {\n        if (value.length === 1) {\n            // Case of single messageStack.\n            const message = MessageStacksMessage.create(this.serializeEdgeLabels(value[0]));\n            return MessageStacksMessage.encode(message).finish();\n        }\n        else {\n            // General case (tree).\n            // Treat each message stack as a path from node to root in a tree,\n            // where edges with the same parent & *string* label are identical.\n            // Then serialize the tree plus the id of each message stack's node\n            // in the tree, in order.\n            // Map from a parent node ID & string edge label to the corresponding\n            // child node ID.\n            const children = new Map();\n            const edgeLabels = [];\n            // ID of each edge's parent. ID 0 = root, ID n + 1 =\n            // tail of edgeLabels[n].\n            const edgeParents = [];\n            const messageStackIDs = [];\n            for (const messageStack of value) {\n                let parent = 0;\n                // Set to false after we encounter a non-string.\n                let useCache = true;\n                // Iterate messageStack backwards (root to node).\n                for (let i = messageStack.length - 1; i >= 0; i--) {\n                    const message = messageStack[i];\n                    if (useCache && typeof message === \"string\") {\n                        // See if this node already exists.\n                        let parentMap = children.get(parent);\n                        const cachedID = parentMap?.get(message);\n                        if (cachedID !== undefined) {\n                            parent = cachedID;\n                        }\n                        else {\n                            edgeLabels.push(message);\n                            edgeParents.push(parent);\n                            // Cache it.\n                            if (parentMap === undefined) {\n                                parentMap = new Map();\n                                children.set(parent, parentMap);\n                            }\n                            parentMap.set(message, edgeLabels.length);\n                            parent = edgeLabels.length;\n                        }\n                    }\n                    else {\n                        useCache = false;\n                        edgeLabels.push(message);\n                        edgeParents.push(parent);\n                        parent = edgeLabels.length;\n                    }\n                }\n                messageStackIDs.push(parent);\n            }\n            const message = MessageStacksMessage.create({\n                ...this.serializeEdgeLabels(edgeLabels),\n                edgeParents,\n                messageStackIDs,\n            });\n            return MessageStacksMessage.encode(message).finish();\n        }\n    }\n    deserialize(message) {\n        const decoded = MessageStacksMessage.decode(message);\n        const edgeLabels = this.deserializeEdgeLabels(decoded);\n        if (decoded.messageStackIDs.length === 0) {\n            // Case of single messageStack.\n            return [edgeLabels];\n        }\n        else {\n            // General case (tree).\n            const messageStacks = new Array(decoded.messageStackIDs.length);\n            for (let i = 0; i < messageStacks.length; i++) {\n                const messageStack = [];\n                // Stack from the node to the root, which is the right order\n                // for messageStack.\n                let nextID = decoded.messageStackIDs[i];\n                while (nextID !== 0) {\n                    messageStack.push(edgeLabels[nextID - 1]);\n                    nextID = decoded.edgeParents[nextID - 1];\n                }\n                messageStacks[i] = messageStack;\n            }\n            return messageStacks;\n        }\n    }\n    serializeEdgeLabels(edgeLabels) {\n        // Put messageStack's messages in order into edgeLabels.\n        // First need to know how long to make edgeLabelsPacked.\n        const edgeLabelLengths = new Array(edgeLabels.length);\n        let packedLength = 0;\n        for (let i = 0; i < edgeLabels.length; i++) {\n            const edgeLabel = edgeLabels[i];\n            if (typeof edgeLabel === \"string\") {\n                const length = util.utf8.length(edgeLabel);\n                edgeLabelLengths[i] = ~length;\n                packedLength += length;\n            }\n            else {\n                edgeLabelLengths[i] = edgeLabel.length;\n                packedLength += edgeLabel.length;\n            }\n        }\n        const edgeLabelsPacked = new Uint8Array(packedLength);\n        let offset = 0;\n        for (let i = 0; i < edgeLabels.length; i++) {\n            const edgeLabel = edgeLabels[i];\n            if (typeof edgeLabel === \"string\") {\n                // OPT: TextEncoder (browser native) instead? Same for read.\n                util.utf8.write(edgeLabel, edgeLabelsPacked, offset);\n            }\n            else {\n                edgeLabelsPacked.set(edgeLabel, offset);\n            }\n            offset += edgeLabel.length;\n        }\n        return { edgeLabelsPacked, edgeLabelLengths };\n    }\n    deserializeEdgeLabels(decoded) {\n        const edgeLabels = new Array(decoded.edgeLabelLengths.length);\n        let offset = 0;\n        for (let i = 0; i < decoded.edgeLabelLengths.length; i++) {\n            const signedLength = decoded.edgeLabelLengths[i];\n            if (signedLength < 0) {\n                // string, actual length is ~signedLengthI.\n                const length = ~signedLength;\n                edgeLabels[i] = util.utf8.read(decoded.edgeLabelsPacked, offset, offset + length);\n                offset += length;\n            }\n            else {\n                // Uint8Array, actual length is signedLengthI.\n                edgeLabels[i] = new Uint8Array(decoded.edgeLabelsPacked.buffer, offset + decoded.edgeLabelsPacked.byteOffset, signedLength);\n                offset += signedLength;\n            }\n        }\n        return edgeLabels;\n    }\n}\n_a = MessageStacksSerializer;\nMessageStacksSerializer.instance = new _a();\n/**\n * Serializer for a [[SavedStateTree]], i.e., an output of [[Collab.save]].\n *\n * [[IRuntime]] implementations may use [[instance]]\n * to convert Collabs's saved states into a single Uint8Array.\n *\n * This is a singleton class; use [[instance]]\n * instead of the constructor.\n */\nexport class SavedStateTreeSerializer {\n    constructor() {\n        // Singleton.\n    }\n    serialize(value) {\n        const message = this.toMessage(value);\n        return SavedStateTreeMessage.encode(message).finish();\n    }\n    deserialize(message) {\n        const decoded = SavedStateTreeMessage.decode(message);\n        return this.fromMessage(decoded);\n    }\n    toMessage(tree) {\n        if (tree.children === undefined)\n            return { self: tree.self };\n        const childrenKeys = new Array(tree.children.size);\n        const childrenValues = new Array(tree.children.size);\n        let i = 0;\n        for (const [key, value] of tree.children) {\n            childrenKeys[i] = key;\n            childrenValues[i] = this.toMessage(value);\n            i++;\n        }\n        return { self: tree.self, childrenKeys, childrenValues };\n    }\n    fromMessage(message) {\n        const children = new Map();\n        for (let i = 0; i < message.childrenKeys.length; i++) {\n            children.set(message.childrenKeys[i], \n            // From the generated protobuf, this is actually a SavedStateTreeMessage,\n            // not just an ISavedStateTreeMessage.\n            this.fromMessage(message.childrenValues[i]));\n        }\n        return { self: message.self, children };\n    }\n}\n_b = SavedStateTreeSerializer;\nSavedStateTreeSerializer.instance = new _b();\n//# sourceMappingURL=update_serializers.js.map","import { SafeWeakRef } from \"./safe_weak_ref\";\n/**\n * A map with weakly held values (not keys like WeakMap).\n *\n * Local data structure - not a [[Collab]].\n */\nexport class WeakValueMap {\n    constructor() {\n        this.internalMap = new Map();\n        if (typeof FinalizationRegistry !== \"undefined\") {\n            this.registry = new FinalizationRegistry((key) => this.checkKey(key));\n        }\n    }\n    clear() {\n        this.internalMap.clear();\n    }\n    delete(key) {\n        this.internalMap.delete(key);\n    }\n    get(key) {\n        const value = this.internalMap.get(key);\n        if (value === undefined)\n            return undefined;\n        const deref = value.deref();\n        if (deref === undefined)\n            this.delete(key);\n        return deref;\n    }\n    set(key, value) {\n        this.internalMap.set(key, new SafeWeakRef(value));\n        if (this.registry)\n            this.registry.register(value, key);\n    }\n    *[Symbol.iterator]() {\n        for (const entry of this.internalMap.entries()) {\n            const valueDeref = entry[1].deref();\n            if (valueDeref !== undefined)\n                yield [entry[0], valueDeref];\n        }\n    }\n    /**\n     * Check if the key's value no longer exists (has\n     * been reclaimed), and if\n     * so, delete the key.\n     * @param  key [description]\n     * @return     [description]\n     */\n    checkKey(key) {\n        const value = this.internalMap.get(key);\n        if (value !== undefined) {\n            if (value.deref() === undefined) {\n                this.delete(key);\n            }\n        }\n    }\n}\n//# sourceMappingURL=weak_value_map.js.map","import { fromByteArray, toByteArray } from \"base64-js\";\nimport { InitToken, collabIDOf, } from \"../core\";\n// Import from specific file to avoid circular dependencies.\nimport { AbstractMap_Collab } from \"../data_types/abstract_maps\";\nimport { DefaultSerializer, Optional, WeakValueMap } from \"../util\";\nimport { nonNull } from \"../util/assertions\";\n/**\n * A collaborative \"lazy\" map with keys of type K and *mutable*\n * values of type C.\n *\n * \"Lazy\" means that every key-value pair implicitly exists,\n * but only nontrivial values are actually stored in memory.\n * [[get]](key) will construct its value if needed using\n * the `valueConstructor` passed to the constructor.\n * This is inspired by [Apache Commons\n * LazyMap](https://commons.apache.org/proper/commons-collections/apidocs/org/apache/commons/collections4/map/LazyMap.html).\n *\n * Due to laziness, there is no explicit operation to \"set\"\n * the value at a key. (The [[set]] method\n * is a no-op.) Instead, all replicas [[get]] the same value,\n * and any operations they perform on that value are \"merged\",\n * affecting everyone.\n * This contrasts with [[CMap]], in which each [[set]] operation\n * overwrites the previous value at its key, erasing any\n * changes (including concurrent ones).\n *\n * See also: [[CMap]], [[CValueMap]].\n *\n * ## Key Presence\n *\n * All values implicitly exist, and [[get]] always returns non-undefined.\n * However, [[has]], [[getIfPresent]], [[size]], and iterators\n * determine key presence by:\n * a key is present if its value is nontrivial, i.e., not in the\n * initial state returned by `valueConstructor`.\n *\n * For example, a [[CVar]] is nontrivial after [[CVar.value]] is first set.\n * It becomes trivial again if [[CVar.clear]] is called and there are no\n * concurrent operations. (Generally, a `clear` method makes its Collab\n * trivial, except for lists.)\n *\n * \"Set\" and \"Delete\" events respect these key presence\n * rules: \"Set\" is emitted for a key when its value\n * goes from trivial to nontrivial, and \"Delete\"\n * is emitted when its value goes from nontrivial to trivial.\n * Because a \"Set\" event is not emitted until after a value becomes\n * nontrivial, it is important to register values' event handlers in\n * `valueConstructor` instead of during the \"Set\" event.\n *\n * [[delete]] and [[clear]] throw errors (grow-only semantics).\n * [[set]] has no effect; it just returns the same value\n * as [[get]].\n *\n * ## Garbage Collection\n *\n * Internally, a value is considered trivial if its [[Collab.canGC]]\n * method returns true or if it has performed no operations.\n * Trivial values are only weakly referenced and so may be garbage\n * collected. After garbage collection, they are re-created using\n * valueConstructor if needed.\n *\n * @typeParam K The type of keys.\n * @typeParam C The type of mutable values, represented by a Collab.\n */\nexport class CLazyMap extends AbstractMap_Collab {\n    /**\n     * Constructs a CLazyMap with the given `valueConstructor`.\n     *\n     * @param valueConstructor Callback used to construct a\n     * value Collab with the given key. See [collections of Collabs](https://collabs.readthedocs.io/en/latest/guide/collections.html)\n     * for example usage.\n     * This may be called multiple times for the same key due to garbage\n     * collection (see class header).\n     * @param options.keySerializer A serializer for keys.\n     * Defaults to [[DefaultSerializer]].\n     */\n    constructor(init, valueConstructor, options = {}) {\n        super(init);\n        this.valueConstructor = valueConstructor;\n        this.nontrivialMap = new Map();\n        this.trivialMap = new WeakValueMap();\n        /**\n         * Set when we are in applyUpdate's update() function.\n         *\n         * The referenced value's nontrivialMap/trivialMap membership reflects its\n         * pre-update value, which update() may have changed.\n         * So, methods that rely on nontrivialMap/trivialMap must\n         * manually check value.canGC() to determine if value is present.\n         */\n        this.inUpdateData = undefined;\n        this.keySerializer =\n            options.keySerializer ?? DefaultSerializer.getInstance();\n    }\n    keyAsString(key) {\n        return fromByteArray(this.keySerializer.serialize(key));\n    }\n    stringAsKey(str) {\n        return this.keySerializer.deserialize(toByteArray(str));\n    }\n    getInternal(key, keyString) {\n        let value = this.nontrivialMap.get(keyString);\n        if (value === undefined) {\n            // Check the backup map\n            value = this.trivialMap.get(keyString);\n            if (value === undefined) {\n                // Create it.\n                value = this.valueConstructor(new InitToken(keyString, this), key);\n                // The value starts trivial; if it becomes nontrivial\n                // due to receive or load, applyUpdate will move\n                // it to nontrivialMap.\n                this.trivialMap.set(keyString, value);\n            }\n            return [value, false];\n        }\n        else\n            return [value, true];\n    }\n    applyUpdate(keyString, update, meta) {\n        const key = this.stringAsKey(keyString);\n        const [value, nontrivialStart] = this.getInternal(key, keyString);\n        try {\n            // Set this.inUpdateData during update.\n            this.inUpdateData = { keyString, value, nontrivialStart };\n            update(value);\n        }\n        finally {\n            this.inUpdateData = undefined;\n        }\n        // If the value became GC-able, move it to the backup map.\n        if (nontrivialStart && value.canGC()) {\n            this.nontrivialMap.delete(keyString);\n            this.trivialMap.set(keyString, value);\n            this.emit(\"Delete\", { key, value, meta });\n        }\n        // If the value became nontrivial, move it to the main map.\n        else if (!nontrivialStart && !value.canGC()) {\n            this.trivialMap.delete(keyString);\n            this.nontrivialMap.set(keyString, value);\n            this.emit(\"Set\", {\n                key,\n                value,\n                previousValue: Optional.empty(),\n                meta,\n            });\n            // We don't dispatch Set events when the value\n            // is not new because there can only ever be one\n            // value at a given key.\n            // An exception is replacement due to GC-ing, but\n            // we consider such values \"the same\"; if users care\n            // about the distinction (e.g. because they need\n            // to register event handlers), they should do so\n            // in valueConstructor, not on Set events.\n        }\n    }\n    childSend(child, messageStack, metaRequests) {\n        if (child.parent !== this) {\n            throw new Error(`childSend called by non-child: ${child}`);\n        }\n        messageStack.push(child.name);\n        this.send(messageStack, metaRequests);\n    }\n    receive(messageStack, meta) {\n        const keyString = messageStack.pop();\n        this.applyUpdate(keyString, \n        // Message for a child\n        (value) => value.receive(messageStack, meta), meta);\n    }\n    /**\n     * No-op, just returns [[get]](key).\n     */\n    set(key) {\n        return this.get(key);\n    }\n    /**\n     * Unsupported (throws error).\n     */\n    delete(_key) {\n        throw new Error(\"Unsupported operation: delete\");\n    }\n    /**\n     * Unsupported (throws error).\n     */\n    clear() {\n        throw new Error(\"Unsupported operation: delete\");\n    }\n    /**\n     * Returns the value associated to key, constructing it with `valueConstructor`\n     * if needed.\n     *\n     * This will never return undefined, even if [[has]](key) is false.\n     * See [[getIfPresent]].\n     */\n    get(key) {\n        return this.getInternal(key, this.keyAsString(key))[0];\n    }\n    /**\n     * Returns the value associated to key, or `undefined` if it is not present.\n     *\n     * Key presence is defined in the class header.\n     */\n    getIfPresent(key) {\n        const str = this.keyAsString(key);\n        if (this.inUpdateData?.keyString === str) {\n            // Check value's presence directly instead of using nontrivialMap.\n            if (!this.inUpdateData.value.canGC()) {\n                return this.inUpdateData.value;\n            }\n            else\n                return undefined;\n        }\n        return this.nontrivialMap.get(this.keyAsString(key));\n    }\n    has(key) {\n        const str = this.keyAsString(key);\n        if (this.inUpdateData?.keyString === str) {\n            // Check value's presence directly instead of using nontrivialMap.\n            return !this.inUpdateData.value.canGC();\n        }\n        else\n            return this.nontrivialMap.has(str);\n    }\n    /**\n     * The number of present (nontrivial) values in the map.\n     */\n    get size() {\n        let delta = 0;\n        if (this.inUpdateData !== undefined) {\n            // Check if value's presence changed and adjust size accordingly.\n            if (this.inUpdateData.nontrivialStart &&\n                this.inUpdateData.value.canGC()) {\n                delta = -1;\n            }\n            else if (!this.inUpdateData.nontrivialStart &&\n                !this.inUpdateData.value.canGC()) {\n                delta = 1;\n            }\n        }\n        return this.nontrivialMap.size + delta;\n    }\n    *entries() {\n        for (const [keyString, value] of this.nontrivialMap) {\n            if (this.inUpdateData?.value === value) {\n                // Check value's presence directly instead of using nontrivialMap.\n                if (this.inUpdateData.value.canGC())\n                    continue;\n            }\n            yield [this.stringAsKey(keyString), value];\n        }\n        if (this.inUpdateData !== undefined) {\n            // Check if value is now present but wasn't in nontrivialMap during the\n            // above loop, hence needs to be emitted.\n            // Edge case: if you start an iterator inside update()\n            // and finish it outside (or vice-versa), I think you'll get the right\n            // answer from this + Map's iterator behavior, but I'm not sure.\n            if (!this.inUpdateData.nontrivialStart &&\n                !this.inUpdateData.value.canGC()) {\n                yield [\n                    this.stringAsKey(this.inUpdateData.keyString),\n                    this.inUpdateData.value,\n                ];\n            }\n        }\n    }\n    *values() {\n        // Override to avoid entries's stringAsKey calls.\n        for (const value of this.nontrivialMap.values()) {\n            if (this.inUpdateData?.value === value) {\n                // Check value's presence directly instead of using nontrivialMap.\n                if (this.inUpdateData.value.canGC())\n                    continue;\n            }\n            yield value;\n        }\n        if (this.inUpdateData !== undefined) {\n            // Check if value is now present but wasn't in nontrivialMap during the\n            // above loop, hence needs to be emitted.\n            // Edge case: if you start an iterator inside update()\n            // and finish it outside (or vice-versa), I think you'll get the right\n            // answer from this + Map's iterator behavior, but I'm not sure.\n            if (!this.inUpdateData.nontrivialStart &&\n                !this.inUpdateData.value.canGC()) {\n                yield this.inUpdateData.value;\n            }\n        }\n    }\n    /**\n     * Returns the unique key associated to a value\n     * in this map, in O(1) time.\n     *\n     * If value is not a value in this map, returned undefined.\n     *\n     * @param searchElement The value to locate in this map.\n     */\n    keyOf(searchElement) {\n        if (searchElement.parent !== this)\n            return undefined;\n        return this.stringAsKey(searchElement.name);\n    }\n    save() {\n        const childSaves = new Map();\n        // Only need to save nontrivial children, since trivial\n        // children are in their initial states.\n        for (const [name, child] of this.nontrivialMap) {\n            childSaves.set(name, child.save());\n        }\n        return {\n            children: childSaves,\n        };\n    }\n    load(savedStateTree, meta) {\n        if (savedStateTree === null) {\n            // Pass the null on to children that might override canGC().\n            for (const child of this.nontrivialMap.values())\n                child.load(null, meta);\n            return;\n        }\n        const children = nonNull(savedStateTree.children);\n        for (const [name, childSave] of children) {\n            this.applyUpdate(name, (child) => child.load(childSave, meta), meta);\n        }\n        // Call null on other (nontrivial) children, in case they weren't saved\n        // because they had canGC() = true in the saved state.\n        for (const name of this.nontrivialMap.keys()) {\n            if (!children.has(name)) {\n                this.applyUpdate(name, (child) => child.load(null, meta), meta);\n            }\n        }\n    }\n    idOf(descendant) {\n        return collabIDOf(descendant, this);\n    }\n    fromID(id, startIndex = 0) {\n        const name = id.collabIDPath[startIndex];\n        const child = this.getInternal(this.stringAsKey(name), name)[0];\n        // Terminal case.\n        // Note that this cast is unsafe, but convenient.\n        if (startIndex === id.collabIDPath.length - 1)\n            return child;\n        // Recursive case.\n        if (child.fromID === undefined) {\n            throw new Error(\"child is not a parent, but CollabID is its descendant\");\n        }\n        return child.fromID(id, startIndex + 1);\n    }\n    canGC() {\n        if (this.inUpdateData !== undefined) {\n            // Check value's presence directly instead of using nontrivialMap.\n            if (!this.inUpdateData.value.canGC())\n                return false;\n        }\n        /*\n         * It's okay to (JS) garbage collect us even if the backup map\n         * is non-empty:\n         * each value points to us (due to Collab.parent),\n         * so we will only be garbage collected if all of our children\n         * are also eligible for garbage collection.\n         */\n        return this.nontrivialMap.size === 0;\n    }\n}\n//# sourceMappingURL=c_lazy_map.js.map","import { CPrimitive } from \"../base_collabs/c_primitive\";\nimport { DefaultSerializer } from \"../util\";\n/**\n * A collaborative messenger.\n *\n * This Collab has no state; it merely broadcasts messages between replicas.\n * To receive messages, listen on Message events.\n *\n * Notes:\n * - When using the standard library (@collabs/collabs or @collabs/crdts),\n * concurrent messages may be received in different orders on different replicas.\n * - Messages are *not* persisted in saved state, and they are *not* replayed\n * during loading. Thus you must use CMessenger either for ephemeral messages\n * (safely forgotten between sessions), or save the resulting state separately\n * (e.g., by overriding [[CObject.save]] and [[CObject.load]]).\n * Or, use a CMessenger alternative:\n *   - Use [[CValueList.push]] as a persistent message log.\n *   - Subclass [[CPrimitive]] and use its internal messaging and save/load functions.\n *\n * @typeParam M The type of messages.\n */\nexport class CMessenger extends CPrimitive {\n    /**\n     * @param options.messageSerializer A serializer for messages.\n     * Defaults to [[DefaultSerializer]].\n     */\n    constructor(init, options = {}) {\n        super(init);\n        this.messageSerializer =\n            options.messageSerializer ?? DefaultSerializer.getInstance();\n    }\n    /**\n     * Sends the given message. It will be delivered in a Message event on\n     * all replicas, including this one.\n     */\n    sendMessage(message) {\n        const encoded = this.messageSerializer.serialize(message);\n        super.sendPrimitive(encoded);\n    }\n    receivePrimitive(message, meta) {\n        const decoded = this.messageSerializer.deserialize(message);\n        this.emit(\"Message\", {\n            message: decoded,\n            meta,\n        });\n    }\n    savePrimitive() {\n        return new Uint8Array();\n    }\n    loadPrimitive() {\n        // No-op.\n    }\n    canGC() {\n        return true;\n    }\n}\n//# sourceMappingURL=c_messenger.js.map","import { CPrimitive, } from \"@collabs/core\";\n/**\n * Convenience base class for a CRDT implementation that sends\n * its own messages over the network.\n *\n * Extend this class to implement a \"primitive\" CRDT with a simple\n * broadcast interface ([[sendCRDT]]/[[receiveCRDT]]) and no child\n * Collabs. This matches how most (op-based) CRDTs\n * are described algorithmically.\n *\n * This class differs from [[CPrimitive]] in that it requires [[CRuntime]],\n * and it makes it easier to work with [[CRuntime]]'s [[CRDTMessageMeta]].\n *\n * See also:\n * - [[CObject]], for an \"object\" Collab that does not need to send its own\n * messages.\n * - [[CPrimitive]], for general [[Collab]]s (not just CRDTs).\n */\nexport class PrimitiveCRDT extends CPrimitive {\n    constructor(init) {\n        super(init);\n        if (this.runtime.isCRDTRuntime !== true) {\n            throw new Error(\"this.runtime must be CRuntime or compatible\");\n        }\n    }\n    /**\n     * Broadcasts a message to other replicas of this CRDT.\n     * The message will be delivered to all replicas' [[receiveCRDT]],\n     * including locally.\n     *\n     * Call this method instead of [[Collab.send]] or [[CPrimitive.sendPrimitive]].\n     *\n     * By default, [[receiveCRDT]]'s `crdtMeta` will contain all fields that are accessed\n     * during the sender's local call to receiveCRDT.\n     * You can request additional fields with `metaRequest`.\n     *\n     * @param message The message to send.\n     */\n    sendCRDT(message, metaRequest) {\n        super.sendPrimitive(message, metaRequest);\n    }\n    /**\n     * Do not override; override [[receiveCRDT]] instead.\n     */\n    receivePrimitive(message, meta) {\n        this.receiveCRDT(message, meta, meta.runtimeExtra);\n    }\n    savePrimitive() {\n        return this.saveCRDT();\n    }\n    loadPrimitive(savedState, meta) {\n        this.loadCRDT(savedState, meta, meta.runtimeExtra);\n    }\n}\n//# sourceMappingURL=primitive_crdt.js.map","import { MakeAbstractList } from \"@collabs/core\";\nimport { PrimitiveCRDT } from \"./primitive_crdt\";\nexport const AbstractList_PrimitiveCRDT = MakeAbstractList(PrimitiveCRDT);\n//# sourceMappingURL=abstract_lists.js.map","import { MakeAbstractMap } from \"@collabs/core\";\nimport { PrimitiveCRDT } from \"./primitive_crdt\";\nexport const AbstractMap_PrimitiveCRDT = MakeAbstractMap(PrimitiveCRDT);\n//# sourceMappingURL=abstract_maps.js.map","import { MakeAbstractSet } from \"@collabs/core\";\nimport { PrimitiveCRDT } from \"./primitive_crdt\";\nexport const AbstractSet_PrimitiveCRDT = MakeAbstractSet(PrimitiveCRDT);\n//# sourceMappingURL=abstract_sets.js.map","/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\nimport * as $protobuf from \"protobufjs/minimal\";\n\n// Common aliases\nconst $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n// Exported root namespace\nconst $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\nexport const CSetMessage = /*@__PURE__*/ (() => {\n\n    /**\n     * Properties of a CSetMessage.\n     * @exports ICSetMessage\n     * @interface ICSetMessage\n     * @property {Uint8Array|null} [add] CSetMessage add\n     * @property {string|null} [\"delete\"] CSetMessage delete\n     */\n\n    /**\n     * Constructs a new CSetMessage.\n     * @exports CSetMessage\n     * @classdesc Represents a CSetMessage.\n     * @implements ICSetMessage\n     * @constructor\n     * @param {ICSetMessage=} [properties] Properties to set\n     */\n    function CSetMessage(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * CSetMessage add.\n     * @member {Uint8Array} add\n     * @memberof CSetMessage\n     * @instance\n     */\n    CSetMessage.prototype.add = $util.newBuffer([]);\n\n    /**\n     * CSetMessage delete.\n     * @member {string} delete\n     * @memberof CSetMessage\n     * @instance\n     */\n    CSetMessage.prototype[\"delete\"] = \"\";\n\n    // OneOf field names bound to virtual getters and setters\n    let $oneOfFields;\n\n    /**\n     * CSetMessage op.\n     * @member {\"add\"|\"delete\"|undefined} op\n     * @memberof CSetMessage\n     * @instance\n     */\n    Object.defineProperty(CSetMessage.prototype, \"op\", {\n        get: $util.oneOfGetter($oneOfFields = [\"add\", \"delete\"]),\n        set: $util.oneOfSetter($oneOfFields)\n    });\n\n    /**\n     * Creates a new CSetMessage instance using the specified properties.\n     * @function create\n     * @memberof CSetMessage\n     * @static\n     * @param {ICSetMessage=} [properties] Properties to set\n     * @returns {CSetMessage} CSetMessage instance\n     */\n    CSetMessage.create = function create(properties) {\n        return new CSetMessage(properties);\n    };\n\n    /**\n     * Encodes the specified CSetMessage message. Does not implicitly {@link CSetMessage.verify|verify} messages.\n     * @function encode\n     * @memberof CSetMessage\n     * @static\n     * @param {ICSetMessage} message CSetMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    CSetMessage.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.add != null && Object.hasOwnProperty.call(message, \"add\"))\n            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.add);\n        if (message[\"delete\"] != null && Object.hasOwnProperty.call(message, \"delete\"))\n            writer.uint32(/* id 2, wireType 2 =*/18).string(message[\"delete\"]);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified CSetMessage message, length delimited. Does not implicitly {@link CSetMessage.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof CSetMessage\n     * @static\n     * @param {ICSetMessage} message CSetMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    CSetMessage.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a CSetMessage message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSetMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSetMessage} CSetMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CSetMessage.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new CSetMessage();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.add = reader.bytes();\n                break;\n            case 2:\n                message[\"delete\"] = reader.string();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a CSetMessage message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof CSetMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {CSetMessage} CSetMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CSetMessage.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a CSetMessage message.\n     * @function verify\n     * @memberof CSetMessage\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    CSetMessage.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        let properties = {};\n        if (message.add != null && message.hasOwnProperty(\"add\")) {\n            properties.op = 1;\n            if (!(message.add && typeof message.add.length === \"number\" || $util.isString(message.add)))\n                return \"add: buffer expected\";\n        }\n        if (message[\"delete\"] != null && message.hasOwnProperty(\"delete\")) {\n            if (properties.op === 1)\n                return \"op: multiple values\";\n            properties.op = 1;\n            if (!$util.isString(message[\"delete\"]))\n                return \"delete: string expected\";\n        }\n        return null;\n    };\n\n    /**\n     * Creates a CSetMessage message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof CSetMessage\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {CSetMessage} CSetMessage\n     */\n    CSetMessage.fromObject = function fromObject(object) {\n        if (object instanceof CSetMessage)\n            return object;\n        let message = new CSetMessage();\n        if (object.add != null)\n            if (typeof object.add === \"string\")\n                $util.base64.decode(object.add, message.add = $util.newBuffer($util.base64.length(object.add)), 0);\n            else if (object.add.length)\n                message.add = object.add;\n        if (object[\"delete\"] != null)\n            message[\"delete\"] = String(object[\"delete\"]);\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a CSetMessage message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof CSetMessage\n     * @static\n     * @param {CSetMessage} message CSetMessage\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    CSetMessage.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (message.add != null && message.hasOwnProperty(\"add\")) {\n            object.add = options.bytes === String ? $util.base64.encode(message.add, 0, message.add.length) : options.bytes === Array ? Array.prototype.slice.call(message.add) : message.add;\n            if (options.oneofs)\n                object.op = \"add\";\n        }\n        if (message[\"delete\"] != null && message.hasOwnProperty(\"delete\")) {\n            object[\"delete\"] = message[\"delete\"];\n            if (options.oneofs)\n                object.op = \"delete\";\n        }\n        return object;\n    };\n\n    /**\n     * Converts this CSetMessage to JSON.\n     * @function toJSON\n     * @memberof CSetMessage\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    CSetMessage.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return CSetMessage;\n})();\n\nexport const CSetSave = /*@__PURE__*/ (() => {\n\n    /**\n     * Properties of a CSetSave.\n     * @exports ICSetSave\n     * @interface ICSetSave\n     * @property {Array.<Uint8Array>|null} [args] CSetSave args\n     */\n\n    /**\n     * Constructs a new CSetSave.\n     * @exports CSetSave\n     * @classdesc Represents a CSetSave.\n     * @implements ICSetSave\n     * @constructor\n     * @param {ICSetSave=} [properties] Properties to set\n     */\n    function CSetSave(properties) {\n        this.args = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * CSetSave args.\n     * @member {Array.<Uint8Array>} args\n     * @memberof CSetSave\n     * @instance\n     */\n    CSetSave.prototype.args = $util.emptyArray;\n\n    /**\n     * Creates a new CSetSave instance using the specified properties.\n     * @function create\n     * @memberof CSetSave\n     * @static\n     * @param {ICSetSave=} [properties] Properties to set\n     * @returns {CSetSave} CSetSave instance\n     */\n    CSetSave.create = function create(properties) {\n        return new CSetSave(properties);\n    };\n\n    /**\n     * Encodes the specified CSetSave message. Does not implicitly {@link CSetSave.verify|verify} messages.\n     * @function encode\n     * @memberof CSetSave\n     * @static\n     * @param {ICSetSave} message CSetSave message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    CSetSave.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.args != null && message.args.length)\n            for (let i = 0; i < message.args.length; ++i)\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.args[i]);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified CSetSave message, length delimited. Does not implicitly {@link CSetSave.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof CSetSave\n     * @static\n     * @param {ICSetSave} message CSetSave message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    CSetSave.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a CSetSave message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSetSave\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSetSave} CSetSave\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CSetSave.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new CSetSave();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                if (!(message.args && message.args.length))\n                    message.args = [];\n                message.args.push(reader.bytes());\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a CSetSave message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof CSetSave\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {CSetSave} CSetSave\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CSetSave.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a CSetSave message.\n     * @function verify\n     * @memberof CSetSave\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    CSetSave.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.args != null && message.hasOwnProperty(\"args\")) {\n            if (!Array.isArray(message.args))\n                return \"args: array expected\";\n            for (let i = 0; i < message.args.length; ++i)\n                if (!(message.args[i] && typeof message.args[i].length === \"number\" || $util.isString(message.args[i])))\n                    return \"args: buffer[] expected\";\n        }\n        return null;\n    };\n\n    /**\n     * Creates a CSetSave message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof CSetSave\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {CSetSave} CSetSave\n     */\n    CSetSave.fromObject = function fromObject(object) {\n        if (object instanceof CSetSave)\n            return object;\n        let message = new CSetSave();\n        if (object.args) {\n            if (!Array.isArray(object.args))\n                throw TypeError(\".CSetSave.args: array expected\");\n            message.args = [];\n            for (let i = 0; i < object.args.length; ++i)\n                if (typeof object.args[i] === \"string\")\n                    $util.base64.decode(object.args[i], message.args[i] = $util.newBuffer($util.base64.length(object.args[i])), 0);\n                else if (object.args[i].length)\n                    message.args[i] = object.args[i];\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a CSetSave message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof CSetSave\n     * @static\n     * @param {CSetSave} message CSetSave\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    CSetSave.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults)\n            object.args = [];\n        if (message.args && message.args.length) {\n            object.args = [];\n            for (let j = 0; j < message.args.length; ++j)\n                object.args[j] = options.bytes === String ? $util.base64.encode(message.args[j], 0, message.args[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.args[j]) : message.args[j];\n        }\n        return object;\n    };\n\n    /**\n     * Converts this CSetSave to JSON.\n     * @function toJSON\n     * @memberof CSetSave\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    CSetSave.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return CSetSave;\n})();\n\nexport const TotalOrderCreateMessage = /*@__PURE__*/ (() => {\n\n    /**\n     * Properties of a TotalOrderCreateMessage.\n     * @exports ITotalOrderCreateMessage\n     * @interface ITotalOrderCreateMessage\n     * @property {string|null} [parentWaypointSenderID] TotalOrderCreateMessage parentWaypointSenderID\n     * @property {number} parentWaypointCounterAndSide TotalOrderCreateMessage parentWaypointCounterAndSide\n     * @property {number} parentValueIndex TotalOrderCreateMessage parentValueIndex\n     */\n\n    /**\n     * Constructs a new TotalOrderCreateMessage.\n     * @exports TotalOrderCreateMessage\n     * @classdesc Represents a TotalOrderCreateMessage.\n     * @implements ITotalOrderCreateMessage\n     * @constructor\n     * @param {ITotalOrderCreateMessage=} [properties] Properties to set\n     */\n    function TotalOrderCreateMessage(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * TotalOrderCreateMessage parentWaypointSenderID.\n     * @member {string} parentWaypointSenderID\n     * @memberof TotalOrderCreateMessage\n     * @instance\n     */\n    TotalOrderCreateMessage.prototype.parentWaypointSenderID = \"\";\n\n    /**\n     * TotalOrderCreateMessage parentWaypointCounterAndSide.\n     * @member {number} parentWaypointCounterAndSide\n     * @memberof TotalOrderCreateMessage\n     * @instance\n     */\n    TotalOrderCreateMessage.prototype.parentWaypointCounterAndSide = 0;\n\n    /**\n     * TotalOrderCreateMessage parentValueIndex.\n     * @member {number} parentValueIndex\n     * @memberof TotalOrderCreateMessage\n     * @instance\n     */\n    TotalOrderCreateMessage.prototype.parentValueIndex = 0;\n\n    /**\n     * Creates a new TotalOrderCreateMessage instance using the specified properties.\n     * @function create\n     * @memberof TotalOrderCreateMessage\n     * @static\n     * @param {ITotalOrderCreateMessage=} [properties] Properties to set\n     * @returns {TotalOrderCreateMessage} TotalOrderCreateMessage instance\n     */\n    TotalOrderCreateMessage.create = function create(properties) {\n        return new TotalOrderCreateMessage(properties);\n    };\n\n    /**\n     * Encodes the specified TotalOrderCreateMessage message. Does not implicitly {@link TotalOrderCreateMessage.verify|verify} messages.\n     * @function encode\n     * @memberof TotalOrderCreateMessage\n     * @static\n     * @param {ITotalOrderCreateMessage} message TotalOrderCreateMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TotalOrderCreateMessage.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.parentWaypointSenderID != null && Object.hasOwnProperty.call(message, \"parentWaypointSenderID\"))\n            writer.uint32(/* id 1, wireType 2 =*/10).string(message.parentWaypointSenderID);\n        writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.parentWaypointCounterAndSide);\n        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.parentValueIndex);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified TotalOrderCreateMessage message, length delimited. Does not implicitly {@link TotalOrderCreateMessage.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof TotalOrderCreateMessage\n     * @static\n     * @param {ITotalOrderCreateMessage} message TotalOrderCreateMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TotalOrderCreateMessage.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a TotalOrderCreateMessage message from the specified reader or buffer.\n     * @function decode\n     * @memberof TotalOrderCreateMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {TotalOrderCreateMessage} TotalOrderCreateMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TotalOrderCreateMessage.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new TotalOrderCreateMessage();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.parentWaypointSenderID = reader.string();\n                break;\n            case 2:\n                message.parentWaypointCounterAndSide = reader.sint32();\n                break;\n            case 3:\n                message.parentValueIndex = reader.uint32();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        if (!message.hasOwnProperty(\"parentWaypointCounterAndSide\"))\n            throw $util.ProtocolError(\"missing required 'parentWaypointCounterAndSide'\", { instance: message });\n        if (!message.hasOwnProperty(\"parentValueIndex\"))\n            throw $util.ProtocolError(\"missing required 'parentValueIndex'\", { instance: message });\n        return message;\n    };\n\n    /**\n     * Decodes a TotalOrderCreateMessage message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof TotalOrderCreateMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {TotalOrderCreateMessage} TotalOrderCreateMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TotalOrderCreateMessage.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a TotalOrderCreateMessage message.\n     * @function verify\n     * @memberof TotalOrderCreateMessage\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    TotalOrderCreateMessage.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.parentWaypointSenderID != null && message.hasOwnProperty(\"parentWaypointSenderID\"))\n            if (!$util.isString(message.parentWaypointSenderID))\n                return \"parentWaypointSenderID: string expected\";\n        if (!$util.isInteger(message.parentWaypointCounterAndSide))\n            return \"parentWaypointCounterAndSide: integer expected\";\n        if (!$util.isInteger(message.parentValueIndex))\n            return \"parentValueIndex: integer expected\";\n        return null;\n    };\n\n    /**\n     * Creates a TotalOrderCreateMessage message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof TotalOrderCreateMessage\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {TotalOrderCreateMessage} TotalOrderCreateMessage\n     */\n    TotalOrderCreateMessage.fromObject = function fromObject(object) {\n        if (object instanceof TotalOrderCreateMessage)\n            return object;\n        let message = new TotalOrderCreateMessage();\n        if (object.parentWaypointSenderID != null)\n            message.parentWaypointSenderID = String(object.parentWaypointSenderID);\n        if (object.parentWaypointCounterAndSide != null)\n            message.parentWaypointCounterAndSide = object.parentWaypointCounterAndSide | 0;\n        if (object.parentValueIndex != null)\n            message.parentValueIndex = object.parentValueIndex >>> 0;\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a TotalOrderCreateMessage message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof TotalOrderCreateMessage\n     * @static\n     * @param {TotalOrderCreateMessage} message TotalOrderCreateMessage\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    TotalOrderCreateMessage.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.defaults) {\n            object.parentWaypointSenderID = \"\";\n            object.parentWaypointCounterAndSide = 0;\n            object.parentValueIndex = 0;\n        }\n        if (message.parentWaypointSenderID != null && message.hasOwnProperty(\"parentWaypointSenderID\"))\n            object.parentWaypointSenderID = message.parentWaypointSenderID;\n        if (message.parentWaypointCounterAndSide != null && message.hasOwnProperty(\"parentWaypointCounterAndSide\"))\n            object.parentWaypointCounterAndSide = message.parentWaypointCounterAndSide;\n        if (message.parentValueIndex != null && message.hasOwnProperty(\"parentValueIndex\"))\n            object.parentValueIndex = message.parentValueIndex;\n        return object;\n    };\n\n    /**\n     * Converts this TotalOrderCreateMessage to JSON.\n     * @function toJSON\n     * @memberof TotalOrderCreateMessage\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    TotalOrderCreateMessage.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return TotalOrderCreateMessage;\n})();\n\nexport const TotalOrderSave = /*@__PURE__*/ (() => {\n\n    /**\n     * Properties of a TotalOrderSave.\n     * @exports ITotalOrderSave\n     * @interface ITotalOrderSave\n     * @property {Array.<string>|null} [replicaIDs] TotalOrderSave replicaIDs\n     * @property {Array.<number>|null} [replicaCounts] TotalOrderSave replicaCounts\n     * @property {Array.<number>|null} [parentWaypoints] TotalOrderSave parentWaypoints\n     * @property {Array.<number>|null} [parentValueIndexAndSides] TotalOrderSave parentValueIndexAndSides\n     */\n\n    /**\n     * Constructs a new TotalOrderSave.\n     * @exports TotalOrderSave\n     * @classdesc Represents a TotalOrderSave.\n     * @implements ITotalOrderSave\n     * @constructor\n     * @param {ITotalOrderSave=} [properties] Properties to set\n     */\n    function TotalOrderSave(properties) {\n        this.replicaIDs = [];\n        this.replicaCounts = [];\n        this.parentWaypoints = [];\n        this.parentValueIndexAndSides = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * TotalOrderSave replicaIDs.\n     * @member {Array.<string>} replicaIDs\n     * @memberof TotalOrderSave\n     * @instance\n     */\n    TotalOrderSave.prototype.replicaIDs = $util.emptyArray;\n\n    /**\n     * TotalOrderSave replicaCounts.\n     * @member {Array.<number>} replicaCounts\n     * @memberof TotalOrderSave\n     * @instance\n     */\n    TotalOrderSave.prototype.replicaCounts = $util.emptyArray;\n\n    /**\n     * TotalOrderSave parentWaypoints.\n     * @member {Array.<number>} parentWaypoints\n     * @memberof TotalOrderSave\n     * @instance\n     */\n    TotalOrderSave.prototype.parentWaypoints = $util.emptyArray;\n\n    /**\n     * TotalOrderSave parentValueIndexAndSides.\n     * @member {Array.<number>} parentValueIndexAndSides\n     * @memberof TotalOrderSave\n     * @instance\n     */\n    TotalOrderSave.prototype.parentValueIndexAndSides = $util.emptyArray;\n\n    /**\n     * Creates a new TotalOrderSave instance using the specified properties.\n     * @function create\n     * @memberof TotalOrderSave\n     * @static\n     * @param {ITotalOrderSave=} [properties] Properties to set\n     * @returns {TotalOrderSave} TotalOrderSave instance\n     */\n    TotalOrderSave.create = function create(properties) {\n        return new TotalOrderSave(properties);\n    };\n\n    /**\n     * Encodes the specified TotalOrderSave message. Does not implicitly {@link TotalOrderSave.verify|verify} messages.\n     * @function encode\n     * @memberof TotalOrderSave\n     * @static\n     * @param {ITotalOrderSave} message TotalOrderSave message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TotalOrderSave.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.replicaIDs != null && message.replicaIDs.length)\n            for (let i = 0; i < message.replicaIDs.length; ++i)\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.replicaIDs[i]);\n        if (message.replicaCounts != null && message.replicaCounts.length) {\n            writer.uint32(/* id 2, wireType 2 =*/18).fork();\n            for (let i = 0; i < message.replicaCounts.length; ++i)\n                writer.uint32(message.replicaCounts[i]);\n            writer.ldelim();\n        }\n        if (message.parentWaypoints != null && message.parentWaypoints.length) {\n            writer.uint32(/* id 3, wireType 2 =*/26).fork();\n            for (let i = 0; i < message.parentWaypoints.length; ++i)\n                writer.uint32(message.parentWaypoints[i]);\n            writer.ldelim();\n        }\n        if (message.parentValueIndexAndSides != null && message.parentValueIndexAndSides.length) {\n            writer.uint32(/* id 4, wireType 2 =*/34).fork();\n            for (let i = 0; i < message.parentValueIndexAndSides.length; ++i)\n                writer.sint32(message.parentValueIndexAndSides[i]);\n            writer.ldelim();\n        }\n        return writer;\n    };\n\n    /**\n     * Encodes the specified TotalOrderSave message, length delimited. Does not implicitly {@link TotalOrderSave.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof TotalOrderSave\n     * @static\n     * @param {ITotalOrderSave} message TotalOrderSave message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TotalOrderSave.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a TotalOrderSave message from the specified reader or buffer.\n     * @function decode\n     * @memberof TotalOrderSave\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {TotalOrderSave} TotalOrderSave\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TotalOrderSave.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new TotalOrderSave();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                if (!(message.replicaIDs && message.replicaIDs.length))\n                    message.replicaIDs = [];\n                message.replicaIDs.push(reader.string());\n                break;\n            case 2:\n                if (!(message.replicaCounts && message.replicaCounts.length))\n                    message.replicaCounts = [];\n                if ((tag & 7) === 2) {\n                    let end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.replicaCounts.push(reader.uint32());\n                } else\n                    message.replicaCounts.push(reader.uint32());\n                break;\n            case 3:\n                if (!(message.parentWaypoints && message.parentWaypoints.length))\n                    message.parentWaypoints = [];\n                if ((tag & 7) === 2) {\n                    let end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.parentWaypoints.push(reader.uint32());\n                } else\n                    message.parentWaypoints.push(reader.uint32());\n                break;\n            case 4:\n                if (!(message.parentValueIndexAndSides && message.parentValueIndexAndSides.length))\n                    message.parentValueIndexAndSides = [];\n                if ((tag & 7) === 2) {\n                    let end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.parentValueIndexAndSides.push(reader.sint32());\n                } else\n                    message.parentValueIndexAndSides.push(reader.sint32());\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a TotalOrderSave message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof TotalOrderSave\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {TotalOrderSave} TotalOrderSave\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TotalOrderSave.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a TotalOrderSave message.\n     * @function verify\n     * @memberof TotalOrderSave\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    TotalOrderSave.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.replicaIDs != null && message.hasOwnProperty(\"replicaIDs\")) {\n            if (!Array.isArray(message.replicaIDs))\n                return \"replicaIDs: array expected\";\n            for (let i = 0; i < message.replicaIDs.length; ++i)\n                if (!$util.isString(message.replicaIDs[i]))\n                    return \"replicaIDs: string[] expected\";\n        }\n        if (message.replicaCounts != null && message.hasOwnProperty(\"replicaCounts\")) {\n            if (!Array.isArray(message.replicaCounts))\n                return \"replicaCounts: array expected\";\n            for (let i = 0; i < message.replicaCounts.length; ++i)\n                if (!$util.isInteger(message.replicaCounts[i]))\n                    return \"replicaCounts: integer[] expected\";\n        }\n        if (message.parentWaypoints != null && message.hasOwnProperty(\"parentWaypoints\")) {\n            if (!Array.isArray(message.parentWaypoints))\n                return \"parentWaypoints: array expected\";\n            for (let i = 0; i < message.parentWaypoints.length; ++i)\n                if (!$util.isInteger(message.parentWaypoints[i]))\n                    return \"parentWaypoints: integer[] expected\";\n        }\n        if (message.parentValueIndexAndSides != null && message.hasOwnProperty(\"parentValueIndexAndSides\")) {\n            if (!Array.isArray(message.parentValueIndexAndSides))\n                return \"parentValueIndexAndSides: array expected\";\n            for (let i = 0; i < message.parentValueIndexAndSides.length; ++i)\n                if (!$util.isInteger(message.parentValueIndexAndSides[i]))\n                    return \"parentValueIndexAndSides: integer[] expected\";\n        }\n        return null;\n    };\n\n    /**\n     * Creates a TotalOrderSave message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof TotalOrderSave\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {TotalOrderSave} TotalOrderSave\n     */\n    TotalOrderSave.fromObject = function fromObject(object) {\n        if (object instanceof TotalOrderSave)\n            return object;\n        let message = new TotalOrderSave();\n        if (object.replicaIDs) {\n            if (!Array.isArray(object.replicaIDs))\n                throw TypeError(\".TotalOrderSave.replicaIDs: array expected\");\n            message.replicaIDs = [];\n            for (let i = 0; i < object.replicaIDs.length; ++i)\n                message.replicaIDs[i] = String(object.replicaIDs[i]);\n        }\n        if (object.replicaCounts) {\n            if (!Array.isArray(object.replicaCounts))\n                throw TypeError(\".TotalOrderSave.replicaCounts: array expected\");\n            message.replicaCounts = [];\n            for (let i = 0; i < object.replicaCounts.length; ++i)\n                message.replicaCounts[i] = object.replicaCounts[i] >>> 0;\n        }\n        if (object.parentWaypoints) {\n            if (!Array.isArray(object.parentWaypoints))\n                throw TypeError(\".TotalOrderSave.parentWaypoints: array expected\");\n            message.parentWaypoints = [];\n            for (let i = 0; i < object.parentWaypoints.length; ++i)\n                message.parentWaypoints[i] = object.parentWaypoints[i] >>> 0;\n        }\n        if (object.parentValueIndexAndSides) {\n            if (!Array.isArray(object.parentValueIndexAndSides))\n                throw TypeError(\".TotalOrderSave.parentValueIndexAndSides: array expected\");\n            message.parentValueIndexAndSides = [];\n            for (let i = 0; i < object.parentValueIndexAndSides.length; ++i)\n                message.parentValueIndexAndSides[i] = object.parentValueIndexAndSides[i] | 0;\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a TotalOrderSave message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof TotalOrderSave\n     * @static\n     * @param {TotalOrderSave} message TotalOrderSave\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    TotalOrderSave.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults) {\n            object.replicaIDs = [];\n            object.replicaCounts = [];\n            object.parentWaypoints = [];\n            object.parentValueIndexAndSides = [];\n        }\n        if (message.replicaIDs && message.replicaIDs.length) {\n            object.replicaIDs = [];\n            for (let j = 0; j < message.replicaIDs.length; ++j)\n                object.replicaIDs[j] = message.replicaIDs[j];\n        }\n        if (message.replicaCounts && message.replicaCounts.length) {\n            object.replicaCounts = [];\n            for (let j = 0; j < message.replicaCounts.length; ++j)\n                object.replicaCounts[j] = message.replicaCounts[j];\n        }\n        if (message.parentWaypoints && message.parentWaypoints.length) {\n            object.parentWaypoints = [];\n            for (let j = 0; j < message.parentWaypoints.length; ++j)\n                object.parentWaypoints[j] = message.parentWaypoints[j];\n        }\n        if (message.parentValueIndexAndSides && message.parentValueIndexAndSides.length) {\n            object.parentValueIndexAndSides = [];\n            for (let j = 0; j < message.parentValueIndexAndSides.length; ++j)\n                object.parentValueIndexAndSides[j] = message.parentValueIndexAndSides[j];\n        }\n        return object;\n    };\n\n    /**\n     * Converts this TotalOrderSave to JSON.\n     * @function toJSON\n     * @memberof TotalOrderSave\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    TotalOrderSave.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return TotalOrderSave;\n})();\n\nexport const LocalListSave = /*@__PURE__*/ (() => {\n\n    /**\n     * Properties of a LocalListSave.\n     * @exports ILocalListSave\n     * @interface ILocalListSave\n     * @property {Array.<string>|null} [replicaIDs] LocalListSave replicaIDs\n     * @property {Array.<number>|null} [replicaIDIndices] LocalListSave replicaIDIndices\n     * @property {Array.<number>|null} [counters] LocalListSave counters\n     * @property {Array.<number>|null} [totals] LocalListSave totals\n     * @property {Array.<number>|null} [seens] LocalListSave seens\n     * @property {Array.<number>|null} [itemsLengths] LocalListSave itemsLengths\n     * @property {Array.<number>|null} [itemSizes] LocalListSave itemSizes\n     * @property {Uint8Array} values LocalListSave values\n     */\n\n    /**\n     * Constructs a new LocalListSave.\n     * @exports LocalListSave\n     * @classdesc Represents a LocalListSave.\n     * @implements ILocalListSave\n     * @constructor\n     * @param {ILocalListSave=} [properties] Properties to set\n     */\n    function LocalListSave(properties) {\n        this.replicaIDs = [];\n        this.replicaIDIndices = [];\n        this.counters = [];\n        this.totals = [];\n        this.seens = [];\n        this.itemsLengths = [];\n        this.itemSizes = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * LocalListSave replicaIDs.\n     * @member {Array.<string>} replicaIDs\n     * @memberof LocalListSave\n     * @instance\n     */\n    LocalListSave.prototype.replicaIDs = $util.emptyArray;\n\n    /**\n     * LocalListSave replicaIDIndices.\n     * @member {Array.<number>} replicaIDIndices\n     * @memberof LocalListSave\n     * @instance\n     */\n    LocalListSave.prototype.replicaIDIndices = $util.emptyArray;\n\n    /**\n     * LocalListSave counters.\n     * @member {Array.<number>} counters\n     * @memberof LocalListSave\n     * @instance\n     */\n    LocalListSave.prototype.counters = $util.emptyArray;\n\n    /**\n     * LocalListSave totals.\n     * @member {Array.<number>} totals\n     * @memberof LocalListSave\n     * @instance\n     */\n    LocalListSave.prototype.totals = $util.emptyArray;\n\n    /**\n     * LocalListSave seens.\n     * @member {Array.<number>} seens\n     * @memberof LocalListSave\n     * @instance\n     */\n    LocalListSave.prototype.seens = $util.emptyArray;\n\n    /**\n     * LocalListSave itemsLengths.\n     * @member {Array.<number>} itemsLengths\n     * @memberof LocalListSave\n     * @instance\n     */\n    LocalListSave.prototype.itemsLengths = $util.emptyArray;\n\n    /**\n     * LocalListSave itemSizes.\n     * @member {Array.<number>} itemSizes\n     * @memberof LocalListSave\n     * @instance\n     */\n    LocalListSave.prototype.itemSizes = $util.emptyArray;\n\n    /**\n     * LocalListSave values.\n     * @member {Uint8Array} values\n     * @memberof LocalListSave\n     * @instance\n     */\n    LocalListSave.prototype.values = $util.newBuffer([]);\n\n    /**\n     * Creates a new LocalListSave instance using the specified properties.\n     * @function create\n     * @memberof LocalListSave\n     * @static\n     * @param {ILocalListSave=} [properties] Properties to set\n     * @returns {LocalListSave} LocalListSave instance\n     */\n    LocalListSave.create = function create(properties) {\n        return new LocalListSave(properties);\n    };\n\n    /**\n     * Encodes the specified LocalListSave message. Does not implicitly {@link LocalListSave.verify|verify} messages.\n     * @function encode\n     * @memberof LocalListSave\n     * @static\n     * @param {ILocalListSave} message LocalListSave message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    LocalListSave.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.replicaIDs != null && message.replicaIDs.length)\n            for (let i = 0; i < message.replicaIDs.length; ++i)\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.replicaIDs[i]);\n        if (message.replicaIDIndices != null && message.replicaIDIndices.length) {\n            writer.uint32(/* id 2, wireType 2 =*/18).fork();\n            for (let i = 0; i < message.replicaIDIndices.length; ++i)\n                writer.uint32(message.replicaIDIndices[i]);\n            writer.ldelim();\n        }\n        if (message.counters != null && message.counters.length) {\n            writer.uint32(/* id 3, wireType 2 =*/26).fork();\n            for (let i = 0; i < message.counters.length; ++i)\n                writer.uint32(message.counters[i]);\n            writer.ldelim();\n        }\n        if (message.totals != null && message.totals.length) {\n            writer.uint32(/* id 4, wireType 2 =*/34).fork();\n            for (let i = 0; i < message.totals.length; ++i)\n                writer.uint32(message.totals[i]);\n            writer.ldelim();\n        }\n        if (message.seens != null && message.seens.length) {\n            writer.uint32(/* id 5, wireType 2 =*/42).fork();\n            for (let i = 0; i < message.seens.length; ++i)\n                writer.uint32(message.seens[i]);\n            writer.ldelim();\n        }\n        if (message.itemsLengths != null && message.itemsLengths.length) {\n            writer.uint32(/* id 6, wireType 2 =*/50).fork();\n            for (let i = 0; i < message.itemsLengths.length; ++i)\n                writer.uint32(message.itemsLengths[i]);\n            writer.ldelim();\n        }\n        if (message.itemSizes != null && message.itemSizes.length) {\n            writer.uint32(/* id 7, wireType 2 =*/58).fork();\n            for (let i = 0; i < message.itemSizes.length; ++i)\n                writer.sint32(message.itemSizes[i]);\n            writer.ldelim();\n        }\n        writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.values);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified LocalListSave message, length delimited. Does not implicitly {@link LocalListSave.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof LocalListSave\n     * @static\n     * @param {ILocalListSave} message LocalListSave message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    LocalListSave.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a LocalListSave message from the specified reader or buffer.\n     * @function decode\n     * @memberof LocalListSave\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {LocalListSave} LocalListSave\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    LocalListSave.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new LocalListSave();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                if (!(message.replicaIDs && message.replicaIDs.length))\n                    message.replicaIDs = [];\n                message.replicaIDs.push(reader.string());\n                break;\n            case 2:\n                if (!(message.replicaIDIndices && message.replicaIDIndices.length))\n                    message.replicaIDIndices = [];\n                if ((tag & 7) === 2) {\n                    let end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.replicaIDIndices.push(reader.uint32());\n                } else\n                    message.replicaIDIndices.push(reader.uint32());\n                break;\n            case 3:\n                if (!(message.counters && message.counters.length))\n                    message.counters = [];\n                if ((tag & 7) === 2) {\n                    let end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.counters.push(reader.uint32());\n                } else\n                    message.counters.push(reader.uint32());\n                break;\n            case 4:\n                if (!(message.totals && message.totals.length))\n                    message.totals = [];\n                if ((tag & 7) === 2) {\n                    let end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.totals.push(reader.uint32());\n                } else\n                    message.totals.push(reader.uint32());\n                break;\n            case 5:\n                if (!(message.seens && message.seens.length))\n                    message.seens = [];\n                if ((tag & 7) === 2) {\n                    let end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.seens.push(reader.uint32());\n                } else\n                    message.seens.push(reader.uint32());\n                break;\n            case 6:\n                if (!(message.itemsLengths && message.itemsLengths.length))\n                    message.itemsLengths = [];\n                if ((tag & 7) === 2) {\n                    let end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.itemsLengths.push(reader.uint32());\n                } else\n                    message.itemsLengths.push(reader.uint32());\n                break;\n            case 7:\n                if (!(message.itemSizes && message.itemSizes.length))\n                    message.itemSizes = [];\n                if ((tag & 7) === 2) {\n                    let end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.itemSizes.push(reader.sint32());\n                } else\n                    message.itemSizes.push(reader.sint32());\n                break;\n            case 8:\n                message.values = reader.bytes();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        if (!message.hasOwnProperty(\"values\"))\n            throw $util.ProtocolError(\"missing required 'values'\", { instance: message });\n        return message;\n    };\n\n    /**\n     * Decodes a LocalListSave message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof LocalListSave\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {LocalListSave} LocalListSave\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    LocalListSave.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a LocalListSave message.\n     * @function verify\n     * @memberof LocalListSave\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    LocalListSave.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.replicaIDs != null && message.hasOwnProperty(\"replicaIDs\")) {\n            if (!Array.isArray(message.replicaIDs))\n                return \"replicaIDs: array expected\";\n            for (let i = 0; i < message.replicaIDs.length; ++i)\n                if (!$util.isString(message.replicaIDs[i]))\n                    return \"replicaIDs: string[] expected\";\n        }\n        if (message.replicaIDIndices != null && message.hasOwnProperty(\"replicaIDIndices\")) {\n            if (!Array.isArray(message.replicaIDIndices))\n                return \"replicaIDIndices: array expected\";\n            for (let i = 0; i < message.replicaIDIndices.length; ++i)\n                if (!$util.isInteger(message.replicaIDIndices[i]))\n                    return \"replicaIDIndices: integer[] expected\";\n        }\n        if (message.counters != null && message.hasOwnProperty(\"counters\")) {\n            if (!Array.isArray(message.counters))\n                return \"counters: array expected\";\n            for (let i = 0; i < message.counters.length; ++i)\n                if (!$util.isInteger(message.counters[i]))\n                    return \"counters: integer[] expected\";\n        }\n        if (message.totals != null && message.hasOwnProperty(\"totals\")) {\n            if (!Array.isArray(message.totals))\n                return \"totals: array expected\";\n            for (let i = 0; i < message.totals.length; ++i)\n                if (!$util.isInteger(message.totals[i]))\n                    return \"totals: integer[] expected\";\n        }\n        if (message.seens != null && message.hasOwnProperty(\"seens\")) {\n            if (!Array.isArray(message.seens))\n                return \"seens: array expected\";\n            for (let i = 0; i < message.seens.length; ++i)\n                if (!$util.isInteger(message.seens[i]))\n                    return \"seens: integer[] expected\";\n        }\n        if (message.itemsLengths != null && message.hasOwnProperty(\"itemsLengths\")) {\n            if (!Array.isArray(message.itemsLengths))\n                return \"itemsLengths: array expected\";\n            for (let i = 0; i < message.itemsLengths.length; ++i)\n                if (!$util.isInteger(message.itemsLengths[i]))\n                    return \"itemsLengths: integer[] expected\";\n        }\n        if (message.itemSizes != null && message.hasOwnProperty(\"itemSizes\")) {\n            if (!Array.isArray(message.itemSizes))\n                return \"itemSizes: array expected\";\n            for (let i = 0; i < message.itemSizes.length; ++i)\n                if (!$util.isInteger(message.itemSizes[i]))\n                    return \"itemSizes: integer[] expected\";\n        }\n        if (!(message.values && typeof message.values.length === \"number\" || $util.isString(message.values)))\n            return \"values: buffer expected\";\n        return null;\n    };\n\n    /**\n     * Creates a LocalListSave message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof LocalListSave\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {LocalListSave} LocalListSave\n     */\n    LocalListSave.fromObject = function fromObject(object) {\n        if (object instanceof LocalListSave)\n            return object;\n        let message = new LocalListSave();\n        if (object.replicaIDs) {\n            if (!Array.isArray(object.replicaIDs))\n                throw TypeError(\".LocalListSave.replicaIDs: array expected\");\n            message.replicaIDs = [];\n            for (let i = 0; i < object.replicaIDs.length; ++i)\n                message.replicaIDs[i] = String(object.replicaIDs[i]);\n        }\n        if (object.replicaIDIndices) {\n            if (!Array.isArray(object.replicaIDIndices))\n                throw TypeError(\".LocalListSave.replicaIDIndices: array expected\");\n            message.replicaIDIndices = [];\n            for (let i = 0; i < object.replicaIDIndices.length; ++i)\n                message.replicaIDIndices[i] = object.replicaIDIndices[i] >>> 0;\n        }\n        if (object.counters) {\n            if (!Array.isArray(object.counters))\n                throw TypeError(\".LocalListSave.counters: array expected\");\n            message.counters = [];\n            for (let i = 0; i < object.counters.length; ++i)\n                message.counters[i] = object.counters[i] >>> 0;\n        }\n        if (object.totals) {\n            if (!Array.isArray(object.totals))\n                throw TypeError(\".LocalListSave.totals: array expected\");\n            message.totals = [];\n            for (let i = 0; i < object.totals.length; ++i)\n                message.totals[i] = object.totals[i] >>> 0;\n        }\n        if (object.seens) {\n            if (!Array.isArray(object.seens))\n                throw TypeError(\".LocalListSave.seens: array expected\");\n            message.seens = [];\n            for (let i = 0; i < object.seens.length; ++i)\n                message.seens[i] = object.seens[i] >>> 0;\n        }\n        if (object.itemsLengths) {\n            if (!Array.isArray(object.itemsLengths))\n                throw TypeError(\".LocalListSave.itemsLengths: array expected\");\n            message.itemsLengths = [];\n            for (let i = 0; i < object.itemsLengths.length; ++i)\n                message.itemsLengths[i] = object.itemsLengths[i] >>> 0;\n        }\n        if (object.itemSizes) {\n            if (!Array.isArray(object.itemSizes))\n                throw TypeError(\".LocalListSave.itemSizes: array expected\");\n            message.itemSizes = [];\n            for (let i = 0; i < object.itemSizes.length; ++i)\n                message.itemSizes[i] = object.itemSizes[i] | 0;\n        }\n        if (object.values != null)\n            if (typeof object.values === \"string\")\n                $util.base64.decode(object.values, message.values = $util.newBuffer($util.base64.length(object.values)), 0);\n            else if (object.values.length)\n                message.values = object.values;\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a LocalListSave message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof LocalListSave\n     * @static\n     * @param {LocalListSave} message LocalListSave\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    LocalListSave.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults) {\n            object.replicaIDs = [];\n            object.replicaIDIndices = [];\n            object.counters = [];\n            object.totals = [];\n            object.seens = [];\n            object.itemsLengths = [];\n            object.itemSizes = [];\n        }\n        if (options.defaults)\n            if (options.bytes === String)\n                object.values = \"\";\n            else {\n                object.values = [];\n                if (options.bytes !== Array)\n                    object.values = $util.newBuffer(object.values);\n            }\n        if (message.replicaIDs && message.replicaIDs.length) {\n            object.replicaIDs = [];\n            for (let j = 0; j < message.replicaIDs.length; ++j)\n                object.replicaIDs[j] = message.replicaIDs[j];\n        }\n        if (message.replicaIDIndices && message.replicaIDIndices.length) {\n            object.replicaIDIndices = [];\n            for (let j = 0; j < message.replicaIDIndices.length; ++j)\n                object.replicaIDIndices[j] = message.replicaIDIndices[j];\n        }\n        if (message.counters && message.counters.length) {\n            object.counters = [];\n            for (let j = 0; j < message.counters.length; ++j)\n                object.counters[j] = message.counters[j];\n        }\n        if (message.totals && message.totals.length) {\n            object.totals = [];\n            for (let j = 0; j < message.totals.length; ++j)\n                object.totals[j] = message.totals[j];\n        }\n        if (message.seens && message.seens.length) {\n            object.seens = [];\n            for (let j = 0; j < message.seens.length; ++j)\n                object.seens[j] = message.seens[j];\n        }\n        if (message.itemsLengths && message.itemsLengths.length) {\n            object.itemsLengths = [];\n            for (let j = 0; j < message.itemsLengths.length; ++j)\n                object.itemsLengths[j] = message.itemsLengths[j];\n        }\n        if (message.itemSizes && message.itemSizes.length) {\n            object.itemSizes = [];\n            for (let j = 0; j < message.itemSizes.length; ++j)\n                object.itemSizes[j] = message.itemSizes[j];\n        }\n        if (message.values != null && message.hasOwnProperty(\"values\"))\n            object.values = options.bytes === String ? $util.base64.encode(message.values, 0, message.values.length) : options.bytes === Array ? Array.prototype.slice.call(message.values) : message.values;\n        return object;\n    };\n\n    /**\n     * Converts this LocalListSave to JSON.\n     * @function toJSON\n     * @memberof LocalListSave\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    LocalListSave.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return LocalListSave;\n})();\n\nexport const SpanLogPartialSpanMessage = /*@__PURE__*/ (() => {\n\n    /**\n     * Properties of a SpanLogPartialSpanMessage.\n     * @exports ISpanLogPartialSpanMessage\n     * @interface ISpanLogPartialSpanMessage\n     * @property {string} key SpanLogPartialSpanMessage key\n     * @property {Uint8Array|null} [value] SpanLogPartialSpanMessage value\n     * @property {string} startPosition SpanLogPartialSpanMessage startPosition\n     * @property {string|null} [endPosition] SpanLogPartialSpanMessage endPosition\n     * @property {boolean|null} [endClosed] SpanLogPartialSpanMessage endClosed\n     */\n\n    /**\n     * Constructs a new SpanLogPartialSpanMessage.\n     * @exports SpanLogPartialSpanMessage\n     * @classdesc Represents a SpanLogPartialSpanMessage.\n     * @implements ISpanLogPartialSpanMessage\n     * @constructor\n     * @param {ISpanLogPartialSpanMessage=} [properties] Properties to set\n     */\n    function SpanLogPartialSpanMessage(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * SpanLogPartialSpanMessage key.\n     * @member {string} key\n     * @memberof SpanLogPartialSpanMessage\n     * @instance\n     */\n    SpanLogPartialSpanMessage.prototype.key = \"\";\n\n    /**\n     * SpanLogPartialSpanMessage value.\n     * @member {Uint8Array} value\n     * @memberof SpanLogPartialSpanMessage\n     * @instance\n     */\n    SpanLogPartialSpanMessage.prototype.value = $util.newBuffer([]);\n\n    /**\n     * SpanLogPartialSpanMessage startPosition.\n     * @member {string} startPosition\n     * @memberof SpanLogPartialSpanMessage\n     * @instance\n     */\n    SpanLogPartialSpanMessage.prototype.startPosition = \"\";\n\n    /**\n     * SpanLogPartialSpanMessage endPosition.\n     * @member {string} endPosition\n     * @memberof SpanLogPartialSpanMessage\n     * @instance\n     */\n    SpanLogPartialSpanMessage.prototype.endPosition = \"\";\n\n    /**\n     * SpanLogPartialSpanMessage endClosed.\n     * @member {boolean} endClosed\n     * @memberof SpanLogPartialSpanMessage\n     * @instance\n     */\n    SpanLogPartialSpanMessage.prototype.endClosed = false;\n\n    /**\n     * Creates a new SpanLogPartialSpanMessage instance using the specified properties.\n     * @function create\n     * @memberof SpanLogPartialSpanMessage\n     * @static\n     * @param {ISpanLogPartialSpanMessage=} [properties] Properties to set\n     * @returns {SpanLogPartialSpanMessage} SpanLogPartialSpanMessage instance\n     */\n    SpanLogPartialSpanMessage.create = function create(properties) {\n        return new SpanLogPartialSpanMessage(properties);\n    };\n\n    /**\n     * Encodes the specified SpanLogPartialSpanMessage message. Does not implicitly {@link SpanLogPartialSpanMessage.verify|verify} messages.\n     * @function encode\n     * @memberof SpanLogPartialSpanMessage\n     * @static\n     * @param {ISpanLogPartialSpanMessage} message SpanLogPartialSpanMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    SpanLogPartialSpanMessage.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);\n        if (message.value != null && Object.hasOwnProperty.call(message, \"value\"))\n            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);\n        writer.uint32(/* id 3, wireType 2 =*/26).string(message.startPosition);\n        if (message.endPosition != null && Object.hasOwnProperty.call(message, \"endPosition\"))\n            writer.uint32(/* id 4, wireType 2 =*/34).string(message.endPosition);\n        if (message.endClosed != null && Object.hasOwnProperty.call(message, \"endClosed\"))\n            writer.uint32(/* id 5, wireType 0 =*/40).bool(message.endClosed);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified SpanLogPartialSpanMessage message, length delimited. Does not implicitly {@link SpanLogPartialSpanMessage.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof SpanLogPartialSpanMessage\n     * @static\n     * @param {ISpanLogPartialSpanMessage} message SpanLogPartialSpanMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    SpanLogPartialSpanMessage.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a SpanLogPartialSpanMessage message from the specified reader or buffer.\n     * @function decode\n     * @memberof SpanLogPartialSpanMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {SpanLogPartialSpanMessage} SpanLogPartialSpanMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    SpanLogPartialSpanMessage.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new SpanLogPartialSpanMessage();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.key = reader.string();\n                break;\n            case 2:\n                message.value = reader.bytes();\n                break;\n            case 3:\n                message.startPosition = reader.string();\n                break;\n            case 4:\n                message.endPosition = reader.string();\n                break;\n            case 5:\n                message.endClosed = reader.bool();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        if (!message.hasOwnProperty(\"key\"))\n            throw $util.ProtocolError(\"missing required 'key'\", { instance: message });\n        if (!message.hasOwnProperty(\"startPosition\"))\n            throw $util.ProtocolError(\"missing required 'startPosition'\", { instance: message });\n        return message;\n    };\n\n    /**\n     * Decodes a SpanLogPartialSpanMessage message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof SpanLogPartialSpanMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {SpanLogPartialSpanMessage} SpanLogPartialSpanMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    SpanLogPartialSpanMessage.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a SpanLogPartialSpanMessage message.\n     * @function verify\n     * @memberof SpanLogPartialSpanMessage\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    SpanLogPartialSpanMessage.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (!$util.isString(message.key))\n            return \"key: string expected\";\n        if (message.value != null && message.hasOwnProperty(\"value\"))\n            if (!(message.value && typeof message.value.length === \"number\" || $util.isString(message.value)))\n                return \"value: buffer expected\";\n        if (!$util.isString(message.startPosition))\n            return \"startPosition: string expected\";\n        if (message.endPosition != null && message.hasOwnProperty(\"endPosition\"))\n            if (!$util.isString(message.endPosition))\n                return \"endPosition: string expected\";\n        if (message.endClosed != null && message.hasOwnProperty(\"endClosed\"))\n            if (typeof message.endClosed !== \"boolean\")\n                return \"endClosed: boolean expected\";\n        return null;\n    };\n\n    /**\n     * Creates a SpanLogPartialSpanMessage message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof SpanLogPartialSpanMessage\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {SpanLogPartialSpanMessage} SpanLogPartialSpanMessage\n     */\n    SpanLogPartialSpanMessage.fromObject = function fromObject(object) {\n        if (object instanceof SpanLogPartialSpanMessage)\n            return object;\n        let message = new SpanLogPartialSpanMessage();\n        if (object.key != null)\n            message.key = String(object.key);\n        if (object.value != null)\n            if (typeof object.value === \"string\")\n                $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);\n            else if (object.value.length)\n                message.value = object.value;\n        if (object.startPosition != null)\n            message.startPosition = String(object.startPosition);\n        if (object.endPosition != null)\n            message.endPosition = String(object.endPosition);\n        if (object.endClosed != null)\n            message.endClosed = Boolean(object.endClosed);\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a SpanLogPartialSpanMessage message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof SpanLogPartialSpanMessage\n     * @static\n     * @param {SpanLogPartialSpanMessage} message SpanLogPartialSpanMessage\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    SpanLogPartialSpanMessage.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.defaults) {\n            object.key = \"\";\n            if (options.bytes === String)\n                object.value = \"\";\n            else {\n                object.value = [];\n                if (options.bytes !== Array)\n                    object.value = $util.newBuffer(object.value);\n            }\n            object.startPosition = \"\";\n            object.endPosition = \"\";\n            object.endClosed = false;\n        }\n        if (message.key != null && message.hasOwnProperty(\"key\"))\n            object.key = message.key;\n        if (message.value != null && message.hasOwnProperty(\"value\"))\n            object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;\n        if (message.startPosition != null && message.hasOwnProperty(\"startPosition\"))\n            object.startPosition = message.startPosition;\n        if (message.endPosition != null && message.hasOwnProperty(\"endPosition\"))\n            object.endPosition = message.endPosition;\n        if (message.endClosed != null && message.hasOwnProperty(\"endClosed\"))\n            object.endClosed = message.endClosed;\n        return object;\n    };\n\n    /**\n     * Converts this SpanLogPartialSpanMessage to JSON.\n     * @function toJSON\n     * @memberof SpanLogPartialSpanMessage\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    SpanLogPartialSpanMessage.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return SpanLogPartialSpanMessage;\n})();\n\nexport const SpanLogSaveMessage = /*@__PURE__*/ (() => {\n\n    /**\n     * Properties of a SpanLogSaveMessage.\n     * @exports ISpanLogSaveMessage\n     * @interface ISpanLogSaveMessage\n     * @property {Array.<string>|null} [senderIDs] SpanLogSaveMessage senderIDs\n     * @property {Array.<number>|null} [lengths] SpanLogSaveMessage lengths\n     * @property {Array.<Uint8Array>|null} [spans] SpanLogSaveMessage spans\n     * @property {Array.<number|Long>|null} [lamports] SpanLogSaveMessage lamports\n     */\n\n    /**\n     * Constructs a new SpanLogSaveMessage.\n     * @exports SpanLogSaveMessage\n     * @classdesc Represents a SpanLogSaveMessage.\n     * @implements ISpanLogSaveMessage\n     * @constructor\n     * @param {ISpanLogSaveMessage=} [properties] Properties to set\n     */\n    function SpanLogSaveMessage(properties) {\n        this.senderIDs = [];\n        this.lengths = [];\n        this.spans = [];\n        this.lamports = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * SpanLogSaveMessage senderIDs.\n     * @member {Array.<string>} senderIDs\n     * @memberof SpanLogSaveMessage\n     * @instance\n     */\n    SpanLogSaveMessage.prototype.senderIDs = $util.emptyArray;\n\n    /**\n     * SpanLogSaveMessage lengths.\n     * @member {Array.<number>} lengths\n     * @memberof SpanLogSaveMessage\n     * @instance\n     */\n    SpanLogSaveMessage.prototype.lengths = $util.emptyArray;\n\n    /**\n     * SpanLogSaveMessage spans.\n     * @member {Array.<Uint8Array>} spans\n     * @memberof SpanLogSaveMessage\n     * @instance\n     */\n    SpanLogSaveMessage.prototype.spans = $util.emptyArray;\n\n    /**\n     * SpanLogSaveMessage lamports.\n     * @member {Array.<number|Long>} lamports\n     * @memberof SpanLogSaveMessage\n     * @instance\n     */\n    SpanLogSaveMessage.prototype.lamports = $util.emptyArray;\n\n    /**\n     * Creates a new SpanLogSaveMessage instance using the specified properties.\n     * @function create\n     * @memberof SpanLogSaveMessage\n     * @static\n     * @param {ISpanLogSaveMessage=} [properties] Properties to set\n     * @returns {SpanLogSaveMessage} SpanLogSaveMessage instance\n     */\n    SpanLogSaveMessage.create = function create(properties) {\n        return new SpanLogSaveMessage(properties);\n    };\n\n    /**\n     * Encodes the specified SpanLogSaveMessage message. Does not implicitly {@link SpanLogSaveMessage.verify|verify} messages.\n     * @function encode\n     * @memberof SpanLogSaveMessage\n     * @static\n     * @param {ISpanLogSaveMessage} message SpanLogSaveMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    SpanLogSaveMessage.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.senderIDs != null && message.senderIDs.length)\n            for (let i = 0; i < message.senderIDs.length; ++i)\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.senderIDs[i]);\n        if (message.lengths != null && message.lengths.length) {\n            writer.uint32(/* id 2, wireType 2 =*/18).fork();\n            for (let i = 0; i < message.lengths.length; ++i)\n                writer.uint32(message.lengths[i]);\n            writer.ldelim();\n        }\n        if (message.spans != null && message.spans.length)\n            for (let i = 0; i < message.spans.length; ++i)\n                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.spans[i]);\n        if (message.lamports != null && message.lamports.length) {\n            writer.uint32(/* id 4, wireType 2 =*/34).fork();\n            for (let i = 0; i < message.lamports.length; ++i)\n                writer.uint64(message.lamports[i]);\n            writer.ldelim();\n        }\n        return writer;\n    };\n\n    /**\n     * Encodes the specified SpanLogSaveMessage message, length delimited. Does not implicitly {@link SpanLogSaveMessage.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof SpanLogSaveMessage\n     * @static\n     * @param {ISpanLogSaveMessage} message SpanLogSaveMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    SpanLogSaveMessage.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a SpanLogSaveMessage message from the specified reader or buffer.\n     * @function decode\n     * @memberof SpanLogSaveMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {SpanLogSaveMessage} SpanLogSaveMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    SpanLogSaveMessage.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new SpanLogSaveMessage();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                if (!(message.senderIDs && message.senderIDs.length))\n                    message.senderIDs = [];\n                message.senderIDs.push(reader.string());\n                break;\n            case 2:\n                if (!(message.lengths && message.lengths.length))\n                    message.lengths = [];\n                if ((tag & 7) === 2) {\n                    let end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.lengths.push(reader.uint32());\n                } else\n                    message.lengths.push(reader.uint32());\n                break;\n            case 3:\n                if (!(message.spans && message.spans.length))\n                    message.spans = [];\n                message.spans.push(reader.bytes());\n                break;\n            case 4:\n                if (!(message.lamports && message.lamports.length))\n                    message.lamports = [];\n                if ((tag & 7) === 2) {\n                    let end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.lamports.push(reader.uint64());\n                } else\n                    message.lamports.push(reader.uint64());\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a SpanLogSaveMessage message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof SpanLogSaveMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {SpanLogSaveMessage} SpanLogSaveMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    SpanLogSaveMessage.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a SpanLogSaveMessage message.\n     * @function verify\n     * @memberof SpanLogSaveMessage\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    SpanLogSaveMessage.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.senderIDs != null && message.hasOwnProperty(\"senderIDs\")) {\n            if (!Array.isArray(message.senderIDs))\n                return \"senderIDs: array expected\";\n            for (let i = 0; i < message.senderIDs.length; ++i)\n                if (!$util.isString(message.senderIDs[i]))\n                    return \"senderIDs: string[] expected\";\n        }\n        if (message.lengths != null && message.hasOwnProperty(\"lengths\")) {\n            if (!Array.isArray(message.lengths))\n                return \"lengths: array expected\";\n            for (let i = 0; i < message.lengths.length; ++i)\n                if (!$util.isInteger(message.lengths[i]))\n                    return \"lengths: integer[] expected\";\n        }\n        if (message.spans != null && message.hasOwnProperty(\"spans\")) {\n            if (!Array.isArray(message.spans))\n                return \"spans: array expected\";\n            for (let i = 0; i < message.spans.length; ++i)\n                if (!(message.spans[i] && typeof message.spans[i].length === \"number\" || $util.isString(message.spans[i])))\n                    return \"spans: buffer[] expected\";\n        }\n        if (message.lamports != null && message.hasOwnProperty(\"lamports\")) {\n            if (!Array.isArray(message.lamports))\n                return \"lamports: array expected\";\n            for (let i = 0; i < message.lamports.length; ++i)\n                if (!$util.isInteger(message.lamports[i]) && !(message.lamports[i] && $util.isInteger(message.lamports[i].low) && $util.isInteger(message.lamports[i].high)))\n                    return \"lamports: integer|Long[] expected\";\n        }\n        return null;\n    };\n\n    /**\n     * Creates a SpanLogSaveMessage message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof SpanLogSaveMessage\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {SpanLogSaveMessage} SpanLogSaveMessage\n     */\n    SpanLogSaveMessage.fromObject = function fromObject(object) {\n        if (object instanceof SpanLogSaveMessage)\n            return object;\n        let message = new SpanLogSaveMessage();\n        if (object.senderIDs) {\n            if (!Array.isArray(object.senderIDs))\n                throw TypeError(\".SpanLogSaveMessage.senderIDs: array expected\");\n            message.senderIDs = [];\n            for (let i = 0; i < object.senderIDs.length; ++i)\n                message.senderIDs[i] = String(object.senderIDs[i]);\n        }\n        if (object.lengths) {\n            if (!Array.isArray(object.lengths))\n                throw TypeError(\".SpanLogSaveMessage.lengths: array expected\");\n            message.lengths = [];\n            for (let i = 0; i < object.lengths.length; ++i)\n                message.lengths[i] = object.lengths[i] >>> 0;\n        }\n        if (object.spans) {\n            if (!Array.isArray(object.spans))\n                throw TypeError(\".SpanLogSaveMessage.spans: array expected\");\n            message.spans = [];\n            for (let i = 0; i < object.spans.length; ++i)\n                if (typeof object.spans[i] === \"string\")\n                    $util.base64.decode(object.spans[i], message.spans[i] = $util.newBuffer($util.base64.length(object.spans[i])), 0);\n                else if (object.spans[i].length)\n                    message.spans[i] = object.spans[i];\n        }\n        if (object.lamports) {\n            if (!Array.isArray(object.lamports))\n                throw TypeError(\".SpanLogSaveMessage.lamports: array expected\");\n            message.lamports = [];\n            for (let i = 0; i < object.lamports.length; ++i)\n                if ($util.Long)\n                    (message.lamports[i] = $util.Long.fromValue(object.lamports[i])).unsigned = true;\n                else if (typeof object.lamports[i] === \"string\")\n                    message.lamports[i] = parseInt(object.lamports[i], 10);\n                else if (typeof object.lamports[i] === \"number\")\n                    message.lamports[i] = object.lamports[i];\n                else if (typeof object.lamports[i] === \"object\")\n                    message.lamports[i] = new $util.LongBits(object.lamports[i].low >>> 0, object.lamports[i].high >>> 0).toNumber(true);\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a SpanLogSaveMessage message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof SpanLogSaveMessage\n     * @static\n     * @param {SpanLogSaveMessage} message SpanLogSaveMessage\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    SpanLogSaveMessage.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults) {\n            object.senderIDs = [];\n            object.lengths = [];\n            object.spans = [];\n            object.lamports = [];\n        }\n        if (message.senderIDs && message.senderIDs.length) {\n            object.senderIDs = [];\n            for (let j = 0; j < message.senderIDs.length; ++j)\n                object.senderIDs[j] = message.senderIDs[j];\n        }\n        if (message.lengths && message.lengths.length) {\n            object.lengths = [];\n            for (let j = 0; j < message.lengths.length; ++j)\n                object.lengths[j] = message.lengths[j];\n        }\n        if (message.spans && message.spans.length) {\n            object.spans = [];\n            for (let j = 0; j < message.spans.length; ++j)\n                object.spans[j] = options.bytes === String ? $util.base64.encode(message.spans[j], 0, message.spans[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.spans[j]) : message.spans[j];\n        }\n        if (message.lamports && message.lamports.length) {\n            object.lamports = [];\n            for (let j = 0; j < message.lamports.length; ++j)\n                if (typeof message.lamports[j] === \"number\")\n                    object.lamports[j] = options.longs === String ? String(message.lamports[j]) : message.lamports[j];\n                else\n                    object.lamports[j] = options.longs === String ? $util.Long.prototype.toString.call(message.lamports[j]) : options.longs === Number ? new $util.LongBits(message.lamports[j].low >>> 0, message.lamports[j].high >>> 0).toNumber(true) : message.lamports[j];\n        }\n        return object;\n    };\n\n    /**\n     * Converts this SpanLogSaveMessage to JSON.\n     * @function toJSON\n     * @memberof SpanLogSaveMessage\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    SpanLogSaveMessage.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return SpanLogSaveMessage;\n})();\n\nexport const ValueListInsertMessage = /*@__PURE__*/ (() => {\n\n    /**\n     * Properties of a ValueListInsertMessage.\n     * @exports IValueListInsertMessage\n     * @interface IValueListInsertMessage\n     * @property {number} counter ValueListInsertMessage counter\n     * @property {number|null} [valueIndex] ValueListInsertMessage valueIndex\n     * @property {Uint8Array|null} [value] ValueListInsertMessage value\n     * @property {Uint8Array|null} [valueArray] ValueListInsertMessage valueArray\n     */\n\n    /**\n     * Constructs a new ValueListInsertMessage.\n     * @exports ValueListInsertMessage\n     * @classdesc Represents a ValueListInsertMessage.\n     * @implements IValueListInsertMessage\n     * @constructor\n     * @param {IValueListInsertMessage=} [properties] Properties to set\n     */\n    function ValueListInsertMessage(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * ValueListInsertMessage counter.\n     * @member {number} counter\n     * @memberof ValueListInsertMessage\n     * @instance\n     */\n    ValueListInsertMessage.prototype.counter = 0;\n\n    /**\n     * ValueListInsertMessage valueIndex.\n     * @member {number} valueIndex\n     * @memberof ValueListInsertMessage\n     * @instance\n     */\n    ValueListInsertMessage.prototype.valueIndex = 0;\n\n    /**\n     * ValueListInsertMessage value.\n     * @member {Uint8Array} value\n     * @memberof ValueListInsertMessage\n     * @instance\n     */\n    ValueListInsertMessage.prototype.value = $util.newBuffer([]);\n\n    /**\n     * ValueListInsertMessage valueArray.\n     * @member {Uint8Array} valueArray\n     * @memberof ValueListInsertMessage\n     * @instance\n     */\n    ValueListInsertMessage.prototype.valueArray = $util.newBuffer([]);\n\n    // OneOf field names bound to virtual getters and setters\n    let $oneOfFields;\n\n    /**\n     * ValueListInsertMessage data.\n     * @member {\"value\"|\"valueArray\"|undefined} data\n     * @memberof ValueListInsertMessage\n     * @instance\n     */\n    Object.defineProperty(ValueListInsertMessage.prototype, \"data\", {\n        get: $util.oneOfGetter($oneOfFields = [\"value\", \"valueArray\"]),\n        set: $util.oneOfSetter($oneOfFields)\n    });\n\n    /**\n     * Creates a new ValueListInsertMessage instance using the specified properties.\n     * @function create\n     * @memberof ValueListInsertMessage\n     * @static\n     * @param {IValueListInsertMessage=} [properties] Properties to set\n     * @returns {ValueListInsertMessage} ValueListInsertMessage instance\n     */\n    ValueListInsertMessage.create = function create(properties) {\n        return new ValueListInsertMessage(properties);\n    };\n\n    /**\n     * Encodes the specified ValueListInsertMessage message. Does not implicitly {@link ValueListInsertMessage.verify|verify} messages.\n     * @function encode\n     * @memberof ValueListInsertMessage\n     * @static\n     * @param {IValueListInsertMessage} message ValueListInsertMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ValueListInsertMessage.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.counter);\n        if (message.valueIndex != null && Object.hasOwnProperty.call(message, \"valueIndex\"))\n            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.valueIndex);\n        if (message.value != null && Object.hasOwnProperty.call(message, \"value\"))\n            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.value);\n        if (message.valueArray != null && Object.hasOwnProperty.call(message, \"valueArray\"))\n            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.valueArray);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified ValueListInsertMessage message, length delimited. Does not implicitly {@link ValueListInsertMessage.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ValueListInsertMessage\n     * @static\n     * @param {IValueListInsertMessage} message ValueListInsertMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ValueListInsertMessage.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a ValueListInsertMessage message from the specified reader or buffer.\n     * @function decode\n     * @memberof ValueListInsertMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ValueListInsertMessage} ValueListInsertMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ValueListInsertMessage.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new ValueListInsertMessage();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.counter = reader.uint32();\n                break;\n            case 2:\n                message.valueIndex = reader.uint32();\n                break;\n            case 3:\n                message.value = reader.bytes();\n                break;\n            case 4:\n                message.valueArray = reader.bytes();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        if (!message.hasOwnProperty(\"counter\"))\n            throw $util.ProtocolError(\"missing required 'counter'\", { instance: message });\n        return message;\n    };\n\n    /**\n     * Decodes a ValueListInsertMessage message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ValueListInsertMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ValueListInsertMessage} ValueListInsertMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ValueListInsertMessage.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a ValueListInsertMessage message.\n     * @function verify\n     * @memberof ValueListInsertMessage\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    ValueListInsertMessage.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        let properties = {};\n        if (!$util.isInteger(message.counter))\n            return \"counter: integer expected\";\n        if (message.valueIndex != null && message.hasOwnProperty(\"valueIndex\"))\n            if (!$util.isInteger(message.valueIndex))\n                return \"valueIndex: integer expected\";\n        if (message.value != null && message.hasOwnProperty(\"value\")) {\n            properties.data = 1;\n            if (!(message.value && typeof message.value.length === \"number\" || $util.isString(message.value)))\n                return \"value: buffer expected\";\n        }\n        if (message.valueArray != null && message.hasOwnProperty(\"valueArray\")) {\n            if (properties.data === 1)\n                return \"data: multiple values\";\n            properties.data = 1;\n            if (!(message.valueArray && typeof message.valueArray.length === \"number\" || $util.isString(message.valueArray)))\n                return \"valueArray: buffer expected\";\n        }\n        return null;\n    };\n\n    /**\n     * Creates a ValueListInsertMessage message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ValueListInsertMessage\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ValueListInsertMessage} ValueListInsertMessage\n     */\n    ValueListInsertMessage.fromObject = function fromObject(object) {\n        if (object instanceof ValueListInsertMessage)\n            return object;\n        let message = new ValueListInsertMessage();\n        if (object.counter != null)\n            message.counter = object.counter >>> 0;\n        if (object.valueIndex != null)\n            message.valueIndex = object.valueIndex >>> 0;\n        if (object.value != null)\n            if (typeof object.value === \"string\")\n                $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);\n            else if (object.value.length)\n                message.value = object.value;\n        if (object.valueArray != null)\n            if (typeof object.valueArray === \"string\")\n                $util.base64.decode(object.valueArray, message.valueArray = $util.newBuffer($util.base64.length(object.valueArray)), 0);\n            else if (object.valueArray.length)\n                message.valueArray = object.valueArray;\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a ValueListInsertMessage message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ValueListInsertMessage\n     * @static\n     * @param {ValueListInsertMessage} message ValueListInsertMessage\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    ValueListInsertMessage.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.defaults) {\n            object.counter = 0;\n            object.valueIndex = 0;\n        }\n        if (message.counter != null && message.hasOwnProperty(\"counter\"))\n            object.counter = message.counter;\n        if (message.valueIndex != null && message.hasOwnProperty(\"valueIndex\"))\n            object.valueIndex = message.valueIndex;\n        if (message.value != null && message.hasOwnProperty(\"value\")) {\n            object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;\n            if (options.oneofs)\n                object.data = \"value\";\n        }\n        if (message.valueArray != null && message.hasOwnProperty(\"valueArray\")) {\n            object.valueArray = options.bytes === String ? $util.base64.encode(message.valueArray, 0, message.valueArray.length) : options.bytes === Array ? Array.prototype.slice.call(message.valueArray) : message.valueArray;\n            if (options.oneofs)\n                object.data = \"valueArray\";\n        }\n        return object;\n    };\n\n    /**\n     * Converts this ValueListInsertMessage to JSON.\n     * @function toJSON\n     * @memberof ValueListInsertMessage\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    ValueListInsertMessage.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return ValueListInsertMessage;\n})();\n\nexport const ValueListMessage = /*@__PURE__*/ (() => {\n\n    /**\n     * Properties of a ValueListMessage.\n     * @exports IValueListMessage\n     * @interface IValueListMessage\n     * @property {IValueListInsertMessage|null} [insert] ValueListMessage insert\n     * @property {string|null} [\"delete\"] ValueListMessage delete\n     */\n\n    /**\n     * Constructs a new ValueListMessage.\n     * @exports ValueListMessage\n     * @classdesc Represents a ValueListMessage.\n     * @implements IValueListMessage\n     * @constructor\n     * @param {IValueListMessage=} [properties] Properties to set\n     */\n    function ValueListMessage(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * ValueListMessage insert.\n     * @member {IValueListInsertMessage|null|undefined} insert\n     * @memberof ValueListMessage\n     * @instance\n     */\n    ValueListMessage.prototype.insert = null;\n\n    /**\n     * ValueListMessage delete.\n     * @member {string} delete\n     * @memberof ValueListMessage\n     * @instance\n     */\n    ValueListMessage.prototype[\"delete\"] = \"\";\n\n    // OneOf field names bound to virtual getters and setters\n    let $oneOfFields;\n\n    /**\n     * ValueListMessage op.\n     * @member {\"insert\"|\"delete\"|undefined} op\n     * @memberof ValueListMessage\n     * @instance\n     */\n    Object.defineProperty(ValueListMessage.prototype, \"op\", {\n        get: $util.oneOfGetter($oneOfFields = [\"insert\", \"delete\"]),\n        set: $util.oneOfSetter($oneOfFields)\n    });\n\n    /**\n     * Creates a new ValueListMessage instance using the specified properties.\n     * @function create\n     * @memberof ValueListMessage\n     * @static\n     * @param {IValueListMessage=} [properties] Properties to set\n     * @returns {ValueListMessage} ValueListMessage instance\n     */\n    ValueListMessage.create = function create(properties) {\n        return new ValueListMessage(properties);\n    };\n\n    /**\n     * Encodes the specified ValueListMessage message. Does not implicitly {@link ValueListMessage.verify|verify} messages.\n     * @function encode\n     * @memberof ValueListMessage\n     * @static\n     * @param {IValueListMessage} message ValueListMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ValueListMessage.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.insert != null && Object.hasOwnProperty.call(message, \"insert\"))\n            ValueListInsertMessage.encode(message.insert, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n        if (message[\"delete\"] != null && Object.hasOwnProperty.call(message, \"delete\"))\n            writer.uint32(/* id 2, wireType 2 =*/18).string(message[\"delete\"]);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified ValueListMessage message, length delimited. Does not implicitly {@link ValueListMessage.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ValueListMessage\n     * @static\n     * @param {IValueListMessage} message ValueListMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ValueListMessage.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a ValueListMessage message from the specified reader or buffer.\n     * @function decode\n     * @memberof ValueListMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ValueListMessage} ValueListMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ValueListMessage.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new ValueListMessage();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.insert = ValueListInsertMessage.decode(reader, reader.uint32());\n                break;\n            case 2:\n                message[\"delete\"] = reader.string();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a ValueListMessage message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ValueListMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ValueListMessage} ValueListMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ValueListMessage.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a ValueListMessage message.\n     * @function verify\n     * @memberof ValueListMessage\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    ValueListMessage.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        let properties = {};\n        if (message.insert != null && message.hasOwnProperty(\"insert\")) {\n            properties.op = 1;\n            {\n                let error = ValueListInsertMessage.verify(message.insert);\n                if (error)\n                    return \"insert.\" + error;\n            }\n        }\n        if (message[\"delete\"] != null && message.hasOwnProperty(\"delete\")) {\n            if (properties.op === 1)\n                return \"op: multiple values\";\n            properties.op = 1;\n            if (!$util.isString(message[\"delete\"]))\n                return \"delete: string expected\";\n        }\n        return null;\n    };\n\n    /**\n     * Creates a ValueListMessage message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ValueListMessage\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ValueListMessage} ValueListMessage\n     */\n    ValueListMessage.fromObject = function fromObject(object) {\n        if (object instanceof ValueListMessage)\n            return object;\n        let message = new ValueListMessage();\n        if (object.insert != null) {\n            if (typeof object.insert !== \"object\")\n                throw TypeError(\".ValueListMessage.insert: object expected\");\n            message.insert = ValueListInsertMessage.fromObject(object.insert);\n        }\n        if (object[\"delete\"] != null)\n            message[\"delete\"] = String(object[\"delete\"]);\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a ValueListMessage message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ValueListMessage\n     * @static\n     * @param {ValueListMessage} message ValueListMessage\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    ValueListMessage.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (message.insert != null && message.hasOwnProperty(\"insert\")) {\n            object.insert = ValueListInsertMessage.toObject(message.insert, options);\n            if (options.oneofs)\n                object.op = \"insert\";\n        }\n        if (message[\"delete\"] != null && message.hasOwnProperty(\"delete\")) {\n            object[\"delete\"] = message[\"delete\"];\n            if (options.oneofs)\n                object.op = \"delete\";\n        }\n        return object;\n    };\n\n    /**\n     * Converts this ValueListMessage to JSON.\n     * @function toJSON\n     * @memberof ValueListMessage\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    ValueListMessage.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return ValueListMessage;\n})();\n\nexport const MessageSerializerMergeInfo = /*@__PURE__*/ (() => {\n\n    /**\n     * Properties of a MessageSerializerMergeInfo.\n     * @exports IMessageSerializerMergeInfo\n     * @interface IMessageSerializerMergeInfo\n     * @property {Array.<string>|null} [replicaIDs] MessageSerializerMergeInfo replicaIDs\n     * @property {Array.<number>|null} [lengths] MessageSerializerMergeInfo lengths\n     */\n\n    /**\n     * Constructs a new MessageSerializerMergeInfo.\n     * @exports MessageSerializerMergeInfo\n     * @classdesc Represents a MessageSerializerMergeInfo.\n     * @implements IMessageSerializerMergeInfo\n     * @constructor\n     * @param {IMessageSerializerMergeInfo=} [properties] Properties to set\n     */\n    function MessageSerializerMergeInfo(properties) {\n        this.replicaIDs = [];\n        this.lengths = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * MessageSerializerMergeInfo replicaIDs.\n     * @member {Array.<string>} replicaIDs\n     * @memberof MessageSerializerMergeInfo\n     * @instance\n     */\n    MessageSerializerMergeInfo.prototype.replicaIDs = $util.emptyArray;\n\n    /**\n     * MessageSerializerMergeInfo lengths.\n     * @member {Array.<number>} lengths\n     * @memberof MessageSerializerMergeInfo\n     * @instance\n     */\n    MessageSerializerMergeInfo.prototype.lengths = $util.emptyArray;\n\n    /**\n     * Creates a new MessageSerializerMergeInfo instance using the specified properties.\n     * @function create\n     * @memberof MessageSerializerMergeInfo\n     * @static\n     * @param {IMessageSerializerMergeInfo=} [properties] Properties to set\n     * @returns {MessageSerializerMergeInfo} MessageSerializerMergeInfo instance\n     */\n    MessageSerializerMergeInfo.create = function create(properties) {\n        return new MessageSerializerMergeInfo(properties);\n    };\n\n    /**\n     * Encodes the specified MessageSerializerMergeInfo message. Does not implicitly {@link MessageSerializerMergeInfo.verify|verify} messages.\n     * @function encode\n     * @memberof MessageSerializerMergeInfo\n     * @static\n     * @param {IMessageSerializerMergeInfo} message MessageSerializerMergeInfo message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    MessageSerializerMergeInfo.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.replicaIDs != null && message.replicaIDs.length)\n            for (let i = 0; i < message.replicaIDs.length; ++i)\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.replicaIDs[i]);\n        if (message.lengths != null && message.lengths.length) {\n            writer.uint32(/* id 2, wireType 2 =*/18).fork();\n            for (let i = 0; i < message.lengths.length; ++i)\n                writer.uint32(message.lengths[i]);\n            writer.ldelim();\n        }\n        return writer;\n    };\n\n    /**\n     * Encodes the specified MessageSerializerMergeInfo message, length delimited. Does not implicitly {@link MessageSerializerMergeInfo.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof MessageSerializerMergeInfo\n     * @static\n     * @param {IMessageSerializerMergeInfo} message MessageSerializerMergeInfo message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    MessageSerializerMergeInfo.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a MessageSerializerMergeInfo message from the specified reader or buffer.\n     * @function decode\n     * @memberof MessageSerializerMergeInfo\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {MessageSerializerMergeInfo} MessageSerializerMergeInfo\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    MessageSerializerMergeInfo.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new MessageSerializerMergeInfo();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                if (!(message.replicaIDs && message.replicaIDs.length))\n                    message.replicaIDs = [];\n                message.replicaIDs.push(reader.string());\n                break;\n            case 2:\n                if (!(message.lengths && message.lengths.length))\n                    message.lengths = [];\n                if ((tag & 7) === 2) {\n                    let end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.lengths.push(reader.uint32());\n                } else\n                    message.lengths.push(reader.uint32());\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a MessageSerializerMergeInfo message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof MessageSerializerMergeInfo\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {MessageSerializerMergeInfo} MessageSerializerMergeInfo\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    MessageSerializerMergeInfo.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a MessageSerializerMergeInfo message.\n     * @function verify\n     * @memberof MessageSerializerMergeInfo\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    MessageSerializerMergeInfo.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.replicaIDs != null && message.hasOwnProperty(\"replicaIDs\")) {\n            if (!Array.isArray(message.replicaIDs))\n                return \"replicaIDs: array expected\";\n            for (let i = 0; i < message.replicaIDs.length; ++i)\n                if (!$util.isString(message.replicaIDs[i]))\n                    return \"replicaIDs: string[] expected\";\n        }\n        if (message.lengths != null && message.hasOwnProperty(\"lengths\")) {\n            if (!Array.isArray(message.lengths))\n                return \"lengths: array expected\";\n            for (let i = 0; i < message.lengths.length; ++i)\n                if (!$util.isInteger(message.lengths[i]))\n                    return \"lengths: integer[] expected\";\n        }\n        return null;\n    };\n\n    /**\n     * Creates a MessageSerializerMergeInfo message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof MessageSerializerMergeInfo\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {MessageSerializerMergeInfo} MessageSerializerMergeInfo\n     */\n    MessageSerializerMergeInfo.fromObject = function fromObject(object) {\n        if (object instanceof MessageSerializerMergeInfo)\n            return object;\n        let message = new MessageSerializerMergeInfo();\n        if (object.replicaIDs) {\n            if (!Array.isArray(object.replicaIDs))\n                throw TypeError(\".MessageSerializerMergeInfo.replicaIDs: array expected\");\n            message.replicaIDs = [];\n            for (let i = 0; i < object.replicaIDs.length; ++i)\n                message.replicaIDs[i] = String(object.replicaIDs[i]);\n        }\n        if (object.lengths) {\n            if (!Array.isArray(object.lengths))\n                throw TypeError(\".MessageSerializerMergeInfo.lengths: array expected\");\n            message.lengths = [];\n            for (let i = 0; i < object.lengths.length; ++i)\n                message.lengths[i] = object.lengths[i] >>> 0;\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a MessageSerializerMergeInfo message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof MessageSerializerMergeInfo\n     * @static\n     * @param {MessageSerializerMergeInfo} message MessageSerializerMergeInfo\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    MessageSerializerMergeInfo.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults) {\n            object.replicaIDs = [];\n            object.lengths = [];\n        }\n        if (message.replicaIDs && message.replicaIDs.length) {\n            object.replicaIDs = [];\n            for (let j = 0; j < message.replicaIDs.length; ++j)\n                object.replicaIDs[j] = message.replicaIDs[j];\n        }\n        if (message.lengths && message.lengths.length) {\n            object.lengths = [];\n            for (let j = 0; j < message.lengths.length; ++j)\n                object.lengths[j] = message.lengths[j];\n        }\n        return object;\n    };\n\n    /**\n     * Converts this MessageSerializerMergeInfo to JSON.\n     * @function toJSON\n     * @memberof MessageSerializerMergeInfo\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    MessageSerializerMergeInfo.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return MessageSerializerMergeInfo;\n})();\n\nexport const CRDTMessageMetaMessage = /*@__PURE__*/ (() => {\n\n    /**\n     * Properties of a CRDTMessageMetaMessage.\n     * @exports ICRDTMessageMetaMessage\n     * @interface ICRDTMessageMetaMessage\n     * @property {string} senderID CRDTMessageMetaMessage senderID\n     * @property {number} senderCounter CRDTMessageMetaMessage senderCounter\n     * @property {Array.<string>|null} [vcKeys] CRDTMessageMetaMessage vcKeys\n     * @property {Array.<number>|null} [vcValues] CRDTMessageMetaMessage vcValues\n     * @property {number|null} [maximalVcKeyCount] CRDTMessageMetaMessage maximalVcKeyCount\n     * @property {number|Long|null} [wallClockTime] CRDTMessageMetaMessage wallClockTime\n     * @property {number|Long|null} [lamportTimestamp] CRDTMessageMetaMessage lamportTimestamp\n     * @property {Array.<number>|null} [encodedVcKeys] CRDTMessageMetaMessage encodedVcKeys\n     */\n\n    /**\n     * Constructs a new CRDTMessageMetaMessage.\n     * @exports CRDTMessageMetaMessage\n     * @classdesc Represents a CRDTMessageMetaMessage.\n     * @implements ICRDTMessageMetaMessage\n     * @constructor\n     * @param {ICRDTMessageMetaMessage=} [properties] Properties to set\n     */\n    function CRDTMessageMetaMessage(properties) {\n        this.vcKeys = [];\n        this.vcValues = [];\n        this.encodedVcKeys = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * CRDTMessageMetaMessage senderID.\n     * @member {string} senderID\n     * @memberof CRDTMessageMetaMessage\n     * @instance\n     */\n    CRDTMessageMetaMessage.prototype.senderID = \"\";\n\n    /**\n     * CRDTMessageMetaMessage senderCounter.\n     * @member {number} senderCounter\n     * @memberof CRDTMessageMetaMessage\n     * @instance\n     */\n    CRDTMessageMetaMessage.prototype.senderCounter = 0;\n\n    /**\n     * CRDTMessageMetaMessage vcKeys.\n     * @member {Array.<string>} vcKeys\n     * @memberof CRDTMessageMetaMessage\n     * @instance\n     */\n    CRDTMessageMetaMessage.prototype.vcKeys = $util.emptyArray;\n\n    /**\n     * CRDTMessageMetaMessage vcValues.\n     * @member {Array.<number>} vcValues\n     * @memberof CRDTMessageMetaMessage\n     * @instance\n     */\n    CRDTMessageMetaMessage.prototype.vcValues = $util.emptyArray;\n\n    /**\n     * CRDTMessageMetaMessage maximalVcKeyCount.\n     * @member {number} maximalVcKeyCount\n     * @memberof CRDTMessageMetaMessage\n     * @instance\n     */\n    CRDTMessageMetaMessage.prototype.maximalVcKeyCount = 0;\n\n    /**\n     * CRDTMessageMetaMessage wallClockTime.\n     * @member {number|Long} wallClockTime\n     * @memberof CRDTMessageMetaMessage\n     * @instance\n     */\n    CRDTMessageMetaMessage.prototype.wallClockTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * CRDTMessageMetaMessage lamportTimestamp.\n     * @member {number|Long} lamportTimestamp\n     * @memberof CRDTMessageMetaMessage\n     * @instance\n     */\n    CRDTMessageMetaMessage.prototype.lamportTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * CRDTMessageMetaMessage encodedVcKeys.\n     * @member {Array.<number>} encodedVcKeys\n     * @memberof CRDTMessageMetaMessage\n     * @instance\n     */\n    CRDTMessageMetaMessage.prototype.encodedVcKeys = $util.emptyArray;\n\n    /**\n     * Creates a new CRDTMessageMetaMessage instance using the specified properties.\n     * @function create\n     * @memberof CRDTMessageMetaMessage\n     * @static\n     * @param {ICRDTMessageMetaMessage=} [properties] Properties to set\n     * @returns {CRDTMessageMetaMessage} CRDTMessageMetaMessage instance\n     */\n    CRDTMessageMetaMessage.create = function create(properties) {\n        return new CRDTMessageMetaMessage(properties);\n    };\n\n    /**\n     * Encodes the specified CRDTMessageMetaMessage message. Does not implicitly {@link CRDTMessageMetaMessage.verify|verify} messages.\n     * @function encode\n     * @memberof CRDTMessageMetaMessage\n     * @static\n     * @param {ICRDTMessageMetaMessage} message CRDTMessageMetaMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    CRDTMessageMetaMessage.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        writer.uint32(/* id 1, wireType 2 =*/10).string(message.senderID);\n        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.senderCounter);\n        if (message.vcKeys != null && message.vcKeys.length)\n            for (let i = 0; i < message.vcKeys.length; ++i)\n                writer.uint32(/* id 3, wireType 2 =*/26).string(message.vcKeys[i]);\n        if (message.vcValues != null && message.vcValues.length) {\n            writer.uint32(/* id 4, wireType 2 =*/34).fork();\n            for (let i = 0; i < message.vcValues.length; ++i)\n                writer.uint32(message.vcValues[i]);\n            writer.ldelim();\n        }\n        if (message.maximalVcKeyCount != null && Object.hasOwnProperty.call(message, \"maximalVcKeyCount\"))\n            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.maximalVcKeyCount);\n        if (message.wallClockTime != null && Object.hasOwnProperty.call(message, \"wallClockTime\"))\n            writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.wallClockTime);\n        if (message.lamportTimestamp != null && Object.hasOwnProperty.call(message, \"lamportTimestamp\"))\n            writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.lamportTimestamp);\n        if (message.encodedVcKeys != null && message.encodedVcKeys.length) {\n            writer.uint32(/* id 8, wireType 2 =*/66).fork();\n            for (let i = 0; i < message.encodedVcKeys.length; ++i)\n                writer.uint32(message.encodedVcKeys[i]);\n            writer.ldelim();\n        }\n        return writer;\n    };\n\n    /**\n     * Encodes the specified CRDTMessageMetaMessage message, length delimited. Does not implicitly {@link CRDTMessageMetaMessage.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof CRDTMessageMetaMessage\n     * @static\n     * @param {ICRDTMessageMetaMessage} message CRDTMessageMetaMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    CRDTMessageMetaMessage.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a CRDTMessageMetaMessage message from the specified reader or buffer.\n     * @function decode\n     * @memberof CRDTMessageMetaMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CRDTMessageMetaMessage} CRDTMessageMetaMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CRDTMessageMetaMessage.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new CRDTMessageMetaMessage();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.senderID = reader.string();\n                break;\n            case 2:\n                message.senderCounter = reader.uint32();\n                break;\n            case 3:\n                if (!(message.vcKeys && message.vcKeys.length))\n                    message.vcKeys = [];\n                message.vcKeys.push(reader.string());\n                break;\n            case 4:\n                if (!(message.vcValues && message.vcValues.length))\n                    message.vcValues = [];\n                if ((tag & 7) === 2) {\n                    let end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.vcValues.push(reader.uint32());\n                } else\n                    message.vcValues.push(reader.uint32());\n                break;\n            case 5:\n                message.maximalVcKeyCount = reader.uint32();\n                break;\n            case 6:\n                message.wallClockTime = reader.uint64();\n                break;\n            case 7:\n                message.lamportTimestamp = reader.uint64();\n                break;\n            case 8:\n                if (!(message.encodedVcKeys && message.encodedVcKeys.length))\n                    message.encodedVcKeys = [];\n                if ((tag & 7) === 2) {\n                    let end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.encodedVcKeys.push(reader.uint32());\n                } else\n                    message.encodedVcKeys.push(reader.uint32());\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        if (!message.hasOwnProperty(\"senderID\"))\n            throw $util.ProtocolError(\"missing required 'senderID'\", { instance: message });\n        if (!message.hasOwnProperty(\"senderCounter\"))\n            throw $util.ProtocolError(\"missing required 'senderCounter'\", { instance: message });\n        return message;\n    };\n\n    /**\n     * Decodes a CRDTMessageMetaMessage message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof CRDTMessageMetaMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {CRDTMessageMetaMessage} CRDTMessageMetaMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CRDTMessageMetaMessage.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a CRDTMessageMetaMessage message.\n     * @function verify\n     * @memberof CRDTMessageMetaMessage\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    CRDTMessageMetaMessage.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (!$util.isString(message.senderID))\n            return \"senderID: string expected\";\n        if (!$util.isInteger(message.senderCounter))\n            return \"senderCounter: integer expected\";\n        if (message.vcKeys != null && message.hasOwnProperty(\"vcKeys\")) {\n            if (!Array.isArray(message.vcKeys))\n                return \"vcKeys: array expected\";\n            for (let i = 0; i < message.vcKeys.length; ++i)\n                if (!$util.isString(message.vcKeys[i]))\n                    return \"vcKeys: string[] expected\";\n        }\n        if (message.vcValues != null && message.hasOwnProperty(\"vcValues\")) {\n            if (!Array.isArray(message.vcValues))\n                return \"vcValues: array expected\";\n            for (let i = 0; i < message.vcValues.length; ++i)\n                if (!$util.isInteger(message.vcValues[i]))\n                    return \"vcValues: integer[] expected\";\n        }\n        if (message.maximalVcKeyCount != null && message.hasOwnProperty(\"maximalVcKeyCount\"))\n            if (!$util.isInteger(message.maximalVcKeyCount))\n                return \"maximalVcKeyCount: integer expected\";\n        if (message.wallClockTime != null && message.hasOwnProperty(\"wallClockTime\"))\n            if (!$util.isInteger(message.wallClockTime) && !(message.wallClockTime && $util.isInteger(message.wallClockTime.low) && $util.isInteger(message.wallClockTime.high)))\n                return \"wallClockTime: integer|Long expected\";\n        if (message.lamportTimestamp != null && message.hasOwnProperty(\"lamportTimestamp\"))\n            if (!$util.isInteger(message.lamportTimestamp) && !(message.lamportTimestamp && $util.isInteger(message.lamportTimestamp.low) && $util.isInteger(message.lamportTimestamp.high)))\n                return \"lamportTimestamp: integer|Long expected\";\n        if (message.encodedVcKeys != null && message.hasOwnProperty(\"encodedVcKeys\")) {\n            if (!Array.isArray(message.encodedVcKeys))\n                return \"encodedVcKeys: array expected\";\n            for (let i = 0; i < message.encodedVcKeys.length; ++i)\n                if (!$util.isInteger(message.encodedVcKeys[i]))\n                    return \"encodedVcKeys: integer[] expected\";\n        }\n        return null;\n    };\n\n    /**\n     * Creates a CRDTMessageMetaMessage message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof CRDTMessageMetaMessage\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {CRDTMessageMetaMessage} CRDTMessageMetaMessage\n     */\n    CRDTMessageMetaMessage.fromObject = function fromObject(object) {\n        if (object instanceof CRDTMessageMetaMessage)\n            return object;\n        let message = new CRDTMessageMetaMessage();\n        if (object.senderID != null)\n            message.senderID = String(object.senderID);\n        if (object.senderCounter != null)\n            message.senderCounter = object.senderCounter >>> 0;\n        if (object.vcKeys) {\n            if (!Array.isArray(object.vcKeys))\n                throw TypeError(\".CRDTMessageMetaMessage.vcKeys: array expected\");\n            message.vcKeys = [];\n            for (let i = 0; i < object.vcKeys.length; ++i)\n                message.vcKeys[i] = String(object.vcKeys[i]);\n        }\n        if (object.vcValues) {\n            if (!Array.isArray(object.vcValues))\n                throw TypeError(\".CRDTMessageMetaMessage.vcValues: array expected\");\n            message.vcValues = [];\n            for (let i = 0; i < object.vcValues.length; ++i)\n                message.vcValues[i] = object.vcValues[i] >>> 0;\n        }\n        if (object.maximalVcKeyCount != null)\n            message.maximalVcKeyCount = object.maximalVcKeyCount >>> 0;\n        if (object.wallClockTime != null)\n            if ($util.Long)\n                (message.wallClockTime = $util.Long.fromValue(object.wallClockTime)).unsigned = true;\n            else if (typeof object.wallClockTime === \"string\")\n                message.wallClockTime = parseInt(object.wallClockTime, 10);\n            else if (typeof object.wallClockTime === \"number\")\n                message.wallClockTime = object.wallClockTime;\n            else if (typeof object.wallClockTime === \"object\")\n                message.wallClockTime = new $util.LongBits(object.wallClockTime.low >>> 0, object.wallClockTime.high >>> 0).toNumber(true);\n        if (object.lamportTimestamp != null)\n            if ($util.Long)\n                (message.lamportTimestamp = $util.Long.fromValue(object.lamportTimestamp)).unsigned = true;\n            else if (typeof object.lamportTimestamp === \"string\")\n                message.lamportTimestamp = parseInt(object.lamportTimestamp, 10);\n            else if (typeof object.lamportTimestamp === \"number\")\n                message.lamportTimestamp = object.lamportTimestamp;\n            else if (typeof object.lamportTimestamp === \"object\")\n                message.lamportTimestamp = new $util.LongBits(object.lamportTimestamp.low >>> 0, object.lamportTimestamp.high >>> 0).toNumber(true);\n        if (object.encodedVcKeys) {\n            if (!Array.isArray(object.encodedVcKeys))\n                throw TypeError(\".CRDTMessageMetaMessage.encodedVcKeys: array expected\");\n            message.encodedVcKeys = [];\n            for (let i = 0; i < object.encodedVcKeys.length; ++i)\n                message.encodedVcKeys[i] = object.encodedVcKeys[i] >>> 0;\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a CRDTMessageMetaMessage message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof CRDTMessageMetaMessage\n     * @static\n     * @param {CRDTMessageMetaMessage} message CRDTMessageMetaMessage\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    CRDTMessageMetaMessage.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults) {\n            object.vcKeys = [];\n            object.vcValues = [];\n            object.encodedVcKeys = [];\n        }\n        if (options.defaults) {\n            object.senderID = \"\";\n            object.senderCounter = 0;\n            object.maximalVcKeyCount = 0;\n            if ($util.Long) {\n                let long = new $util.Long(0, 0, true);\n                object.wallClockTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.wallClockTime = options.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                let long = new $util.Long(0, 0, true);\n                object.lamportTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.lamportTimestamp = options.longs === String ? \"0\" : 0;\n        }\n        if (message.senderID != null && message.hasOwnProperty(\"senderID\"))\n            object.senderID = message.senderID;\n        if (message.senderCounter != null && message.hasOwnProperty(\"senderCounter\"))\n            object.senderCounter = message.senderCounter;\n        if (message.vcKeys && message.vcKeys.length) {\n            object.vcKeys = [];\n            for (let j = 0; j < message.vcKeys.length; ++j)\n                object.vcKeys[j] = message.vcKeys[j];\n        }\n        if (message.vcValues && message.vcValues.length) {\n            object.vcValues = [];\n            for (let j = 0; j < message.vcValues.length; ++j)\n                object.vcValues[j] = message.vcValues[j];\n        }\n        if (message.maximalVcKeyCount != null && message.hasOwnProperty(\"maximalVcKeyCount\"))\n            object.maximalVcKeyCount = message.maximalVcKeyCount;\n        if (message.wallClockTime != null && message.hasOwnProperty(\"wallClockTime\"))\n            if (typeof message.wallClockTime === \"number\")\n                object.wallClockTime = options.longs === String ? String(message.wallClockTime) : message.wallClockTime;\n            else\n                object.wallClockTime = options.longs === String ? $util.Long.prototype.toString.call(message.wallClockTime) : options.longs === Number ? new $util.LongBits(message.wallClockTime.low >>> 0, message.wallClockTime.high >>> 0).toNumber(true) : message.wallClockTime;\n        if (message.lamportTimestamp != null && message.hasOwnProperty(\"lamportTimestamp\"))\n            if (typeof message.lamportTimestamp === \"number\")\n                object.lamportTimestamp = options.longs === String ? String(message.lamportTimestamp) : message.lamportTimestamp;\n            else\n                object.lamportTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.lamportTimestamp) : options.longs === Number ? new $util.LongBits(message.lamportTimestamp.low >>> 0, message.lamportTimestamp.high >>> 0).toNumber(true) : message.lamportTimestamp;\n        if (message.encodedVcKeys && message.encodedVcKeys.length) {\n            object.encodedVcKeys = [];\n            for (let j = 0; j < message.encodedVcKeys.length; ++j)\n                object.encodedVcKeys[j] = message.encodedVcKeys[j];\n        }\n        return object;\n    };\n\n    /**\n     * Converts this CRDTMessageMetaMessage to JSON.\n     * @function toJSON\n     * @memberof CRDTMessageMetaMessage\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    CRDTMessageMetaMessage.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return CRDTMessageMetaMessage;\n})();\n\nexport const CausalMessageBufferSave = /*@__PURE__*/ (() => {\n\n    /**\n     * Properties of a CausalMessageBufferSave.\n     * @exports ICausalMessageBufferSave\n     * @interface ICausalMessageBufferSave\n     * @property {Array.<string>|null} [vcKeys] CausalMessageBufferSave vcKeys\n     * @property {Array.<number|Long>|null} [vcValues] CausalMessageBufferSave vcValues\n     * @property {Array.<string>|null} [maximalVcKeys] CausalMessageBufferSave maximalVcKeys\n     * @property {number|Long} lamportTimestamp CausalMessageBufferSave lamportTimestamp\n     * @property {Array.<Uint8Array>|null} [bufferMessages] CausalMessageBufferSave bufferMessages\n     */\n\n    /**\n     * Constructs a new CausalMessageBufferSave.\n     * @exports CausalMessageBufferSave\n     * @classdesc Represents a CausalMessageBufferSave.\n     * @implements ICausalMessageBufferSave\n     * @constructor\n     * @param {ICausalMessageBufferSave=} [properties] Properties to set\n     */\n    function CausalMessageBufferSave(properties) {\n        this.vcKeys = [];\n        this.vcValues = [];\n        this.maximalVcKeys = [];\n        this.bufferMessages = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * CausalMessageBufferSave vcKeys.\n     * @member {Array.<string>} vcKeys\n     * @memberof CausalMessageBufferSave\n     * @instance\n     */\n    CausalMessageBufferSave.prototype.vcKeys = $util.emptyArray;\n\n    /**\n     * CausalMessageBufferSave vcValues.\n     * @member {Array.<number|Long>} vcValues\n     * @memberof CausalMessageBufferSave\n     * @instance\n     */\n    CausalMessageBufferSave.prototype.vcValues = $util.emptyArray;\n\n    /**\n     * CausalMessageBufferSave maximalVcKeys.\n     * @member {Array.<string>} maximalVcKeys\n     * @memberof CausalMessageBufferSave\n     * @instance\n     */\n    CausalMessageBufferSave.prototype.maximalVcKeys = $util.emptyArray;\n\n    /**\n     * CausalMessageBufferSave lamportTimestamp.\n     * @member {number|Long} lamportTimestamp\n     * @memberof CausalMessageBufferSave\n     * @instance\n     */\n    CausalMessageBufferSave.prototype.lamportTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * CausalMessageBufferSave bufferMessages.\n     * @member {Array.<Uint8Array>} bufferMessages\n     * @memberof CausalMessageBufferSave\n     * @instance\n     */\n    CausalMessageBufferSave.prototype.bufferMessages = $util.emptyArray;\n\n    /**\n     * Creates a new CausalMessageBufferSave instance using the specified properties.\n     * @function create\n     * @memberof CausalMessageBufferSave\n     * @static\n     * @param {ICausalMessageBufferSave=} [properties] Properties to set\n     * @returns {CausalMessageBufferSave} CausalMessageBufferSave instance\n     */\n    CausalMessageBufferSave.create = function create(properties) {\n        return new CausalMessageBufferSave(properties);\n    };\n\n    /**\n     * Encodes the specified CausalMessageBufferSave message. Does not implicitly {@link CausalMessageBufferSave.verify|verify} messages.\n     * @function encode\n     * @memberof CausalMessageBufferSave\n     * @static\n     * @param {ICausalMessageBufferSave} message CausalMessageBufferSave message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    CausalMessageBufferSave.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.vcKeys != null && message.vcKeys.length)\n            for (let i = 0; i < message.vcKeys.length; ++i)\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.vcKeys[i]);\n        if (message.vcValues != null && message.vcValues.length) {\n            writer.uint32(/* id 2, wireType 2 =*/18).fork();\n            for (let i = 0; i < message.vcValues.length; ++i)\n                writer.uint64(message.vcValues[i]);\n            writer.ldelim();\n        }\n        if (message.maximalVcKeys != null && message.maximalVcKeys.length)\n            for (let i = 0; i < message.maximalVcKeys.length; ++i)\n                writer.uint32(/* id 3, wireType 2 =*/26).string(message.maximalVcKeys[i]);\n        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.lamportTimestamp);\n        if (message.bufferMessages != null && message.bufferMessages.length)\n            for (let i = 0; i < message.bufferMessages.length; ++i)\n                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.bufferMessages[i]);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified CausalMessageBufferSave message, length delimited. Does not implicitly {@link CausalMessageBufferSave.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof CausalMessageBufferSave\n     * @static\n     * @param {ICausalMessageBufferSave} message CausalMessageBufferSave message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    CausalMessageBufferSave.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a CausalMessageBufferSave message from the specified reader or buffer.\n     * @function decode\n     * @memberof CausalMessageBufferSave\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CausalMessageBufferSave} CausalMessageBufferSave\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CausalMessageBufferSave.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new CausalMessageBufferSave();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                if (!(message.vcKeys && message.vcKeys.length))\n                    message.vcKeys = [];\n                message.vcKeys.push(reader.string());\n                break;\n            case 2:\n                if (!(message.vcValues && message.vcValues.length))\n                    message.vcValues = [];\n                if ((tag & 7) === 2) {\n                    let end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.vcValues.push(reader.uint64());\n                } else\n                    message.vcValues.push(reader.uint64());\n                break;\n            case 3:\n                if (!(message.maximalVcKeys && message.maximalVcKeys.length))\n                    message.maximalVcKeys = [];\n                message.maximalVcKeys.push(reader.string());\n                break;\n            case 4:\n                message.lamportTimestamp = reader.uint64();\n                break;\n            case 5:\n                if (!(message.bufferMessages && message.bufferMessages.length))\n                    message.bufferMessages = [];\n                message.bufferMessages.push(reader.bytes());\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        if (!message.hasOwnProperty(\"lamportTimestamp\"))\n            throw $util.ProtocolError(\"missing required 'lamportTimestamp'\", { instance: message });\n        return message;\n    };\n\n    /**\n     * Decodes a CausalMessageBufferSave message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof CausalMessageBufferSave\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {CausalMessageBufferSave} CausalMessageBufferSave\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CausalMessageBufferSave.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a CausalMessageBufferSave message.\n     * @function verify\n     * @memberof CausalMessageBufferSave\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    CausalMessageBufferSave.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.vcKeys != null && message.hasOwnProperty(\"vcKeys\")) {\n            if (!Array.isArray(message.vcKeys))\n                return \"vcKeys: array expected\";\n            for (let i = 0; i < message.vcKeys.length; ++i)\n                if (!$util.isString(message.vcKeys[i]))\n                    return \"vcKeys: string[] expected\";\n        }\n        if (message.vcValues != null && message.hasOwnProperty(\"vcValues\")) {\n            if (!Array.isArray(message.vcValues))\n                return \"vcValues: array expected\";\n            for (let i = 0; i < message.vcValues.length; ++i)\n                if (!$util.isInteger(message.vcValues[i]) && !(message.vcValues[i] && $util.isInteger(message.vcValues[i].low) && $util.isInteger(message.vcValues[i].high)))\n                    return \"vcValues: integer|Long[] expected\";\n        }\n        if (message.maximalVcKeys != null && message.hasOwnProperty(\"maximalVcKeys\")) {\n            if (!Array.isArray(message.maximalVcKeys))\n                return \"maximalVcKeys: array expected\";\n            for (let i = 0; i < message.maximalVcKeys.length; ++i)\n                if (!$util.isString(message.maximalVcKeys[i]))\n                    return \"maximalVcKeys: string[] expected\";\n        }\n        if (!$util.isInteger(message.lamportTimestamp) && !(message.lamportTimestamp && $util.isInteger(message.lamportTimestamp.low) && $util.isInteger(message.lamportTimestamp.high)))\n            return \"lamportTimestamp: integer|Long expected\";\n        if (message.bufferMessages != null && message.hasOwnProperty(\"bufferMessages\")) {\n            if (!Array.isArray(message.bufferMessages))\n                return \"bufferMessages: array expected\";\n            for (let i = 0; i < message.bufferMessages.length; ++i)\n                if (!(message.bufferMessages[i] && typeof message.bufferMessages[i].length === \"number\" || $util.isString(message.bufferMessages[i])))\n                    return \"bufferMessages: buffer[] expected\";\n        }\n        return null;\n    };\n\n    /**\n     * Creates a CausalMessageBufferSave message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof CausalMessageBufferSave\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {CausalMessageBufferSave} CausalMessageBufferSave\n     */\n    CausalMessageBufferSave.fromObject = function fromObject(object) {\n        if (object instanceof CausalMessageBufferSave)\n            return object;\n        let message = new CausalMessageBufferSave();\n        if (object.vcKeys) {\n            if (!Array.isArray(object.vcKeys))\n                throw TypeError(\".CausalMessageBufferSave.vcKeys: array expected\");\n            message.vcKeys = [];\n            for (let i = 0; i < object.vcKeys.length; ++i)\n                message.vcKeys[i] = String(object.vcKeys[i]);\n        }\n        if (object.vcValues) {\n            if (!Array.isArray(object.vcValues))\n                throw TypeError(\".CausalMessageBufferSave.vcValues: array expected\");\n            message.vcValues = [];\n            for (let i = 0; i < object.vcValues.length; ++i)\n                if ($util.Long)\n                    (message.vcValues[i] = $util.Long.fromValue(object.vcValues[i])).unsigned = true;\n                else if (typeof object.vcValues[i] === \"string\")\n                    message.vcValues[i] = parseInt(object.vcValues[i], 10);\n                else if (typeof object.vcValues[i] === \"number\")\n                    message.vcValues[i] = object.vcValues[i];\n                else if (typeof object.vcValues[i] === \"object\")\n                    message.vcValues[i] = new $util.LongBits(object.vcValues[i].low >>> 0, object.vcValues[i].high >>> 0).toNumber(true);\n        }\n        if (object.maximalVcKeys) {\n            if (!Array.isArray(object.maximalVcKeys))\n                throw TypeError(\".CausalMessageBufferSave.maximalVcKeys: array expected\");\n            message.maximalVcKeys = [];\n            for (let i = 0; i < object.maximalVcKeys.length; ++i)\n                message.maximalVcKeys[i] = String(object.maximalVcKeys[i]);\n        }\n        if (object.lamportTimestamp != null)\n            if ($util.Long)\n                (message.lamportTimestamp = $util.Long.fromValue(object.lamportTimestamp)).unsigned = true;\n            else if (typeof object.lamportTimestamp === \"string\")\n                message.lamportTimestamp = parseInt(object.lamportTimestamp, 10);\n            else if (typeof object.lamportTimestamp === \"number\")\n                message.lamportTimestamp = object.lamportTimestamp;\n            else if (typeof object.lamportTimestamp === \"object\")\n                message.lamportTimestamp = new $util.LongBits(object.lamportTimestamp.low >>> 0, object.lamportTimestamp.high >>> 0).toNumber(true);\n        if (object.bufferMessages) {\n            if (!Array.isArray(object.bufferMessages))\n                throw TypeError(\".CausalMessageBufferSave.bufferMessages: array expected\");\n            message.bufferMessages = [];\n            for (let i = 0; i < object.bufferMessages.length; ++i)\n                if (typeof object.bufferMessages[i] === \"string\")\n                    $util.base64.decode(object.bufferMessages[i], message.bufferMessages[i] = $util.newBuffer($util.base64.length(object.bufferMessages[i])), 0);\n                else if (object.bufferMessages[i].length)\n                    message.bufferMessages[i] = object.bufferMessages[i];\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a CausalMessageBufferSave message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof CausalMessageBufferSave\n     * @static\n     * @param {CausalMessageBufferSave} message CausalMessageBufferSave\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    CausalMessageBufferSave.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults) {\n            object.vcKeys = [];\n            object.vcValues = [];\n            object.maximalVcKeys = [];\n            object.bufferMessages = [];\n        }\n        if (options.defaults)\n            if ($util.Long) {\n                let long = new $util.Long(0, 0, true);\n                object.lamportTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.lamportTimestamp = options.longs === String ? \"0\" : 0;\n        if (message.vcKeys && message.vcKeys.length) {\n            object.vcKeys = [];\n            for (let j = 0; j < message.vcKeys.length; ++j)\n                object.vcKeys[j] = message.vcKeys[j];\n        }\n        if (message.vcValues && message.vcValues.length) {\n            object.vcValues = [];\n            for (let j = 0; j < message.vcValues.length; ++j)\n                if (typeof message.vcValues[j] === \"number\")\n                    object.vcValues[j] = options.longs === String ? String(message.vcValues[j]) : message.vcValues[j];\n                else\n                    object.vcValues[j] = options.longs === String ? $util.Long.prototype.toString.call(message.vcValues[j]) : options.longs === Number ? new $util.LongBits(message.vcValues[j].low >>> 0, message.vcValues[j].high >>> 0).toNumber(true) : message.vcValues[j];\n        }\n        if (message.maximalVcKeys && message.maximalVcKeys.length) {\n            object.maximalVcKeys = [];\n            for (let j = 0; j < message.maximalVcKeys.length; ++j)\n                object.maximalVcKeys[j] = message.maximalVcKeys[j];\n        }\n        if (message.lamportTimestamp != null && message.hasOwnProperty(\"lamportTimestamp\"))\n            if (typeof message.lamportTimestamp === \"number\")\n                object.lamportTimestamp = options.longs === String ? String(message.lamportTimestamp) : message.lamportTimestamp;\n            else\n                object.lamportTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.lamportTimestamp) : options.longs === Number ? new $util.LongBits(message.lamportTimestamp.low >>> 0, message.lamportTimestamp.high >>> 0).toNumber(true) : message.lamportTimestamp;\n        if (message.bufferMessages && message.bufferMessages.length) {\n            object.bufferMessages = [];\n            for (let j = 0; j < message.bufferMessages.length; ++j)\n                object.bufferMessages[j] = options.bytes === String ? $util.base64.encode(message.bufferMessages[j], 0, message.bufferMessages[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.bufferMessages[j]) : message.bufferMessages[j];\n        }\n        return object;\n    };\n\n    /**\n     * Converts this CausalMessageBufferSave to JSON.\n     * @function toJSON\n     * @memberof CausalMessageBufferSave\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    CausalMessageBufferSave.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return CausalMessageBufferSave;\n})();\n\nexport const CounterMessage = /*@__PURE__*/ (() => {\n\n    /**\n     * Properties of a CounterMessage.\n     * @exports ICounterMessage\n     * @interface ICounterMessage\n     * @property {number|Long|null} [arg] CounterMessage arg\n     */\n\n    /**\n     * Constructs a new CounterMessage.\n     * @exports CounterMessage\n     * @classdesc Represents a CounterMessage.\n     * @implements ICounterMessage\n     * @constructor\n     * @param {ICounterMessage=} [properties] Properties to set\n     */\n    function CounterMessage(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * CounterMessage arg.\n     * @member {number|Long} arg\n     * @memberof CounterMessage\n     * @instance\n     */\n    CounterMessage.prototype.arg = $util.Long ? $util.Long.fromBits(1,0,false) : 1;\n\n    /**\n     * Creates a new CounterMessage instance using the specified properties.\n     * @function create\n     * @memberof CounterMessage\n     * @static\n     * @param {ICounterMessage=} [properties] Properties to set\n     * @returns {CounterMessage} CounterMessage instance\n     */\n    CounterMessage.create = function create(properties) {\n        return new CounterMessage(properties);\n    };\n\n    /**\n     * Encodes the specified CounterMessage message. Does not implicitly {@link CounterMessage.verify|verify} messages.\n     * @function encode\n     * @memberof CounterMessage\n     * @static\n     * @param {ICounterMessage} message CounterMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    CounterMessage.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.arg != null && Object.hasOwnProperty.call(message, \"arg\"))\n            writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.arg);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified CounterMessage message, length delimited. Does not implicitly {@link CounterMessage.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof CounterMessage\n     * @static\n     * @param {ICounterMessage} message CounterMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    CounterMessage.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a CounterMessage message from the specified reader or buffer.\n     * @function decode\n     * @memberof CounterMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CounterMessage} CounterMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CounterMessage.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new CounterMessage();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.arg = reader.sint64();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a CounterMessage message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof CounterMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {CounterMessage} CounterMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CounterMessage.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a CounterMessage message.\n     * @function verify\n     * @memberof CounterMessage\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    CounterMessage.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.arg != null && message.hasOwnProperty(\"arg\"))\n            if (!$util.isInteger(message.arg) && !(message.arg && $util.isInteger(message.arg.low) && $util.isInteger(message.arg.high)))\n                return \"arg: integer|Long expected\";\n        return null;\n    };\n\n    /**\n     * Creates a CounterMessage message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof CounterMessage\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {CounterMessage} CounterMessage\n     */\n    CounterMessage.fromObject = function fromObject(object) {\n        if (object instanceof CounterMessage)\n            return object;\n        let message = new CounterMessage();\n        if (object.arg != null)\n            if ($util.Long)\n                (message.arg = $util.Long.fromValue(object.arg)).unsigned = false;\n            else if (typeof object.arg === \"string\")\n                message.arg = parseInt(object.arg, 10);\n            else if (typeof object.arg === \"number\")\n                message.arg = object.arg;\n            else if (typeof object.arg === \"object\")\n                message.arg = new $util.LongBits(object.arg.low >>> 0, object.arg.high >>> 0).toNumber();\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a CounterMessage message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof CounterMessage\n     * @static\n     * @param {CounterMessage} message CounterMessage\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    CounterMessage.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.defaults)\n            if ($util.Long) {\n                let long = new $util.Long(1, 0, false);\n                object.arg = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.arg = options.longs === String ? \"1\" : 1;\n        if (message.arg != null && message.hasOwnProperty(\"arg\"))\n            if (typeof message.arg === \"number\")\n                object.arg = options.longs === String ? String(message.arg) : message.arg;\n            else\n                object.arg = options.longs === String ? $util.Long.prototype.toString.call(message.arg) : options.longs === Number ? new $util.LongBits(message.arg.low >>> 0, message.arg.high >>> 0).toNumber() : message.arg;\n        return object;\n    };\n\n    /**\n     * Converts this CounterMessage to JSON.\n     * @function toJSON\n     * @memberof CounterMessage\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    CounterMessage.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return CounterMessage;\n})();\n\nexport const CounterSave = /*@__PURE__*/ (() => {\n\n    /**\n     * Properties of a CounterSave.\n     * @exports ICounterSave\n     * @interface ICounterSave\n     * @property {Object.<string,number|Long>|null} [p] CounterSave p\n     * @property {Object.<string,number|Long>|null} [n] CounterSave n\n     */\n\n    /**\n     * Constructs a new CounterSave.\n     * @exports CounterSave\n     * @classdesc Represents a CounterSave.\n     * @implements ICounterSave\n     * @constructor\n     * @param {ICounterSave=} [properties] Properties to set\n     */\n    function CounterSave(properties) {\n        this.p = {};\n        this.n = {};\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * CounterSave p.\n     * @member {Object.<string,number|Long>} p\n     * @memberof CounterSave\n     * @instance\n     */\n    CounterSave.prototype.p = $util.emptyObject;\n\n    /**\n     * CounterSave n.\n     * @member {Object.<string,number|Long>} n\n     * @memberof CounterSave\n     * @instance\n     */\n    CounterSave.prototype.n = $util.emptyObject;\n\n    /**\n     * Creates a new CounterSave instance using the specified properties.\n     * @function create\n     * @memberof CounterSave\n     * @static\n     * @param {ICounterSave=} [properties] Properties to set\n     * @returns {CounterSave} CounterSave instance\n     */\n    CounterSave.create = function create(properties) {\n        return new CounterSave(properties);\n    };\n\n    /**\n     * Encodes the specified CounterSave message. Does not implicitly {@link CounterSave.verify|verify} messages.\n     * @function encode\n     * @memberof CounterSave\n     * @static\n     * @param {ICounterSave} message CounterSave message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    CounterSave.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.p != null && Object.hasOwnProperty.call(message, \"p\"))\n            for (let keys = Object.keys(message.p), i = 0; i < keys.length; ++i)\n                writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).uint64(message.p[keys[i]]).ldelim();\n        if (message.n != null && Object.hasOwnProperty.call(message, \"n\"))\n            for (let keys = Object.keys(message.n), i = 0; i < keys.length; ++i)\n                writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).uint64(message.n[keys[i]]).ldelim();\n        return writer;\n    };\n\n    /**\n     * Encodes the specified CounterSave message, length delimited. Does not implicitly {@link CounterSave.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof CounterSave\n     * @static\n     * @param {ICounterSave} message CounterSave message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    CounterSave.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a CounterSave message from the specified reader or buffer.\n     * @function decode\n     * @memberof CounterSave\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CounterSave} CounterSave\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CounterSave.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new CounterSave(), key;\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                reader.skip().pos++;\n                if (message.p === $util.emptyObject)\n                    message.p = {};\n                key = reader.string();\n                reader.pos++;\n                message.p[key] = reader.uint64();\n                break;\n            case 2:\n                reader.skip().pos++;\n                if (message.n === $util.emptyObject)\n                    message.n = {};\n                key = reader.string();\n                reader.pos++;\n                message.n[key] = reader.uint64();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a CounterSave message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof CounterSave\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {CounterSave} CounterSave\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CounterSave.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a CounterSave message.\n     * @function verify\n     * @memberof CounterSave\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    CounterSave.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.p != null && message.hasOwnProperty(\"p\")) {\n            if (!$util.isObject(message.p))\n                return \"p: object expected\";\n            let key = Object.keys(message.p);\n            for (let i = 0; i < key.length; ++i)\n                if (!$util.isInteger(message.p[key[i]]) && !(message.p[key[i]] && $util.isInteger(message.p[key[i]].low) && $util.isInteger(message.p[key[i]].high)))\n                    return \"p: integer|Long{k:string} expected\";\n        }\n        if (message.n != null && message.hasOwnProperty(\"n\")) {\n            if (!$util.isObject(message.n))\n                return \"n: object expected\";\n            let key = Object.keys(message.n);\n            for (let i = 0; i < key.length; ++i)\n                if (!$util.isInteger(message.n[key[i]]) && !(message.n[key[i]] && $util.isInteger(message.n[key[i]].low) && $util.isInteger(message.n[key[i]].high)))\n                    return \"n: integer|Long{k:string} expected\";\n        }\n        return null;\n    };\n\n    /**\n     * Creates a CounterSave message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof CounterSave\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {CounterSave} CounterSave\n     */\n    CounterSave.fromObject = function fromObject(object) {\n        if (object instanceof CounterSave)\n            return object;\n        let message = new CounterSave();\n        if (object.p) {\n            if (typeof object.p !== \"object\")\n                throw TypeError(\".CounterSave.p: object expected\");\n            message.p = {};\n            for (let keys = Object.keys(object.p), i = 0; i < keys.length; ++i)\n                if ($util.Long)\n                    (message.p[keys[i]] = $util.Long.fromValue(object.p[keys[i]])).unsigned = true;\n                else if (typeof object.p[keys[i]] === \"string\")\n                    message.p[keys[i]] = parseInt(object.p[keys[i]], 10);\n                else if (typeof object.p[keys[i]] === \"number\")\n                    message.p[keys[i]] = object.p[keys[i]];\n                else if (typeof object.p[keys[i]] === \"object\")\n                    message.p[keys[i]] = new $util.LongBits(object.p[keys[i]].low >>> 0, object.p[keys[i]].high >>> 0).toNumber(true);\n        }\n        if (object.n) {\n            if (typeof object.n !== \"object\")\n                throw TypeError(\".CounterSave.n: object expected\");\n            message.n = {};\n            for (let keys = Object.keys(object.n), i = 0; i < keys.length; ++i)\n                if ($util.Long)\n                    (message.n[keys[i]] = $util.Long.fromValue(object.n[keys[i]])).unsigned = true;\n                else if (typeof object.n[keys[i]] === \"string\")\n                    message.n[keys[i]] = parseInt(object.n[keys[i]], 10);\n                else if (typeof object.n[keys[i]] === \"number\")\n                    message.n[keys[i]] = object.n[keys[i]];\n                else if (typeof object.n[keys[i]] === \"object\")\n                    message.n[keys[i]] = new $util.LongBits(object.n[keys[i]].low >>> 0, object.n[keys[i]].high >>> 0).toNumber(true);\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a CounterSave message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof CounterSave\n     * @static\n     * @param {CounterSave} message CounterSave\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    CounterSave.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.objects || options.defaults) {\n            object.p = {};\n            object.n = {};\n        }\n        let keys2;\n        if (message.p && (keys2 = Object.keys(message.p)).length) {\n            object.p = {};\n            for (let j = 0; j < keys2.length; ++j)\n                if (typeof message.p[keys2[j]] === \"number\")\n                    object.p[keys2[j]] = options.longs === String ? String(message.p[keys2[j]]) : message.p[keys2[j]];\n                else\n                    object.p[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.p[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.p[keys2[j]].low >>> 0, message.p[keys2[j]].high >>> 0).toNumber(true) : message.p[keys2[j]];\n        }\n        if (message.n && (keys2 = Object.keys(message.n)).length) {\n            object.n = {};\n            for (let j = 0; j < keys2.length; ++j)\n                if (typeof message.n[keys2[j]] === \"number\")\n                    object.n[keys2[j]] = options.longs === String ? String(message.n[keys2[j]]) : message.n[keys2[j]];\n                else\n                    object.n[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.n[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.n[keys2[j]].low >>> 0, message.n[keys2[j]].high >>> 0).toNumber(true) : message.n[keys2[j]];\n        }\n        return object;\n    };\n\n    /**\n     * Converts this CounterSave to JSON.\n     * @function toJSON\n     * @memberof CounterSave\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    CounterSave.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return CounterSave;\n})();\n\nexport const PresenceSetMessage = /*@__PURE__*/ (() => {\n\n    /**\n     * Properties of a PresenceSetMessage.\n     * @exports IPresenceSetMessage\n     * @interface IPresenceSetMessage\n     * @property {Uint8Array} value PresenceSetMessage value\n     * @property {boolean|null} [isJoin] PresenceSetMessage isJoin\n     * @property {boolean|null} [isResponse] PresenceSetMessage isResponse\n     */\n\n    /**\n     * Constructs a new PresenceSetMessage.\n     * @exports PresenceSetMessage\n     * @classdesc Represents a PresenceSetMessage.\n     * @implements IPresenceSetMessage\n     * @constructor\n     * @param {IPresenceSetMessage=} [properties] Properties to set\n     */\n    function PresenceSetMessage(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * PresenceSetMessage value.\n     * @member {Uint8Array} value\n     * @memberof PresenceSetMessage\n     * @instance\n     */\n    PresenceSetMessage.prototype.value = $util.newBuffer([]);\n\n    /**\n     * PresenceSetMessage isJoin.\n     * @member {boolean} isJoin\n     * @memberof PresenceSetMessage\n     * @instance\n     */\n    PresenceSetMessage.prototype.isJoin = false;\n\n    /**\n     * PresenceSetMessage isResponse.\n     * @member {boolean} isResponse\n     * @memberof PresenceSetMessage\n     * @instance\n     */\n    PresenceSetMessage.prototype.isResponse = false;\n\n    /**\n     * Creates a new PresenceSetMessage instance using the specified properties.\n     * @function create\n     * @memberof PresenceSetMessage\n     * @static\n     * @param {IPresenceSetMessage=} [properties] Properties to set\n     * @returns {PresenceSetMessage} PresenceSetMessage instance\n     */\n    PresenceSetMessage.create = function create(properties) {\n        return new PresenceSetMessage(properties);\n    };\n\n    /**\n     * Encodes the specified PresenceSetMessage message. Does not implicitly {@link PresenceSetMessage.verify|verify} messages.\n     * @function encode\n     * @memberof PresenceSetMessage\n     * @static\n     * @param {IPresenceSetMessage} message PresenceSetMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    PresenceSetMessage.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.value);\n        if (message.isJoin != null && Object.hasOwnProperty.call(message, \"isJoin\"))\n            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isJoin);\n        if (message.isResponse != null && Object.hasOwnProperty.call(message, \"isResponse\"))\n            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isResponse);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified PresenceSetMessage message, length delimited. Does not implicitly {@link PresenceSetMessage.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof PresenceSetMessage\n     * @static\n     * @param {IPresenceSetMessage} message PresenceSetMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    PresenceSetMessage.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a PresenceSetMessage message from the specified reader or buffer.\n     * @function decode\n     * @memberof PresenceSetMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {PresenceSetMessage} PresenceSetMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    PresenceSetMessage.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new PresenceSetMessage();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.value = reader.bytes();\n                break;\n            case 2:\n                message.isJoin = reader.bool();\n                break;\n            case 3:\n                message.isResponse = reader.bool();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        if (!message.hasOwnProperty(\"value\"))\n            throw $util.ProtocolError(\"missing required 'value'\", { instance: message });\n        return message;\n    };\n\n    /**\n     * Decodes a PresenceSetMessage message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof PresenceSetMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {PresenceSetMessage} PresenceSetMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    PresenceSetMessage.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a PresenceSetMessage message.\n     * @function verify\n     * @memberof PresenceSetMessage\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    PresenceSetMessage.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (!(message.value && typeof message.value.length === \"number\" || $util.isString(message.value)))\n            return \"value: buffer expected\";\n        if (message.isJoin != null && message.hasOwnProperty(\"isJoin\"))\n            if (typeof message.isJoin !== \"boolean\")\n                return \"isJoin: boolean expected\";\n        if (message.isResponse != null && message.hasOwnProperty(\"isResponse\"))\n            if (typeof message.isResponse !== \"boolean\")\n                return \"isResponse: boolean expected\";\n        return null;\n    };\n\n    /**\n     * Creates a PresenceSetMessage message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof PresenceSetMessage\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {PresenceSetMessage} PresenceSetMessage\n     */\n    PresenceSetMessage.fromObject = function fromObject(object) {\n        if (object instanceof PresenceSetMessage)\n            return object;\n        let message = new PresenceSetMessage();\n        if (object.value != null)\n            if (typeof object.value === \"string\")\n                $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);\n            else if (object.value.length)\n                message.value = object.value;\n        if (object.isJoin != null)\n            message.isJoin = Boolean(object.isJoin);\n        if (object.isResponse != null)\n            message.isResponse = Boolean(object.isResponse);\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a PresenceSetMessage message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof PresenceSetMessage\n     * @static\n     * @param {PresenceSetMessage} message PresenceSetMessage\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    PresenceSetMessage.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.defaults) {\n            if (options.bytes === String)\n                object.value = \"\";\n            else {\n                object.value = [];\n                if (options.bytes !== Array)\n                    object.value = $util.newBuffer(object.value);\n            }\n            object.isJoin = false;\n            object.isResponse = false;\n        }\n        if (message.value != null && message.hasOwnProperty(\"value\"))\n            object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;\n        if (message.isJoin != null && message.hasOwnProperty(\"isJoin\"))\n            object.isJoin = message.isJoin;\n        if (message.isResponse != null && message.hasOwnProperty(\"isResponse\"))\n            object.isResponse = message.isResponse;\n        return object;\n    };\n\n    /**\n     * Converts this PresenceSetMessage to JSON.\n     * @function toJSON\n     * @memberof PresenceSetMessage\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    PresenceSetMessage.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return PresenceSetMessage;\n})();\n\nexport const PresenceRequestMessage = /*@__PURE__*/ (() => {\n\n    /**\n     * Properties of a PresenceRequestMessage.\n     * @exports IPresenceRequestMessage\n     * @interface IPresenceRequestMessage\n     * @property {string} replicaID PresenceRequestMessage replicaID\n     */\n\n    /**\n     * Constructs a new PresenceRequestMessage.\n     * @exports PresenceRequestMessage\n     * @classdesc Represents a PresenceRequestMessage.\n     * @implements IPresenceRequestMessage\n     * @constructor\n     * @param {IPresenceRequestMessage=} [properties] Properties to set\n     */\n    function PresenceRequestMessage(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * PresenceRequestMessage replicaID.\n     * @member {string} replicaID\n     * @memberof PresenceRequestMessage\n     * @instance\n     */\n    PresenceRequestMessage.prototype.replicaID = \"\";\n\n    /**\n     * Creates a new PresenceRequestMessage instance using the specified properties.\n     * @function create\n     * @memberof PresenceRequestMessage\n     * @static\n     * @param {IPresenceRequestMessage=} [properties] Properties to set\n     * @returns {PresenceRequestMessage} PresenceRequestMessage instance\n     */\n    PresenceRequestMessage.create = function create(properties) {\n        return new PresenceRequestMessage(properties);\n    };\n\n    /**\n     * Encodes the specified PresenceRequestMessage message. Does not implicitly {@link PresenceRequestMessage.verify|verify} messages.\n     * @function encode\n     * @memberof PresenceRequestMessage\n     * @static\n     * @param {IPresenceRequestMessage} message PresenceRequestMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    PresenceRequestMessage.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        writer.uint32(/* id 1, wireType 2 =*/10).string(message.replicaID);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified PresenceRequestMessage message, length delimited. Does not implicitly {@link PresenceRequestMessage.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof PresenceRequestMessage\n     * @static\n     * @param {IPresenceRequestMessage} message PresenceRequestMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    PresenceRequestMessage.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a PresenceRequestMessage message from the specified reader or buffer.\n     * @function decode\n     * @memberof PresenceRequestMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {PresenceRequestMessage} PresenceRequestMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    PresenceRequestMessage.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new PresenceRequestMessage();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.replicaID = reader.string();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        if (!message.hasOwnProperty(\"replicaID\"))\n            throw $util.ProtocolError(\"missing required 'replicaID'\", { instance: message });\n        return message;\n    };\n\n    /**\n     * Decodes a PresenceRequestMessage message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof PresenceRequestMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {PresenceRequestMessage} PresenceRequestMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    PresenceRequestMessage.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a PresenceRequestMessage message.\n     * @function verify\n     * @memberof PresenceRequestMessage\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    PresenceRequestMessage.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (!$util.isString(message.replicaID))\n            return \"replicaID: string expected\";\n        return null;\n    };\n\n    /**\n     * Creates a PresenceRequestMessage message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof PresenceRequestMessage\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {PresenceRequestMessage} PresenceRequestMessage\n     */\n    PresenceRequestMessage.fromObject = function fromObject(object) {\n        if (object instanceof PresenceRequestMessage)\n            return object;\n        let message = new PresenceRequestMessage();\n        if (object.replicaID != null)\n            message.replicaID = String(object.replicaID);\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a PresenceRequestMessage message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof PresenceRequestMessage\n     * @static\n     * @param {PresenceRequestMessage} message PresenceRequestMessage\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    PresenceRequestMessage.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.defaults)\n            object.replicaID = \"\";\n        if (message.replicaID != null && message.hasOwnProperty(\"replicaID\"))\n            object.replicaID = message.replicaID;\n        return object;\n    };\n\n    /**\n     * Converts this PresenceRequestMessage to JSON.\n     * @function toJSON\n     * @memberof PresenceRequestMessage\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    PresenceRequestMessage.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return PresenceRequestMessage;\n})();\n\nexport const PresenceMessage = /*@__PURE__*/ (() => {\n\n    /**\n     * Properties of a PresenceMessage.\n     * @exports IPresenceMessage\n     * @interface IPresenceMessage\n     * @property {boolean|null} [heartbeat] PresenceMessage heartbeat\n     * @property {IPresenceSetMessage|null} [set] PresenceMessage set\n     * @property {Uint8Array|null} [update] PresenceMessage update\n     * @property {boolean|null} [disconnect] PresenceMessage disconnect\n     * @property {string|null} [request] PresenceMessage request\n     */\n\n    /**\n     * Constructs a new PresenceMessage.\n     * @exports PresenceMessage\n     * @classdesc Represents a PresenceMessage.\n     * @implements IPresenceMessage\n     * @constructor\n     * @param {IPresenceMessage=} [properties] Properties to set\n     */\n    function PresenceMessage(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * PresenceMessage heartbeat.\n     * @member {boolean} heartbeat\n     * @memberof PresenceMessage\n     * @instance\n     */\n    PresenceMessage.prototype.heartbeat = false;\n\n    /**\n     * PresenceMessage set.\n     * @member {IPresenceSetMessage|null|undefined} set\n     * @memberof PresenceMessage\n     * @instance\n     */\n    PresenceMessage.prototype.set = null;\n\n    /**\n     * PresenceMessage update.\n     * @member {Uint8Array} update\n     * @memberof PresenceMessage\n     * @instance\n     */\n    PresenceMessage.prototype.update = $util.newBuffer([]);\n\n    /**\n     * PresenceMessage disconnect.\n     * @member {boolean} disconnect\n     * @memberof PresenceMessage\n     * @instance\n     */\n    PresenceMessage.prototype.disconnect = false;\n\n    /**\n     * PresenceMessage request.\n     * @member {string} request\n     * @memberof PresenceMessage\n     * @instance\n     */\n    PresenceMessage.prototype.request = \"\";\n\n    // OneOf field names bound to virtual getters and setters\n    let $oneOfFields;\n\n    /**\n     * PresenceMessage type.\n     * @member {\"heartbeat\"|\"set\"|\"update\"|\"disconnect\"|\"request\"|undefined} type\n     * @memberof PresenceMessage\n     * @instance\n     */\n    Object.defineProperty(PresenceMessage.prototype, \"type\", {\n        get: $util.oneOfGetter($oneOfFields = [\"heartbeat\", \"set\", \"update\", \"disconnect\", \"request\"]),\n        set: $util.oneOfSetter($oneOfFields)\n    });\n\n    /**\n     * Creates a new PresenceMessage instance using the specified properties.\n     * @function create\n     * @memberof PresenceMessage\n     * @static\n     * @param {IPresenceMessage=} [properties] Properties to set\n     * @returns {PresenceMessage} PresenceMessage instance\n     */\n    PresenceMessage.create = function create(properties) {\n        return new PresenceMessage(properties);\n    };\n\n    /**\n     * Encodes the specified PresenceMessage message. Does not implicitly {@link PresenceMessage.verify|verify} messages.\n     * @function encode\n     * @memberof PresenceMessage\n     * @static\n     * @param {IPresenceMessage} message PresenceMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    PresenceMessage.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.heartbeat != null && Object.hasOwnProperty.call(message, \"heartbeat\"))\n            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.heartbeat);\n        if (message.set != null && Object.hasOwnProperty.call(message, \"set\"))\n            PresenceSetMessage.encode(message.set, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n        if (message.update != null && Object.hasOwnProperty.call(message, \"update\"))\n            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.update);\n        if (message.disconnect != null && Object.hasOwnProperty.call(message, \"disconnect\"))\n            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.disconnect);\n        if (message.request != null && Object.hasOwnProperty.call(message, \"request\"))\n            writer.uint32(/* id 5, wireType 2 =*/42).string(message.request);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified PresenceMessage message, length delimited. Does not implicitly {@link PresenceMessage.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof PresenceMessage\n     * @static\n     * @param {IPresenceMessage} message PresenceMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    PresenceMessage.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a PresenceMessage message from the specified reader or buffer.\n     * @function decode\n     * @memberof PresenceMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {PresenceMessage} PresenceMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    PresenceMessage.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new PresenceMessage();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.heartbeat = reader.bool();\n                break;\n            case 2:\n                message.set = PresenceSetMessage.decode(reader, reader.uint32());\n                break;\n            case 3:\n                message.update = reader.bytes();\n                break;\n            case 4:\n                message.disconnect = reader.bool();\n                break;\n            case 5:\n                message.request = reader.string();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a PresenceMessage message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof PresenceMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {PresenceMessage} PresenceMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    PresenceMessage.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a PresenceMessage message.\n     * @function verify\n     * @memberof PresenceMessage\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    PresenceMessage.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        let properties = {};\n        if (message.heartbeat != null && message.hasOwnProperty(\"heartbeat\")) {\n            properties.type = 1;\n            if (typeof message.heartbeat !== \"boolean\")\n                return \"heartbeat: boolean expected\";\n        }\n        if (message.set != null && message.hasOwnProperty(\"set\")) {\n            if (properties.type === 1)\n                return \"type: multiple values\";\n            properties.type = 1;\n            {\n                let error = PresenceSetMessage.verify(message.set);\n                if (error)\n                    return \"set.\" + error;\n            }\n        }\n        if (message.update != null && message.hasOwnProperty(\"update\")) {\n            if (properties.type === 1)\n                return \"type: multiple values\";\n            properties.type = 1;\n            if (!(message.update && typeof message.update.length === \"number\" || $util.isString(message.update)))\n                return \"update: buffer expected\";\n        }\n        if (message.disconnect != null && message.hasOwnProperty(\"disconnect\")) {\n            if (properties.type === 1)\n                return \"type: multiple values\";\n            properties.type = 1;\n            if (typeof message.disconnect !== \"boolean\")\n                return \"disconnect: boolean expected\";\n        }\n        if (message.request != null && message.hasOwnProperty(\"request\")) {\n            if (properties.type === 1)\n                return \"type: multiple values\";\n            properties.type = 1;\n            if (!$util.isString(message.request))\n                return \"request: string expected\";\n        }\n        return null;\n    };\n\n    /**\n     * Creates a PresenceMessage message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof PresenceMessage\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {PresenceMessage} PresenceMessage\n     */\n    PresenceMessage.fromObject = function fromObject(object) {\n        if (object instanceof PresenceMessage)\n            return object;\n        let message = new PresenceMessage();\n        if (object.heartbeat != null)\n            message.heartbeat = Boolean(object.heartbeat);\n        if (object.set != null) {\n            if (typeof object.set !== \"object\")\n                throw TypeError(\".PresenceMessage.set: object expected\");\n            message.set = PresenceSetMessage.fromObject(object.set);\n        }\n        if (object.update != null)\n            if (typeof object.update === \"string\")\n                $util.base64.decode(object.update, message.update = $util.newBuffer($util.base64.length(object.update)), 0);\n            else if (object.update.length)\n                message.update = object.update;\n        if (object.disconnect != null)\n            message.disconnect = Boolean(object.disconnect);\n        if (object.request != null)\n            message.request = String(object.request);\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a PresenceMessage message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof PresenceMessage\n     * @static\n     * @param {PresenceMessage} message PresenceMessage\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    PresenceMessage.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (message.heartbeat != null && message.hasOwnProperty(\"heartbeat\")) {\n            object.heartbeat = message.heartbeat;\n            if (options.oneofs)\n                object.type = \"heartbeat\";\n        }\n        if (message.set != null && message.hasOwnProperty(\"set\")) {\n            object.set = PresenceSetMessage.toObject(message.set, options);\n            if (options.oneofs)\n                object.type = \"set\";\n        }\n        if (message.update != null && message.hasOwnProperty(\"update\")) {\n            object.update = options.bytes === String ? $util.base64.encode(message.update, 0, message.update.length) : options.bytes === Array ? Array.prototype.slice.call(message.update) : message.update;\n            if (options.oneofs)\n                object.type = \"update\";\n        }\n        if (message.disconnect != null && message.hasOwnProperty(\"disconnect\")) {\n            object.disconnect = message.disconnect;\n            if (options.oneofs)\n                object.type = \"disconnect\";\n        }\n        if (message.request != null && message.hasOwnProperty(\"request\")) {\n            object.request = message.request;\n            if (options.oneofs)\n                object.type = \"request\";\n        }\n        return object;\n    };\n\n    /**\n     * Converts this PresenceMessage to JSON.\n     * @function toJSON\n     * @memberof PresenceMessage\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    PresenceMessage.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return PresenceMessage;\n})();\n\nexport const PresenceInfoSave = /*@__PURE__*/ (() => {\n\n    /**\n     * Properties of a PresenceInfoSave.\n     * @exports IPresenceInfoSave\n     * @interface IPresenceInfoSave\n     * @property {Uint8Array} value PresenceInfoSave value\n     * @property {number|Long} time PresenceInfoSave time\n     */\n\n    /**\n     * Constructs a new PresenceInfoSave.\n     * @exports PresenceInfoSave\n     * @classdesc Represents a PresenceInfoSave.\n     * @implements IPresenceInfoSave\n     * @constructor\n     * @param {IPresenceInfoSave=} [properties] Properties to set\n     */\n    function PresenceInfoSave(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * PresenceInfoSave value.\n     * @member {Uint8Array} value\n     * @memberof PresenceInfoSave\n     * @instance\n     */\n    PresenceInfoSave.prototype.value = $util.newBuffer([]);\n\n    /**\n     * PresenceInfoSave time.\n     * @member {number|Long} time\n     * @memberof PresenceInfoSave\n     * @instance\n     */\n    PresenceInfoSave.prototype.time = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * Creates a new PresenceInfoSave instance using the specified properties.\n     * @function create\n     * @memberof PresenceInfoSave\n     * @static\n     * @param {IPresenceInfoSave=} [properties] Properties to set\n     * @returns {PresenceInfoSave} PresenceInfoSave instance\n     */\n    PresenceInfoSave.create = function create(properties) {\n        return new PresenceInfoSave(properties);\n    };\n\n    /**\n     * Encodes the specified PresenceInfoSave message. Does not implicitly {@link PresenceInfoSave.verify|verify} messages.\n     * @function encode\n     * @memberof PresenceInfoSave\n     * @static\n     * @param {IPresenceInfoSave} message PresenceInfoSave message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    PresenceInfoSave.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.value);\n        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.time);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified PresenceInfoSave message, length delimited. Does not implicitly {@link PresenceInfoSave.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof PresenceInfoSave\n     * @static\n     * @param {IPresenceInfoSave} message PresenceInfoSave message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    PresenceInfoSave.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a PresenceInfoSave message from the specified reader or buffer.\n     * @function decode\n     * @memberof PresenceInfoSave\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {PresenceInfoSave} PresenceInfoSave\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    PresenceInfoSave.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new PresenceInfoSave();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.value = reader.bytes();\n                break;\n            case 2:\n                message.time = reader.uint64();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        if (!message.hasOwnProperty(\"value\"))\n            throw $util.ProtocolError(\"missing required 'value'\", { instance: message });\n        if (!message.hasOwnProperty(\"time\"))\n            throw $util.ProtocolError(\"missing required 'time'\", { instance: message });\n        return message;\n    };\n\n    /**\n     * Decodes a PresenceInfoSave message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof PresenceInfoSave\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {PresenceInfoSave} PresenceInfoSave\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    PresenceInfoSave.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a PresenceInfoSave message.\n     * @function verify\n     * @memberof PresenceInfoSave\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    PresenceInfoSave.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (!(message.value && typeof message.value.length === \"number\" || $util.isString(message.value)))\n            return \"value: buffer expected\";\n        if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))\n            return \"time: integer|Long expected\";\n        return null;\n    };\n\n    /**\n     * Creates a PresenceInfoSave message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof PresenceInfoSave\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {PresenceInfoSave} PresenceInfoSave\n     */\n    PresenceInfoSave.fromObject = function fromObject(object) {\n        if (object instanceof PresenceInfoSave)\n            return object;\n        let message = new PresenceInfoSave();\n        if (object.value != null)\n            if (typeof object.value === \"string\")\n                $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);\n            else if (object.value.length)\n                message.value = object.value;\n        if (object.time != null)\n            if ($util.Long)\n                (message.time = $util.Long.fromValue(object.time)).unsigned = true;\n            else if (typeof object.time === \"string\")\n                message.time = parseInt(object.time, 10);\n            else if (typeof object.time === \"number\")\n                message.time = object.time;\n            else if (typeof object.time === \"object\")\n                message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber(true);\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a PresenceInfoSave message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof PresenceInfoSave\n     * @static\n     * @param {PresenceInfoSave} message PresenceInfoSave\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    PresenceInfoSave.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.defaults) {\n            if (options.bytes === String)\n                object.value = \"\";\n            else {\n                object.value = [];\n                if (options.bytes !== Array)\n                    object.value = $util.newBuffer(object.value);\n            }\n            if ($util.Long) {\n                let long = new $util.Long(0, 0, true);\n                object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.time = options.longs === String ? \"0\" : 0;\n        }\n        if (message.value != null && message.hasOwnProperty(\"value\"))\n            object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;\n        if (message.time != null && message.hasOwnProperty(\"time\"))\n            if (typeof message.time === \"number\")\n                object.time = options.longs === String ? String(message.time) : message.time;\n            else\n                object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber(true) : message.time;\n        return object;\n    };\n\n    /**\n     * Converts this PresenceInfoSave to JSON.\n     * @function toJSON\n     * @memberof PresenceInfoSave\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    PresenceInfoSave.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return PresenceInfoSave;\n})();\n\nexport const PresenceSave = /*@__PURE__*/ (() => {\n\n    /**\n     * Properties of a PresenceSave.\n     * @exports IPresenceSave\n     * @interface IPresenceSave\n     * @property {Object.<string,IPresenceInfoSave>|null} [state] PresenceSave state\n     * @property {string} saverID PresenceSave saverID\n     */\n\n    /**\n     * Constructs a new PresenceSave.\n     * @exports PresenceSave\n     * @classdesc Represents a PresenceSave.\n     * @implements IPresenceSave\n     * @constructor\n     * @param {IPresenceSave=} [properties] Properties to set\n     */\n    function PresenceSave(properties) {\n        this.state = {};\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * PresenceSave state.\n     * @member {Object.<string,IPresenceInfoSave>} state\n     * @memberof PresenceSave\n     * @instance\n     */\n    PresenceSave.prototype.state = $util.emptyObject;\n\n    /**\n     * PresenceSave saverID.\n     * @member {string} saverID\n     * @memberof PresenceSave\n     * @instance\n     */\n    PresenceSave.prototype.saverID = \"\";\n\n    /**\n     * Creates a new PresenceSave instance using the specified properties.\n     * @function create\n     * @memberof PresenceSave\n     * @static\n     * @param {IPresenceSave=} [properties] Properties to set\n     * @returns {PresenceSave} PresenceSave instance\n     */\n    PresenceSave.create = function create(properties) {\n        return new PresenceSave(properties);\n    };\n\n    /**\n     * Encodes the specified PresenceSave message. Does not implicitly {@link PresenceSave.verify|verify} messages.\n     * @function encode\n     * @memberof PresenceSave\n     * @static\n     * @param {IPresenceSave} message PresenceSave message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    PresenceSave.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.state != null && Object.hasOwnProperty.call(message, \"state\"))\n            for (let keys = Object.keys(message.state), i = 0; i < keys.length; ++i) {\n                writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);\n                PresenceInfoSave.encode(message.state[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();\n            }\n        writer.uint32(/* id 2, wireType 2 =*/18).string(message.saverID);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified PresenceSave message, length delimited. Does not implicitly {@link PresenceSave.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof PresenceSave\n     * @static\n     * @param {IPresenceSave} message PresenceSave message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    PresenceSave.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a PresenceSave message from the specified reader or buffer.\n     * @function decode\n     * @memberof PresenceSave\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {PresenceSave} PresenceSave\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    PresenceSave.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new PresenceSave(), key;\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                reader.skip().pos++;\n                if (message.state === $util.emptyObject)\n                    message.state = {};\n                key = reader.string();\n                reader.pos++;\n                message.state[key] = PresenceInfoSave.decode(reader, reader.uint32());\n                break;\n            case 2:\n                message.saverID = reader.string();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        if (!message.hasOwnProperty(\"saverID\"))\n            throw $util.ProtocolError(\"missing required 'saverID'\", { instance: message });\n        return message;\n    };\n\n    /**\n     * Decodes a PresenceSave message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof PresenceSave\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {PresenceSave} PresenceSave\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    PresenceSave.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a PresenceSave message.\n     * @function verify\n     * @memberof PresenceSave\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    PresenceSave.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.state != null && message.hasOwnProperty(\"state\")) {\n            if (!$util.isObject(message.state))\n                return \"state: object expected\";\n            let key = Object.keys(message.state);\n            for (let i = 0; i < key.length; ++i) {\n                let error = PresenceInfoSave.verify(message.state[key[i]]);\n                if (error)\n                    return \"state.\" + error;\n            }\n        }\n        if (!$util.isString(message.saverID))\n            return \"saverID: string expected\";\n        return null;\n    };\n\n    /**\n     * Creates a PresenceSave message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof PresenceSave\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {PresenceSave} PresenceSave\n     */\n    PresenceSave.fromObject = function fromObject(object) {\n        if (object instanceof PresenceSave)\n            return object;\n        let message = new PresenceSave();\n        if (object.state) {\n            if (typeof object.state !== \"object\")\n                throw TypeError(\".PresenceSave.state: object expected\");\n            message.state = {};\n            for (let keys = Object.keys(object.state), i = 0; i < keys.length; ++i) {\n                if (typeof object.state[keys[i]] !== \"object\")\n                    throw TypeError(\".PresenceSave.state: object expected\");\n                message.state[keys[i]] = PresenceInfoSave.fromObject(object.state[keys[i]]);\n            }\n        }\n        if (object.saverID != null)\n            message.saverID = String(object.saverID);\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a PresenceSave message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof PresenceSave\n     * @static\n     * @param {PresenceSave} message PresenceSave\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    PresenceSave.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.objects || options.defaults)\n            object.state = {};\n        if (options.defaults)\n            object.saverID = \"\";\n        let keys2;\n        if (message.state && (keys2 = Object.keys(message.state)).length) {\n            object.state = {};\n            for (let j = 0; j < keys2.length; ++j)\n                object.state[keys2[j]] = PresenceInfoSave.toObject(message.state[keys2[j]], options);\n        }\n        if (message.saverID != null && message.hasOwnProperty(\"saverID\"))\n            object.saverID = message.saverID;\n        return object;\n    };\n\n    /**\n     * Converts this PresenceSave to JSON.\n     * @function toJSON\n     * @memberof PresenceSave\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    PresenceSave.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return PresenceSave;\n})();\n\nexport const MultiValueMapMessage = /*@__PURE__*/ (() => {\n\n    /**\n     * Properties of a MultiValueMapMessage.\n     * @exports IMultiValueMapMessage\n     * @interface IMultiValueMapMessage\n     * @property {Uint8Array} key MultiValueMapMessage key\n     * @property {Uint8Array|null} [value] MultiValueMapMessage value\n     */\n\n    /**\n     * Constructs a new MultiValueMapMessage.\n     * @exports MultiValueMapMessage\n     * @classdesc Represents a MultiValueMapMessage.\n     * @implements IMultiValueMapMessage\n     * @constructor\n     * @param {IMultiValueMapMessage=} [properties] Properties to set\n     */\n    function MultiValueMapMessage(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * MultiValueMapMessage key.\n     * @member {Uint8Array} key\n     * @memberof MultiValueMapMessage\n     * @instance\n     */\n    MultiValueMapMessage.prototype.key = $util.newBuffer([]);\n\n    /**\n     * MultiValueMapMessage value.\n     * @member {Uint8Array} value\n     * @memberof MultiValueMapMessage\n     * @instance\n     */\n    MultiValueMapMessage.prototype.value = $util.newBuffer([]);\n\n    /**\n     * Creates a new MultiValueMapMessage instance using the specified properties.\n     * @function create\n     * @memberof MultiValueMapMessage\n     * @static\n     * @param {IMultiValueMapMessage=} [properties] Properties to set\n     * @returns {MultiValueMapMessage} MultiValueMapMessage instance\n     */\n    MultiValueMapMessage.create = function create(properties) {\n        return new MultiValueMapMessage(properties);\n    };\n\n    /**\n     * Encodes the specified MultiValueMapMessage message. Does not implicitly {@link MultiValueMapMessage.verify|verify} messages.\n     * @function encode\n     * @memberof MultiValueMapMessage\n     * @static\n     * @param {IMultiValueMapMessage} message MultiValueMapMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    MultiValueMapMessage.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);\n        if (message.value != null && Object.hasOwnProperty.call(message, \"value\"))\n            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified MultiValueMapMessage message, length delimited. Does not implicitly {@link MultiValueMapMessage.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof MultiValueMapMessage\n     * @static\n     * @param {IMultiValueMapMessage} message MultiValueMapMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    MultiValueMapMessage.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a MultiValueMapMessage message from the specified reader or buffer.\n     * @function decode\n     * @memberof MultiValueMapMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {MultiValueMapMessage} MultiValueMapMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    MultiValueMapMessage.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new MultiValueMapMessage();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.key = reader.bytes();\n                break;\n            case 2:\n                message.value = reader.bytes();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        if (!message.hasOwnProperty(\"key\"))\n            throw $util.ProtocolError(\"missing required 'key'\", { instance: message });\n        return message;\n    };\n\n    /**\n     * Decodes a MultiValueMapMessage message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof MultiValueMapMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {MultiValueMapMessage} MultiValueMapMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    MultiValueMapMessage.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a MultiValueMapMessage message.\n     * @function verify\n     * @memberof MultiValueMapMessage\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    MultiValueMapMessage.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key)))\n            return \"key: buffer expected\";\n        if (message.value != null && message.hasOwnProperty(\"value\"))\n            if (!(message.value && typeof message.value.length === \"number\" || $util.isString(message.value)))\n                return \"value: buffer expected\";\n        return null;\n    };\n\n    /**\n     * Creates a MultiValueMapMessage message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof MultiValueMapMessage\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {MultiValueMapMessage} MultiValueMapMessage\n     */\n    MultiValueMapMessage.fromObject = function fromObject(object) {\n        if (object instanceof MultiValueMapMessage)\n            return object;\n        let message = new MultiValueMapMessage();\n        if (object.key != null)\n            if (typeof object.key === \"string\")\n                $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);\n            else if (object.key.length)\n                message.key = object.key;\n        if (object.value != null)\n            if (typeof object.value === \"string\")\n                $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);\n            else if (object.value.length)\n                message.value = object.value;\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a MultiValueMapMessage message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof MultiValueMapMessage\n     * @static\n     * @param {MultiValueMapMessage} message MultiValueMapMessage\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    MultiValueMapMessage.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.defaults) {\n            if (options.bytes === String)\n                object.key = \"\";\n            else {\n                object.key = [];\n                if (options.bytes !== Array)\n                    object.key = $util.newBuffer(object.key);\n            }\n            if (options.bytes === String)\n                object.value = \"\";\n            else {\n                object.value = [];\n                if (options.bytes !== Array)\n                    object.value = $util.newBuffer(object.value);\n            }\n        }\n        if (message.key != null && message.hasOwnProperty(\"key\"))\n            object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n        if (message.value != null && message.hasOwnProperty(\"value\"))\n            object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;\n        return object;\n    };\n\n    /**\n     * Converts this MultiValueMapMessage to JSON.\n     * @function toJSON\n     * @memberof MultiValueMapMessage\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    MultiValueMapMessage.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return MultiValueMapMessage;\n})();\n\nexport const MultiValueMapItemsSave = /*@__PURE__*/ (() => {\n\n    /**\n     * Properties of a MultiValueMapItemsSave.\n     * @exports IMultiValueMapItemsSave\n     * @interface IMultiValueMapItemsSave\n     * @property {Array.<Uint8Array>|null} [values] MultiValueMapItemsSave values\n     * @property {Array.<number>|null} [senders] MultiValueMapItemsSave senders\n     * @property {Array.<number>|null} [senderCounters] MultiValueMapItemsSave senderCounters\n     * @property {Array.<number|Long>|null} [wallClockTimes] MultiValueMapItemsSave wallClockTimes\n     * @property {Array.<number|Long>|null} [lamportTimestamps] MultiValueMapItemsSave lamportTimestamps\n     */\n\n    /**\n     * Constructs a new MultiValueMapItemsSave.\n     * @exports MultiValueMapItemsSave\n     * @classdesc Represents a MultiValueMapItemsSave.\n     * @implements IMultiValueMapItemsSave\n     * @constructor\n     * @param {IMultiValueMapItemsSave=} [properties] Properties to set\n     */\n    function MultiValueMapItemsSave(properties) {\n        this.values = [];\n        this.senders = [];\n        this.senderCounters = [];\n        this.wallClockTimes = [];\n        this.lamportTimestamps = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * MultiValueMapItemsSave values.\n     * @member {Array.<Uint8Array>} values\n     * @memberof MultiValueMapItemsSave\n     * @instance\n     */\n    MultiValueMapItemsSave.prototype.values = $util.emptyArray;\n\n    /**\n     * MultiValueMapItemsSave senders.\n     * @member {Array.<number>} senders\n     * @memberof MultiValueMapItemsSave\n     * @instance\n     */\n    MultiValueMapItemsSave.prototype.senders = $util.emptyArray;\n\n    /**\n     * MultiValueMapItemsSave senderCounters.\n     * @member {Array.<number>} senderCounters\n     * @memberof MultiValueMapItemsSave\n     * @instance\n     */\n    MultiValueMapItemsSave.prototype.senderCounters = $util.emptyArray;\n\n    /**\n     * MultiValueMapItemsSave wallClockTimes.\n     * @member {Array.<number|Long>} wallClockTimes\n     * @memberof MultiValueMapItemsSave\n     * @instance\n     */\n    MultiValueMapItemsSave.prototype.wallClockTimes = $util.emptyArray;\n\n    /**\n     * MultiValueMapItemsSave lamportTimestamps.\n     * @member {Array.<number|Long>} lamportTimestamps\n     * @memberof MultiValueMapItemsSave\n     * @instance\n     */\n    MultiValueMapItemsSave.prototype.lamportTimestamps = $util.emptyArray;\n\n    /**\n     * Creates a new MultiValueMapItemsSave instance using the specified properties.\n     * @function create\n     * @memberof MultiValueMapItemsSave\n     * @static\n     * @param {IMultiValueMapItemsSave=} [properties] Properties to set\n     * @returns {MultiValueMapItemsSave} MultiValueMapItemsSave instance\n     */\n    MultiValueMapItemsSave.create = function create(properties) {\n        return new MultiValueMapItemsSave(properties);\n    };\n\n    /**\n     * Encodes the specified MultiValueMapItemsSave message. Does not implicitly {@link MultiValueMapItemsSave.verify|verify} messages.\n     * @function encode\n     * @memberof MultiValueMapItemsSave\n     * @static\n     * @param {IMultiValueMapItemsSave} message MultiValueMapItemsSave message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    MultiValueMapItemsSave.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.values != null && message.values.length)\n            for (let i = 0; i < message.values.length; ++i)\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.values[i]);\n        if (message.senders != null && message.senders.length) {\n            writer.uint32(/* id 2, wireType 2 =*/18).fork();\n            for (let i = 0; i < message.senders.length; ++i)\n                writer.uint32(message.senders[i]);\n            writer.ldelim();\n        }\n        if (message.senderCounters != null && message.senderCounters.length) {\n            writer.uint32(/* id 3, wireType 2 =*/26).fork();\n            for (let i = 0; i < message.senderCounters.length; ++i)\n                writer.uint32(message.senderCounters[i]);\n            writer.ldelim();\n        }\n        if (message.wallClockTimes != null && message.wallClockTimes.length) {\n            writer.uint32(/* id 4, wireType 2 =*/34).fork();\n            for (let i = 0; i < message.wallClockTimes.length; ++i)\n                writer.uint64(message.wallClockTimes[i]);\n            writer.ldelim();\n        }\n        if (message.lamportTimestamps != null && message.lamportTimestamps.length) {\n            writer.uint32(/* id 5, wireType 2 =*/42).fork();\n            for (let i = 0; i < message.lamportTimestamps.length; ++i)\n                writer.uint64(message.lamportTimestamps[i]);\n            writer.ldelim();\n        }\n        return writer;\n    };\n\n    /**\n     * Encodes the specified MultiValueMapItemsSave message, length delimited. Does not implicitly {@link MultiValueMapItemsSave.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof MultiValueMapItemsSave\n     * @static\n     * @param {IMultiValueMapItemsSave} message MultiValueMapItemsSave message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    MultiValueMapItemsSave.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a MultiValueMapItemsSave message from the specified reader or buffer.\n     * @function decode\n     * @memberof MultiValueMapItemsSave\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {MultiValueMapItemsSave} MultiValueMapItemsSave\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    MultiValueMapItemsSave.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new MultiValueMapItemsSave();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                if (!(message.values && message.values.length))\n                    message.values = [];\n                message.values.push(reader.bytes());\n                break;\n            case 2:\n                if (!(message.senders && message.senders.length))\n                    message.senders = [];\n                if ((tag & 7) === 2) {\n                    let end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.senders.push(reader.uint32());\n                } else\n                    message.senders.push(reader.uint32());\n                break;\n            case 3:\n                if (!(message.senderCounters && message.senderCounters.length))\n                    message.senderCounters = [];\n                if ((tag & 7) === 2) {\n                    let end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.senderCounters.push(reader.uint32());\n                } else\n                    message.senderCounters.push(reader.uint32());\n                break;\n            case 4:\n                if (!(message.wallClockTimes && message.wallClockTimes.length))\n                    message.wallClockTimes = [];\n                if ((tag & 7) === 2) {\n                    let end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.wallClockTimes.push(reader.uint64());\n                } else\n                    message.wallClockTimes.push(reader.uint64());\n                break;\n            case 5:\n                if (!(message.lamportTimestamps && message.lamportTimestamps.length))\n                    message.lamportTimestamps = [];\n                if ((tag & 7) === 2) {\n                    let end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.lamportTimestamps.push(reader.uint64());\n                } else\n                    message.lamportTimestamps.push(reader.uint64());\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a MultiValueMapItemsSave message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof MultiValueMapItemsSave\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {MultiValueMapItemsSave} MultiValueMapItemsSave\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    MultiValueMapItemsSave.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a MultiValueMapItemsSave message.\n     * @function verify\n     * @memberof MultiValueMapItemsSave\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    MultiValueMapItemsSave.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.values != null && message.hasOwnProperty(\"values\")) {\n            if (!Array.isArray(message.values))\n                return \"values: array expected\";\n            for (let i = 0; i < message.values.length; ++i)\n                if (!(message.values[i] && typeof message.values[i].length === \"number\" || $util.isString(message.values[i])))\n                    return \"values: buffer[] expected\";\n        }\n        if (message.senders != null && message.hasOwnProperty(\"senders\")) {\n            if (!Array.isArray(message.senders))\n                return \"senders: array expected\";\n            for (let i = 0; i < message.senders.length; ++i)\n                if (!$util.isInteger(message.senders[i]))\n                    return \"senders: integer[] expected\";\n        }\n        if (message.senderCounters != null && message.hasOwnProperty(\"senderCounters\")) {\n            if (!Array.isArray(message.senderCounters))\n                return \"senderCounters: array expected\";\n            for (let i = 0; i < message.senderCounters.length; ++i)\n                if (!$util.isInteger(message.senderCounters[i]))\n                    return \"senderCounters: integer[] expected\";\n        }\n        if (message.wallClockTimes != null && message.hasOwnProperty(\"wallClockTimes\")) {\n            if (!Array.isArray(message.wallClockTimes))\n                return \"wallClockTimes: array expected\";\n            for (let i = 0; i < message.wallClockTimes.length; ++i)\n                if (!$util.isInteger(message.wallClockTimes[i]) && !(message.wallClockTimes[i] && $util.isInteger(message.wallClockTimes[i].low) && $util.isInteger(message.wallClockTimes[i].high)))\n                    return \"wallClockTimes: integer|Long[] expected\";\n        }\n        if (message.lamportTimestamps != null && message.hasOwnProperty(\"lamportTimestamps\")) {\n            if (!Array.isArray(message.lamportTimestamps))\n                return \"lamportTimestamps: array expected\";\n            for (let i = 0; i < message.lamportTimestamps.length; ++i)\n                if (!$util.isInteger(message.lamportTimestamps[i]) && !(message.lamportTimestamps[i] && $util.isInteger(message.lamportTimestamps[i].low) && $util.isInteger(message.lamportTimestamps[i].high)))\n                    return \"lamportTimestamps: integer|Long[] expected\";\n        }\n        return null;\n    };\n\n    /**\n     * Creates a MultiValueMapItemsSave message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof MultiValueMapItemsSave\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {MultiValueMapItemsSave} MultiValueMapItemsSave\n     */\n    MultiValueMapItemsSave.fromObject = function fromObject(object) {\n        if (object instanceof MultiValueMapItemsSave)\n            return object;\n        let message = new MultiValueMapItemsSave();\n        if (object.values) {\n            if (!Array.isArray(object.values))\n                throw TypeError(\".MultiValueMapItemsSave.values: array expected\");\n            message.values = [];\n            for (let i = 0; i < object.values.length; ++i)\n                if (typeof object.values[i] === \"string\")\n                    $util.base64.decode(object.values[i], message.values[i] = $util.newBuffer($util.base64.length(object.values[i])), 0);\n                else if (object.values[i].length)\n                    message.values[i] = object.values[i];\n        }\n        if (object.senders) {\n            if (!Array.isArray(object.senders))\n                throw TypeError(\".MultiValueMapItemsSave.senders: array expected\");\n            message.senders = [];\n            for (let i = 0; i < object.senders.length; ++i)\n                message.senders[i] = object.senders[i] >>> 0;\n        }\n        if (object.senderCounters) {\n            if (!Array.isArray(object.senderCounters))\n                throw TypeError(\".MultiValueMapItemsSave.senderCounters: array expected\");\n            message.senderCounters = [];\n            for (let i = 0; i < object.senderCounters.length; ++i)\n                message.senderCounters[i] = object.senderCounters[i] >>> 0;\n        }\n        if (object.wallClockTimes) {\n            if (!Array.isArray(object.wallClockTimes))\n                throw TypeError(\".MultiValueMapItemsSave.wallClockTimes: array expected\");\n            message.wallClockTimes = [];\n            for (let i = 0; i < object.wallClockTimes.length; ++i)\n                if ($util.Long)\n                    (message.wallClockTimes[i] = $util.Long.fromValue(object.wallClockTimes[i])).unsigned = true;\n                else if (typeof object.wallClockTimes[i] === \"string\")\n                    message.wallClockTimes[i] = parseInt(object.wallClockTimes[i], 10);\n                else if (typeof object.wallClockTimes[i] === \"number\")\n                    message.wallClockTimes[i] = object.wallClockTimes[i];\n                else if (typeof object.wallClockTimes[i] === \"object\")\n                    message.wallClockTimes[i] = new $util.LongBits(object.wallClockTimes[i].low >>> 0, object.wallClockTimes[i].high >>> 0).toNumber(true);\n        }\n        if (object.lamportTimestamps) {\n            if (!Array.isArray(object.lamportTimestamps))\n                throw TypeError(\".MultiValueMapItemsSave.lamportTimestamps: array expected\");\n            message.lamportTimestamps = [];\n            for (let i = 0; i < object.lamportTimestamps.length; ++i)\n                if ($util.Long)\n                    (message.lamportTimestamps[i] = $util.Long.fromValue(object.lamportTimestamps[i])).unsigned = true;\n                else if (typeof object.lamportTimestamps[i] === \"string\")\n                    message.lamportTimestamps[i] = parseInt(object.lamportTimestamps[i], 10);\n                else if (typeof object.lamportTimestamps[i] === \"number\")\n                    message.lamportTimestamps[i] = object.lamportTimestamps[i];\n                else if (typeof object.lamportTimestamps[i] === \"object\")\n                    message.lamportTimestamps[i] = new $util.LongBits(object.lamportTimestamps[i].low >>> 0, object.lamportTimestamps[i].high >>> 0).toNumber(true);\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a MultiValueMapItemsSave message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof MultiValueMapItemsSave\n     * @static\n     * @param {MultiValueMapItemsSave} message MultiValueMapItemsSave\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    MultiValueMapItemsSave.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults) {\n            object.values = [];\n            object.senders = [];\n            object.senderCounters = [];\n            object.wallClockTimes = [];\n            object.lamportTimestamps = [];\n        }\n        if (message.values && message.values.length) {\n            object.values = [];\n            for (let j = 0; j < message.values.length; ++j)\n                object.values[j] = options.bytes === String ? $util.base64.encode(message.values[j], 0, message.values[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.values[j]) : message.values[j];\n        }\n        if (message.senders && message.senders.length) {\n            object.senders = [];\n            for (let j = 0; j < message.senders.length; ++j)\n                object.senders[j] = message.senders[j];\n        }\n        if (message.senderCounters && message.senderCounters.length) {\n            object.senderCounters = [];\n            for (let j = 0; j < message.senderCounters.length; ++j)\n                object.senderCounters[j] = message.senderCounters[j];\n        }\n        if (message.wallClockTimes && message.wallClockTimes.length) {\n            object.wallClockTimes = [];\n            for (let j = 0; j < message.wallClockTimes.length; ++j)\n                if (typeof message.wallClockTimes[j] === \"number\")\n                    object.wallClockTimes[j] = options.longs === String ? String(message.wallClockTimes[j]) : message.wallClockTimes[j];\n                else\n                    object.wallClockTimes[j] = options.longs === String ? $util.Long.prototype.toString.call(message.wallClockTimes[j]) : options.longs === Number ? new $util.LongBits(message.wallClockTimes[j].low >>> 0, message.wallClockTimes[j].high >>> 0).toNumber(true) : message.wallClockTimes[j];\n        }\n        if (message.lamportTimestamps && message.lamportTimestamps.length) {\n            object.lamportTimestamps = [];\n            for (let j = 0; j < message.lamportTimestamps.length; ++j)\n                if (typeof message.lamportTimestamps[j] === \"number\")\n                    object.lamportTimestamps[j] = options.longs === String ? String(message.lamportTimestamps[j]) : message.lamportTimestamps[j];\n                else\n                    object.lamportTimestamps[j] = options.longs === String ? $util.Long.prototype.toString.call(message.lamportTimestamps[j]) : options.longs === Number ? new $util.LongBits(message.lamportTimestamps[j].low >>> 0, message.lamportTimestamps[j].high >>> 0).toNumber(true) : message.lamportTimestamps[j];\n        }\n        return object;\n    };\n\n    /**\n     * Converts this MultiValueMapItemsSave to JSON.\n     * @function toJSON\n     * @memberof MultiValueMapItemsSave\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    MultiValueMapItemsSave.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return MultiValueMapItemsSave;\n})();\n\nexport const MultiValueMapSave = /*@__PURE__*/ (() => {\n\n    /**\n     * Properties of a MultiValueMapSave.\n     * @exports IMultiValueMapSave\n     * @interface IMultiValueMapSave\n     * @property {Object.<string,IMultiValueMapItemsSave>|null} [entries] MultiValueMapSave entries\n     * @property {Array.<string>|null} [senders] MultiValueMapSave senders\n     */\n\n    /**\n     * Constructs a new MultiValueMapSave.\n     * @exports MultiValueMapSave\n     * @classdesc Represents a MultiValueMapSave.\n     * @implements IMultiValueMapSave\n     * @constructor\n     * @param {IMultiValueMapSave=} [properties] Properties to set\n     */\n    function MultiValueMapSave(properties) {\n        this.entries = {};\n        this.senders = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * MultiValueMapSave entries.\n     * @member {Object.<string,IMultiValueMapItemsSave>} entries\n     * @memberof MultiValueMapSave\n     * @instance\n     */\n    MultiValueMapSave.prototype.entries = $util.emptyObject;\n\n    /**\n     * MultiValueMapSave senders.\n     * @member {Array.<string>} senders\n     * @memberof MultiValueMapSave\n     * @instance\n     */\n    MultiValueMapSave.prototype.senders = $util.emptyArray;\n\n    /**\n     * Creates a new MultiValueMapSave instance using the specified properties.\n     * @function create\n     * @memberof MultiValueMapSave\n     * @static\n     * @param {IMultiValueMapSave=} [properties] Properties to set\n     * @returns {MultiValueMapSave} MultiValueMapSave instance\n     */\n    MultiValueMapSave.create = function create(properties) {\n        return new MultiValueMapSave(properties);\n    };\n\n    /**\n     * Encodes the specified MultiValueMapSave message. Does not implicitly {@link MultiValueMapSave.verify|verify} messages.\n     * @function encode\n     * @memberof MultiValueMapSave\n     * @static\n     * @param {IMultiValueMapSave} message MultiValueMapSave message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    MultiValueMapSave.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.entries != null && Object.hasOwnProperty.call(message, \"entries\"))\n            for (let keys = Object.keys(message.entries), i = 0; i < keys.length; ++i) {\n                writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);\n                MultiValueMapItemsSave.encode(message.entries[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();\n            }\n        if (message.senders != null && message.senders.length)\n            for (let i = 0; i < message.senders.length; ++i)\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.senders[i]);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified MultiValueMapSave message, length delimited. Does not implicitly {@link MultiValueMapSave.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof MultiValueMapSave\n     * @static\n     * @param {IMultiValueMapSave} message MultiValueMapSave message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    MultiValueMapSave.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a MultiValueMapSave message from the specified reader or buffer.\n     * @function decode\n     * @memberof MultiValueMapSave\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {MultiValueMapSave} MultiValueMapSave\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    MultiValueMapSave.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new MultiValueMapSave(), key;\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                reader.skip().pos++;\n                if (message.entries === $util.emptyObject)\n                    message.entries = {};\n                key = reader.string();\n                reader.pos++;\n                message.entries[key] = MultiValueMapItemsSave.decode(reader, reader.uint32());\n                break;\n            case 2:\n                if (!(message.senders && message.senders.length))\n                    message.senders = [];\n                message.senders.push(reader.string());\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a MultiValueMapSave message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof MultiValueMapSave\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {MultiValueMapSave} MultiValueMapSave\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    MultiValueMapSave.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a MultiValueMapSave message.\n     * @function verify\n     * @memberof MultiValueMapSave\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    MultiValueMapSave.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.entries != null && message.hasOwnProperty(\"entries\")) {\n            if (!$util.isObject(message.entries))\n                return \"entries: object expected\";\n            let key = Object.keys(message.entries);\n            for (let i = 0; i < key.length; ++i) {\n                let error = MultiValueMapItemsSave.verify(message.entries[key[i]]);\n                if (error)\n                    return \"entries.\" + error;\n            }\n        }\n        if (message.senders != null && message.hasOwnProperty(\"senders\")) {\n            if (!Array.isArray(message.senders))\n                return \"senders: array expected\";\n            for (let i = 0; i < message.senders.length; ++i)\n                if (!$util.isString(message.senders[i]))\n                    return \"senders: string[] expected\";\n        }\n        return null;\n    };\n\n    /**\n     * Creates a MultiValueMapSave message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof MultiValueMapSave\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {MultiValueMapSave} MultiValueMapSave\n     */\n    MultiValueMapSave.fromObject = function fromObject(object) {\n        if (object instanceof MultiValueMapSave)\n            return object;\n        let message = new MultiValueMapSave();\n        if (object.entries) {\n            if (typeof object.entries !== \"object\")\n                throw TypeError(\".MultiValueMapSave.entries: object expected\");\n            message.entries = {};\n            for (let keys = Object.keys(object.entries), i = 0; i < keys.length; ++i) {\n                if (typeof object.entries[keys[i]] !== \"object\")\n                    throw TypeError(\".MultiValueMapSave.entries: object expected\");\n                message.entries[keys[i]] = MultiValueMapItemsSave.fromObject(object.entries[keys[i]]);\n            }\n        }\n        if (object.senders) {\n            if (!Array.isArray(object.senders))\n                throw TypeError(\".MultiValueMapSave.senders: array expected\");\n            message.senders = [];\n            for (let i = 0; i < object.senders.length; ++i)\n                message.senders[i] = String(object.senders[i]);\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a MultiValueMapSave message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof MultiValueMapSave\n     * @static\n     * @param {MultiValueMapSave} message MultiValueMapSave\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    MultiValueMapSave.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults)\n            object.senders = [];\n        if (options.objects || options.defaults)\n            object.entries = {};\n        let keys2;\n        if (message.entries && (keys2 = Object.keys(message.entries)).length) {\n            object.entries = {};\n            for (let j = 0; j < keys2.length; ++j)\n                object.entries[keys2[j]] = MultiValueMapItemsSave.toObject(message.entries[keys2[j]], options);\n        }\n        if (message.senders && message.senders.length) {\n            object.senders = [];\n            for (let j = 0; j < message.senders.length; ++j)\n                object.senders[j] = message.senders[j];\n        }\n        return object;\n    };\n\n    /**\n     * Converts this MultiValueMapSave to JSON.\n     * @function toJSON\n     * @memberof MultiValueMapSave\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    MultiValueMapSave.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return MultiValueMapSave;\n})();\n\nexport { $root as default };\n","import { AbstractSet_Collab, DefaultSerializer, InitToken, collabIDOf, nonNull, } from \"@collabs/core\";\nimport { CSetMessage, CSetSave } from \"../../generated/proto_compiled\";\nconst RADIX = 36;\n/**\n * A collaborative set with *mutable*\n * values of type C.\n *\n * Values are internally mutable.\n * Specifically, each value is its own [[Collab]], and\n * operations on that Collab are collaborative as usual.\n *\n * Unlike a normal `Set<C>`, you do not add values directly.\n * Instead, you use the pattern described in\n * [collections of Collabs](https://collabs.readthedocs.io/en/latest/guide/collections.html):\n * one user calls [[add]] with `AddArgs`; each\n * replica passes those `AddArgs` to its\n * `valueConstructor`;\n * and `valueConstructor` returns the local copy of the new value Collab.\n *\n * When a value is deleted with [[delete]], it is deleted permanently and\n * can no longer be used; future and concurrent operations on that value\n * are ignored.\n *\n * You can also treat a `CSet<C>` as a \"factory\"\n * for Collabs of type C: [[add]] is like \"new\"/\"malloc\" and\n * [[delete]] is like \"free\", but replicated across all devices.\n *\n * See also: [[CValueSet]].\n *\n * @typeParam C The value type, which is a Collab.\n * @typeParam AddArgs The type of arguments to [[add]].\n */\nexport class CSet extends AbstractSet_Collab {\n    /**\n     * Constructs a CSet with the given `valueConstructor`.\n     *\n     * @param valueConstructor Callback used to construct a\n     * value Collab with the given [[InitToken]] and arguments to [[add]]. See [collections of Collabs](https://collabs.readthedocs.io/en/latest/guide/collections.html)\n     * for example usage.\n     * @param options.argsSerializer A serializer for `AddArgs` as an array.\n     * Defaults to [[DefaultSerializer]].\n     */\n    constructor(init, valueConstructor, options = {}) {\n        super(init);\n        this.valueConstructor = valueConstructor;\n        this.children = new Map();\n        // constructorArgs are saved for later save calls.\n        this.constructorArgs = new Map();\n        // We store just-deleted children until the next runtime Change event, for\n        // the purpose of answering fromId calls in same-transaction event listeners.\n        this.justDeletedChildren = new Map();\n        /**\n         * A deleted child that is sending a message. This var is used to\n         * pass the child from childSend to receive so that we\n         * can deliver the message successfully despite not keeping the\n         * child around in this.children.\n         */\n        this.deletedSendingChild = undefined;\n        // Vars used to return the newly-added value in add().\n        this.inAdd = false;\n        this.ourCreatedValue = undefined;\n        // Name requirements:\n        // 1. Contain their causal dot (senderID, senderCounter), for merging\n        // 2. Unique, even with multiple adds in same transaction\n        // 3. Pure - doesn't reference sender-side state, for future runLocally\n        // To satisfy these, we use a causal dot plus a per-transaction counter\n        // (evaluated on the receiver side).\n        // To avoid a wasteful senderID -> utf8 bytes -> base64 string\n        // conversion, we encode the string manually,\n        // instead of using protobuf + base64.\n        // OPT: shorter number encodings? Esp for senderCounter.\n        this.trCounter = 0;\n        if (this.runtime.isCRDTRuntime !== true) {\n            throw new Error(\"this.runtime must be CRuntime or compatible\");\n        }\n        this.argsSerializer =\n            options.argsSerializer ?? DefaultSerializer.getInstance();\n    }\n    childSend(child, messageStack, metaRequests) {\n        if (child.parent !== this) {\n            throw new Error(`childSend called by non-child: ${child}`);\n        }\n        // OPT: Should we avoid this redundant Map lookup by storing the child\n        // regardless?\n        if (!this.children.has(child.name)) {\n            this.deletedSendingChild = child;\n        }\n        messageStack.push(child.name);\n        this.send(messageStack, metaRequests);\n    }\n    receive(messageStack, meta) {\n        const lastMessage = nonNull(messageStack.pop());\n        if (typeof lastMessage === \"string\") {\n            // Message for an existing child.  Proceed as in\n            // CObject.\n            let child = this.children.get(lastMessage);\n            if (child === undefined) {\n                // Assume it's a message for a deleted (hence\n                // frozen) child.\n                if (this.deletedSendingChild !== undefined) {\n                    // Deliver the message locally so that the child ops go through,\n                    // preventing errors from chained ops.\n                    child = this.deletedSendingChild;\n                    this.deletedSendingChild = undefined;\n                }\n                else {\n                    // Ignore.\n                    return;\n                }\n            }\n            child.receive(messageStack, meta);\n        }\n        else {\n            const decoded = CSetMessage.decode(lastMessage);\n            const crdtMeta = meta.runtimeExtra;\n            switch (decoded.op) {\n                case \"add\": {\n                    const name = this.makeName(meta.senderID, crdtMeta.senderCounter);\n                    this.receiveAdd(name, decoded.add, meta);\n                    break;\n                }\n                case \"delete\": {\n                    const child = this.children.get(decoded.delete);\n                    if (child !== undefined) {\n                        this.receiveDelete(decoded.delete, child, meta);\n                    }\n                    break;\n                }\n                default:\n                    throw new Error(`Unknown decoded.op: ${decoded.op}`);\n            }\n        }\n    }\n    receiveAdd(name, serializedArgs, meta) {\n        if (this.children.has(name)) {\n            throw new Error('Duplicate newValue name: \"' + name + '\"');\n        }\n        const newValue = this.valueConstructor(new InitToken(name, this), ...this.argsSerializer.deserialize(nonNull(serializedArgs)));\n        this.children.set(name, newValue);\n        this.constructorArgs.set(name, nonNull(serializedArgs));\n        if (this.inAdd) {\n            this.ourCreatedValue = newValue;\n        }\n        this.emit(\"Add\", {\n            value: newValue,\n            meta,\n        });\n    }\n    receiveDelete(name, value, meta) {\n        this.children.delete(name);\n        this.constructorArgs.delete(name);\n        // Store the child in justDeletedChildren until the end\n        // of the current update. See [[fromID]]'s doc header for why.\n        if (this.justDeletedChildren.size === 0) {\n            this.runtime.on(\"Update\", () => this.justDeletedChildren.clear(), { once: true });\n        }\n        this.justDeletedChildren.set(name, value);\n        this.emit(\"Delete\", {\n            value,\n            meta,\n        });\n        value.finalize();\n    }\n    makeName(senderID, senderCounter) {\n        let ans;\n        if (this.trCounter === 0) {\n            // Reset trCounter at the end of the transaction.\n            // Since this method is only called during receive(), transactions\n            // coincide with updates.\n            this.runtime.on(\"Update\", () => {\n                this.trCounter = 0;\n            }, { once: true });\n            // Omit trCounter in this common case.\n            ans = `${senderCounter.toString(RADIX)},${senderID}`;\n        }\n        else {\n            ans = `${senderCounter.toString(RADIX)}.${this.trCounter.toString(RADIX)},${senderID}`;\n        }\n        this.trCounter++;\n        return ans;\n    }\n    parseName(name) {\n        const comma = name.indexOf(\",\");\n        const dot = name.lastIndexOf(\".\", comma - 1);\n        const senderCounterStr = name.slice(0, dot === -1 ? comma : dot);\n        return [name.slice(comma + 1), Number.parseInt(senderCounterStr, RADIX)];\n    }\n    /**\n     * Adds a value to the set using args.\n     *\n     * The args are broadcast to all replicas in serialized form.\n     * Every replica then passes them to `valueConstructor` to construct the actual\n     * value of type C, a new Collab that is collaborative as usual.\n     *\n     * @returns The added value.\n     */\n    add(...args) {\n        this.inAdd = true;\n        const message = CSetMessage.create({\n            add: this.argsSerializer.serialize(args),\n        });\n        this.send([CSetMessage.encode(message).finish()], []);\n        const created = nonNull(this.ourCreatedValue);\n        this.ourCreatedValue = undefined;\n        this.inAdd = false;\n        return created;\n    }\n    /**\n     * Deletes the given value, making it no longer present\n     * in this set.\n     *\n     * `value` is deleted permanently and\n     * can no longer be used; future and concurrent operations on that value\n     * are ignored. Local operations will succeed but will not affect\n     * remote replicas. The value can perform cleanup in its\n     * [[Collab.finalize]] method.\n     */\n    delete(value) {\n        if (this.has(value)) {\n            const message = CSetMessage.create({\n                delete: value.name,\n            });\n            this.send([CSetMessage.encode(message).finish()], []);\n        }\n    }\n    // OPT: better clear()\n    has(value) {\n        return value.parent === this && this.children.has(value.name);\n    }\n    values() {\n        return this.children.values();\n    }\n    get size() {\n        return this.children.size;\n    }\n    /**\n     * Returns the `AddArgs` used to add `value`.\n     *\n     * @throws if `!this.has(value)`.\n     */\n    getArgs(value) {\n        if (!this.has(value)) {\n            throw new Error(\"this.has(value) is false\");\n        }\n        const argsSerialized = this.constructorArgs.get(value.name);\n        if (argsSerialized === undefined) {\n            throw new Error(\"Cannot call argsOf on initial value\");\n        }\n        return this.argsSerializer.deserialize(argsSerialized);\n    }\n    save() {\n        const args = new Array(this.size);\n        const childSaves = new Map();\n        let i = 0;\n        for (const [name, child] of this.children) {\n            args[i] = nonNull(this.constructorArgs.get(name));\n            childSaves.set(name, child.save());\n            i++;\n        }\n        const saveMessage = CSetSave.create({ args });\n        return {\n            self: CSetSave.encode(saveMessage).finish(),\n            children: childSaves,\n        };\n    }\n    load(savedStateTree, meta) {\n        const crdtMeta = meta.runtimeExtra;\n        let saveMessage;\n        let childSaves;\n        if (savedStateTree === null) {\n            // Assume the saved state was trivial (had canGC() = true), i.e.,\n            // 0 values.\n            saveMessage = CSetSave.create({ args: [] });\n            childSaves = new Map();\n        }\n        else {\n            saveMessage = CSetSave.decode(nonNull(savedStateTree.self));\n            childSaves = nonNull(savedStateTree.children);\n        }\n        // 1. Delete our children that are not present in the saved\n        // state and that are causally dominated by the remote VC.\n        for (const [name, value] of this.children) {\n            if (!childSaves.has(name)) {\n                const [senderID, senderCounter] = this.parseName(name);\n                if (crdtMeta.remoteVectorClock.get(senderID) >= senderCounter) {\n                    this.receiveDelete(name, value, meta);\n                }\n            }\n        }\n        // 2. Add new children (not already present here) that are not\n        // causally dominated by the local VC.\n        let i = 0;\n        for (const name of childSaves.keys()) {\n            if (!this.children.has(name)) {\n                const [senderID, senderCounter] = this.parseName(name);\n                if (crdtMeta.localVectorClock.get(senderID) < senderCounter) {\n                    // This will emit an Add event, even though we haven't\n                    // loaded the value yet.\n                    // That matches add()'s behavior, and it lets users register event\n                    // listeners in the Add event before any updates occur.\n                    this.receiveAdd(name, saveMessage.args[i], meta);\n                }\n            }\n            i++;\n        }\n        // 3. Load children that have a save and are still present.\n        for (const [name, childSave] of childSaves) {\n            const child = this.children.get(name);\n            if (child !== undefined) {\n                child.load(childSave, meta);\n            }\n        }\n    }\n    idOf(descendant) {\n        return collabIDOf(descendant, this);\n    }\n    /**\n     * Inverse of [[idOf]].\n     *\n     * Specifically, given a [[CollabID]] returned by [[idOf]] on some replica of\n     * this CSet, returns this replica's copy of the original\n     * `descendant`.\n     *\n     * If the original `descendant` has been deleted from this\n     * set, this method will usually return `undefined`. The exception\n     * is if `descendant` was just deleted from this set.\n     * In that case, this method will\n     * still return the original `descendant` until the end of\n     * the deleting update.\n     * Thus event handlers within the same transaction can still\n     * get the deleted value.\n     *\n     * @param id A CollabID from [[idOf]].\n     * @param startIndex Internal (parent) use only.\n     * If provided, treat `id.collabIDPath` as if\n     * it starts at startIndex instead of 0.\n     */\n    fromID(id, startIndex = 0) {\n        const name = id.collabIDPath[startIndex];\n        let child = this.children.get(name);\n        if (child === undefined) {\n            // If it's a just-deleted child, still succeed.\n            child = this.justDeletedChildren.get(name);\n            if (child === undefined) {\n                // Assume it is a deleted child.\n                return undefined;\n            }\n        }\n        // Terminal case.\n        // Note that this cast is unsafe, but convenient.\n        if (startIndex === id.collabIDPath.length - 1)\n            return child;\n        // Recursive case.\n        if (child.fromID === undefined) {\n            throw new Error(\"child is not a parent, but CollabID is its descendant\");\n        }\n        return child.fromID(id, startIndex + 1);\n    }\n    canGC() {\n        return this.size === 0;\n    }\n}\n//# sourceMappingURL=c_set.js.map","import { AbstractSet_CObject, ConstSerializer, } from \"@collabs/core\";\nimport { CMultiValueMap } from \"../map\";\nconst trueSerializer = new ConstSerializer(true);\n/**\n * A collaborative set with values of type T.\n *\n * The API is compatible* with `Set<T>` and can be used as a\n * drop-in collaborative replacement when T is internally immutable. If multiple users\n * add and delete the same value concurrently, the add \"wins\"\n * (the value is present).\n *\n * Values must be internally immutable;\n * mutating a value internally will not change it on\n * other replicas. If you need to mutate values internally,\n * instead use a [[CSet]].\n *\n * (*) Except for the return value of [[add]], which is the added value instead\n * of `this`.\n *\n * @typeParam T The value type.\n */\nexport class CValueSet extends AbstractSet_CObject {\n    /**\n     * Constructs a CValueSet.\n     *\n     * @param options.valueSerializer Serializer for values. Defaults to [[DefaultSerializer]].\n     */\n    constructor(init, options = {}) {\n        super(init);\n        this.mvMap = super.registerCollab(\"\", (init) => new CMultiValueMap(init, {\n            keySerializer: options.valueSerializer,\n            valueSerializer: trueSerializer,\n        }));\n        this.mvMap.on(\"Delete\", (e) => {\n            this.emit(\"Delete\", {\n                value: e.key,\n                meta: e.meta,\n            });\n        });\n        this.mvMap.on(\"Set\", (e) => {\n            // Ensure the value actually went from not-present to present.\n            if (e.previousValue.isPresent)\n                return;\n            this.emit(\"Add\", {\n                value: e.key,\n                meta: e.meta,\n            });\n        });\n    }\n    /**\n     * Adds the value, making it present in this set.\n     *\n     * @return `value`.\n     */\n    add(value) {\n        this.mvMap.set(value, true);\n        return value;\n    }\n    /**\n     * Deletes the given value, making it no longer present in this set.\n     *\n     * @returns `true` if value was present and has been removed.\n     */\n    delete(value) {\n        const existed = this.has(value);\n        this.mvMap.delete(value);\n        return existed;\n    }\n    clear() {\n        this.mvMap.clear();\n    }\n    has(value) {\n        return this.mvMap.has(value);\n    }\n    get size() {\n        return this.mvMap.size;\n    }\n    values() {\n        return this.mvMap.keys();\n    }\n}\n//# sourceMappingURL=c_value_set.js.map","import { DefaultSerializer, Optional, int64AsNumber, nonNull, protobufHas, } from \"@collabs/core\";\nimport { fromByteArray, toByteArray } from \"base64-js\";\nimport { MultiValueMapMessage, MultiValueMapSave, } from \"../../generated/proto_compiled\";\nimport { AbstractMap_PrimitiveCRDT } from \"../base_collabs\";\n/**\n * A collaborative \"multi-value\" map, in which there may be multiple values\n * for a key due to concurrent [[set]] operations.\n *\n * This is a low-level API intended for internal use by other CRDT implementations.\n * In most apps, you are better off using [[CValueMap]] or [[CMap]].\n *\n * @typeParam K The key type.\n * @typeParam V The value type.\n */\nexport class CMultiValueMap extends AbstractMap_PrimitiveCRDT {\n    /**\n     * Constructs a MultiValueMap.\n     *\n     * @param options.keySerializer Serializer for keys. Defaults to [[DefaultSerializer]].\n     * @param options.valueSerializer Serializer for values. Defaults to [[DefaultSerializer]].\n     * @param options.aggregator [[Aggregator.wallClockTime]]\n     * and [[Aggregator.lamportTimestamp]] are used as settings\n     * for our [[MultiValueMapItems]]. [[Aggregator.aggregate]]\n     * is ignored.\n     */\n    constructor(init, options = {}) {\n        super(init);\n        // In the common case (no concurrent sets on a given key), that key has\n        // just one value. We store it as such, instead of as a singleton array,\n        // in the hopes of reducing memory usage & (un)boxing time.\n        // OPT: profile this to see if it's actually useful.\n        // The map key is keyAsString.\n        this.state = new Map();\n        this.keySerializer =\n            options.keySerializer ?? DefaultSerializer.getInstance();\n        this.valueSerializer =\n            options.valueSerializer ?? DefaultSerializer.getInstance();\n        this.wallClockTime = options.aggregator?.wallClockTime ?? false;\n        this.lamportTimestamp = options.aggregator?.lamportTimestamp ?? false;\n    }\n    /**\n     * Sets the value at key.\n     *\n     * @returns The corresponding [[MultiValueMapItem]].\n     */\n    set(key, value) {\n        const message = MultiValueMapMessage.create({\n            key: this.keySerializer.serialize(key),\n            value: this.valueSerializer.serialize(value),\n        });\n        // Automatic mode suffices to send all of the needed\n        // vector clock entries (those corresponding to current\n        // items in this.get(key)) and optional wallClockTime/lamportTimestamp.\n        super.sendCRDT(MultiValueMapMessage.encode(message).finish());\n        // OPT: don't re-serialize key here\n        return nonNull(this.get(key));\n    }\n    delete(key) {\n        const message = MultiValueMapMessage.create({\n            key: this.keySerializer.serialize(key),\n        });\n        // Automatic mode suffices to send all of the needed\n        // vector clock entries (those corresponding to current\n        // items in this.get(key)) and optional wallClockTime/lamportTimestamp.\n        super.sendCRDT(MultiValueMapMessage.encode(message).finish());\n    }\n    // OPT: implement clear (better than deleting every value)\n    receiveCRDT(message, meta, crdtMeta) {\n        const decoded = MultiValueMapMessage.decode(message);\n        const keyAsString = fromByteArray(decoded.key);\n        const previousValue = this.getInternal(keyAsString);\n        const newItems = [];\n        let needsSort = false;\n        if (previousValue !== undefined) {\n            for (const item of previousValue) {\n                // Omit causally dominated entries, including previous sets from the\n                // same transaction.\n                if (crdtMeta.vectorClock.get(item.senderID) < item.senderCounter) {\n                    newItems.push(item);\n                }\n            }\n        }\n        if (protobufHas(decoded, \"value\")) {\n            // It's a set operation; add the set item.\n            newItems.push({\n                value: this.valueSerializer.deserialize(decoded.value),\n                senderID: meta.senderID,\n                senderCounter: crdtMeta.senderCounter,\n                ...(this.wallClockTime\n                    ? { wallClockTime: nonNull(crdtMeta.wallClockTime) }\n                    : {}),\n                ...(this.lamportTimestamp\n                    ? { lamportTimestamp: nonNull(crdtMeta.lamportTimestamp) }\n                    : {}),\n            });\n            needsSort = true;\n        }\n        this.applyNewItems(keyAsString, decoded.key, previousValue, newItems, meta, needsSort);\n    }\n    applyNewItems(keyAsString, keyAsBytes, previousValue, newItems, meta, needsSort) {\n        if (needsSort) {\n            // Sort newItems to make its order deterministic (same across replicas).\n            newItems.sort((a, b) => (a.senderID < b.senderID ? -1 : 1));\n        }\n        const key = this.keySerializer.deserialize(keyAsBytes ?? toByteArray(keyAsString));\n        if (newItems.length === 0) {\n            this.state.delete(keyAsString);\n            if (previousValue !== undefined) {\n                this.emit(\"Delete\", { key, value: previousValue, meta });\n            }\n        }\n        else {\n            this.state.set(keyAsString, newItems.length === 1 ? newItems[0] : newItems);\n            this.emit(\"Set\", {\n                key,\n                value: newItems,\n                previousValue: previousValue === undefined\n                    ? Optional.empty()\n                    : Optional.of(previousValue),\n                meta,\n            });\n        }\n    }\n    /**\n     * Returns value in array form. The array is always new, to prevent\n     * the caller from mutating our internal state or vice-versa.\n     */\n    asNewArray(value) {\n        if (value === undefined)\n            return [];\n        if (Array.isArray(value))\n            return value.slice();\n        else\n            return [value];\n    }\n    /**\n     * Returns the array of [[MultiValueMapItem]]s corresponding\n     * to conflicting concurrent [[set]]s at `key`,\n     * or undefined if key is not present.\n     *\n     * If defined, the return value is always non-empty, and its order is\n     * eventually consistent. Specifically, it is\n     * in order by [[MultiValueMapItem.sender]].\n     */\n    get(key) {\n        return this.getInternal(fromByteArray(this.keySerializer.serialize(key)));\n    }\n    getInternal(keyAsString) {\n        const value = this.state.get(keyAsString);\n        return value === undefined ? undefined : this.asNewArray(value);\n    }\n    has(key) {\n        return this.state.has(fromByteArray(this.keySerializer.serialize(key)));\n    }\n    get size() {\n        return this.state.size;\n    }\n    /**\n     * Returns an iterable of `[key, get(key)]` pairs\n     * for every entry in the map.\n     *\n     * The iteration order is NOT eventually consistent:\n     * it may differ on replicas with the same state.\n     */\n    *entries() {\n        for (const [key, value] of this.state) {\n            yield [\n                this.keySerializer.deserialize(toByteArray(key)),\n                this.asNewArray(value),\n            ];\n        }\n    }\n    saveCRDT() {\n        const entries = {};\n        const senders = [];\n        const indexBySender = new Map();\n        for (const [keyAsString, itemsRaw] of this.state) {\n            const items = this.asNewArray(itemsRaw);\n            const entry = {\n                values: new Array(items.length),\n                senders: new Array(items.length),\n                senderCounters: new Array(items.length),\n            };\n            if (this.wallClockTime)\n                entry.wallClockTimes = new Array(items.length);\n            if (this.lamportTimestamp)\n                entry.lamportTimestamps = new Array(items.length);\n            for (let i = 0; i < items.length; i++) {\n                // Skip nonNull() checks for efficiency; it's just a weakness\n                // of how we've organized the code.\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                entry.values[i] = this.valueSerializer.serialize(items[i].value);\n                let sender = indexBySender.get(items[i].senderID);\n                if (sender === undefined) {\n                    sender = senders.length;\n                    senders.push(items[i].senderID);\n                }\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                entry.senders[i] = sender;\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                entry.senderCounters[i] = items[i].senderCounter;\n                if (this.wallClockTime) {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    entry.wallClockTimes[i] = items[i].wallClockTime;\n                }\n                if (this.lamportTimestamp) {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    entry.lamportTimestamps[i] = items[i].lamportTimestamp;\n                }\n            }\n            entries[keyAsString] = entry;\n        }\n        return MultiValueMapSave.encode({ entries, senders }).finish();\n    }\n    loadCRDT(savedState, meta, crdtMeta) {\n        let decoded;\n        if (savedState === null) {\n            // Assume the saved state was trivial (had canGC() = true), i.e.,\n            // 0 values.\n            decoded = MultiValueMapSave.create({ entries: {}, senders: [] });\n        }\n        else {\n            decoded = MultiValueMapSave.decode(savedState);\n        }\n        // Loop through keys in this.state.\n        for (const [keyAsString, itemsRaw] of this.state) {\n            this.loadOneKey(keyAsString, this.asNewArray(itemsRaw), decoded.entries[keyAsString], decoded.senders, meta, crdtMeta);\n            // Delete from decoded so we don't loop over it again.\n            delete decoded.entries[keyAsString];\n        }\n        // Loop through keys in decoded but not this.state.\n        for (const [keyAsString, items] of Object.entries(decoded.entries)) {\n            this.loadOneKey(keyAsString, undefined, items, decoded.senders, meta, crdtMeta);\n        }\n    }\n    loadOneKey(keyAsString, localItems, remoteItems, decodedSenders, meta, crdtMeta) {\n        // The new set of items is the union of:\n        // 1. Items in both localItems and remoteItems.\n        // 2. Items in localItems only that are not causally dominated by crdtMeta.remoteVC.\n        // 3. Items in remoteItems only that are not causally dominated by crdtMeta.localVC.\n        const newItems = [];\n        let addedRemote = false;\n        if (localItems !== undefined) {\n            // Map remote senders to senderCounters, for intersection checking.\n            // We are guaranteed that items with the same sender & senderCounter\n            // are identical. (Even if there were multiple ops in that transaction,\n            // we'll only ever see the last op.)\n            const remoteMap = new Map();\n            if (remoteItems !== undefined) {\n                for (let i = 0; i < remoteItems.senders.length; i++) {\n                    remoteMap.set(decodedSenders[remoteItems.senders[i]], remoteItems.senderCounters[i]);\n                }\n            }\n            for (const localItem of localItems) {\n                if (\n                // Case 2\n                crdtMeta.remoteVectorClock.get(localItem.senderID) <\n                    localItem.senderCounter ||\n                    // Case 1\n                    remoteMap.get(localItem.senderID) === localItem.senderCounter) {\n                    newItems.push(localItem);\n                }\n            }\n        }\n        if (remoteItems !== undefined) {\n            for (let i = 0; i < remoteItems.senders.length; i++) {\n                const sender = decodedSenders[remoteItems.senders[i]];\n                const senderCounter = remoteItems.senderCounters[i];\n                // Case 3\n                if (crdtMeta.localVectorClock.get(sender) < senderCounter) {\n                    newItems.push({\n                        value: this.valueSerializer.deserialize(remoteItems.values[i]),\n                        senderID: sender,\n                        senderCounter,\n                        ...(this.wallClockTime\n                            ? {\n                                wallClockTime: int64AsNumber(remoteItems.wallClockTimes[i]),\n                            }\n                            : {}),\n                        ...(this.lamportTimestamp\n                            ? {\n                                lamportTimestamp: int64AsNumber(remoteItems.lamportTimestamps[i]),\n                            }\n                            : {}),\n                    });\n                    addedRemote = true;\n                }\n            }\n        }\n        if (addedRemote ||\n            (localItems !== undefined && newItems.length < localItems.length)) {\n            // newItems differs from localItems; update this.state and emit\n            // an event.\n            this.applyNewItems(keyAsString, undefined, localItems, newItems, meta, addedRemote);\n        }\n    }\n    canGC() {\n        return this.state.size === 0;\n    }\n}\n//# sourceMappingURL=c_multi_value_map.js.map","import { AbstractMap_CObject, } from \"@collabs/core\";\nimport { CMultiValueMap } from \"./c_multi_value_map\";\n/**\n * Default aggregator: return the first item (first replicaID wins).\n */\nconst defaultAggregator = {\n    aggregate(items) {\n        return items[0].value;\n    },\n};\n/**\n * A collaborative map with keys of type K and values of type V.\n *\n * The API is compatible* with `Map<K, V>` and can be used as a\n * drop-in collaborative replacement when V is internally immutable. If multiple users\n * set the value at a key concurrently, one of them is picked\n * arbitrarily.\n *\n * Values must be internally immutable;\n * mutating a value internally will not change it on\n * other replicas. If you need to mutate values internally,\n * instead use a [[CMap]] or [[CLazyMap]].\n *\n * (*) Except for the return value of [[set]], which is the set value instead\n * of `this`.\n *\n * @typeParam K The key type.\n * @typeParam V The value type.\n */\nexport class CValueMap extends AbstractMap_CObject {\n    /**\n     * Constructs a CValueMap.\n     *\n     * @param options.keySerializer Serializer for keys. Defaults to [[DefaultSerializer]].\n     * @param options.valueSerializer Serializer for values. Defaults to [[DefaultSerializer]].\n     * @param options.aggregator If provided, used\n     * to aggregate concurrently-set values at the same key,\n     * instead of picking one arbitrarily.\n     */\n    constructor(init, options = {}) {\n        super(init);\n        this.aggregator =\n            options.aggregator ?? defaultAggregator;\n        this.mvMap = super.registerCollab(\"\", (init) => new CMultiValueMap(init, options));\n        this.mvMap.on(\"Delete\", (e) => {\n            this.emit(\"Delete\", {\n                key: e.key,\n                value: this.aggregator.aggregate(e.value),\n                meta: e.meta,\n            });\n        });\n        this.mvMap.on(\"Set\", (e) => {\n            // Note that we emit a Set event even when the new value ===\n            // the old value. That is useful if you are maintaining a view\n            // of getConflicts(): it tells you to refresh the view for `key`\n            // even when the winning value doesn't change.\n            this.emit(\"Set\", {\n                key: e.key,\n                value: this.aggregator.aggregate(e.value),\n                previousValue: e.previousValue.map((multiValue) => this.aggregator.aggregate(multiValue)),\n                meta: e.meta,\n            });\n        });\n    }\n    /**\n     * Sets the value at key.\n     *\n     * @return `value`\n     */\n    set(key, value) {\n        this.mvMap.set(key, value);\n        // Return this.get instead of just value, in case the aggregator does\n        // something weird.\n        // Use ! instead of nonNull because V might allow null.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return this.get(key);\n    }\n    /**\n     * Deletes the given key, making it no longer present in this map.\n     *\n     * @returns `true` if key was present and has been removed.\n     */\n    delete(key) {\n        const existed = this.has(key);\n        this.mvMap.delete(key);\n        return existed;\n    }\n    get(key) {\n        const multiValue = this.mvMap.get(key);\n        if (multiValue === undefined)\n            return undefined;\n        else\n            return this.aggregator.aggregate(multiValue);\n    }\n    /**\n     * Returns all conflicting concurrently-set values\n     * at key.\n     * Their order is arbitrary but consistent across replicas.\n     *\n     * If the key is not present, this returns `[]`.\n     * Otherwise, its first element is the set value.\n     */\n    getConflicts(key) {\n        return (this.mvMap.get(key) ?? []).map((item) => item.value);\n    }\n    has(key) {\n        return this.mvMap.has(key);\n    }\n    get size() {\n        return this.mvMap.size;\n    }\n    *entries() {\n        for (const [key, multiValue] of this.mvMap) {\n            yield [key, this.aggregator.aggregate(multiValue)];\n        }\n    }\n}\n//# sourceMappingURL=c_value_map.js.map","import { AbstractMap_CObject, CollabIDSerializer, DefaultSerializer, PairSerializer, nonNull, } from \"@collabs/core\";\nimport { CSet } from \"../set\";\nimport { CValueMap } from \"./c_value_map\";\n/**\n * A collaborative map with keys of type K and *mutable*\n * values of type C.\n *\n * Values are internally mutable.\n * Specifically, each value is its own [[Collab]], and\n * operations on that Collab are collaborative as usual.\n *\n * Unlike a normal `Map<K, C>`, you do not set values directly.\n * Instead, you use the pattern described in\n * [collections of Collabs](https://collabs.readthedocs.io/en/latest/guide/collections.html):\n * one user calls [[set]] with `SetArgs`; each\n * replica passes those `SetArgs` to its\n * `valueConstructor`;\n * and `valueConstructor` returns the local copy of the new value Collab.\n *\n * If multiple users\n * set the value at a key concurrently, one of the value Collabs is picked\n * arbitrarily; operations on the others are ignored.\n * To instead \"merge\" concurrently-created values - applying all of their\n * operations to the same underlying Collab - use\n * [[CLazyMap]].\n *\n * See also: [[CValueMap]], a simpler map for immutable values.\n *\n * @typeParam K The key type.\n * @typeParam C The value type, which is a Collab.\n * @typeParam SetArgs The type of arguments to [[set]].\n */\nexport class CMap extends AbstractMap_CObject {\n    /**\n     * Constructs a CMap with the given `valueConstructor`.\n     *\n     * @param valueConstructor Callback used to construct a\n     * value Collab with the given [[InitToken]], key, and arguments to [[set]]. See [collections of Collabs](https://collabs.readthedocs.io/en/latest/guide/collections.html)\n     * for example usage.\n     * @param options.keySerializer A serializer for keys.\n     * Defaults to [[DefaultSerializer]].\n     * @param options.argsSerializer A serializer for `SetArgs` as an array.\n     * Defaults to [[DefaultSerializer]].\n     * @param options.aggregator If provided, used\n     * to aggregate concurrently-set values at the same key,\n     * instead of picking one arbitrarily.\n     */\n    constructor(init, valueConstructor, options = {}) {\n        super(init);\n        const keySerializer = options.keySerializer ?? DefaultSerializer.getInstance();\n        const argsSerializer = options.argsSerializer ?? DefaultSerializer.getInstance();\n        this.valueSet = super.registerCollab(\"\", (init) => new CSet(init, (valueInit, key, args) => valueConstructor(valueInit, key, ...args), { argsSerializer: new PairSerializer(keySerializer, argsSerializer) }));\n        this.map = super.registerCollab(\"0\", (init) => new CValueMap(init, {\n            keySerializer,\n            valueSerializer: CollabIDSerializer.getInstance(),\n            aggregator: options.aggregator,\n        }));\n        // In this event handlers, calling this.valueSet.fromID\n        // on just-added values is okay because the set's additions\n        // always come before map sets. (On operations, this is by method\n        // call order; during loading, this is because we register this.set\n        // first, hence it is loaded first).\n        // Calling this.valueSet.fromID on just-deleted values is okay\n        // because CSet remembers just-deleted values until the end of\n        // the transaction.\n        this.map.on(\"Set\", (e) => {\n            const previousValue = e.previousValue.map((id) => nonNull(this.valueSet.fromID(id)));\n            this.emit(\"Set\", {\n                key: e.key,\n                value: nonNull(this.valueSet.fromID(e.value)),\n                previousValue,\n                meta: e.meta,\n            });\n        });\n        this.map.on(\"Delete\", (e) => {\n            const value = nonNull(this.valueSet.fromID(e.value));\n            this.emit(\"Delete\", {\n                key: e.key,\n                value,\n                meta: e.meta,\n            });\n        });\n    }\n    /**\n     * Sets the value at key using args.\n     *\n     * The args are broadcast to all replicas in serialized form.\n     * Every replica then passes them to `valueConstructor` to construct the actual\n     * value of type C, a new Collab that is collaborative as usual.\n     *\n     * @returns The set value.\n     */\n    set(key, ...args) {\n        const oldConflicts = this.getConflicts(key);\n        const newValue = this.valueSet.add(key, args);\n        this.map.set(key, this.valueSet.idOf(newValue));\n        // Delete old values, so they don't become tombstones.\n        // These correspond precisely to the conflicts deleted by map.set,\n        // so the invariant is maintained (valueSet and map's values remain in sync).\n        oldConflicts.forEach((value) => this.valueSet.delete(value));\n        return newValue;\n    }\n    delete(key) {\n        const oldConflicts = this.getConflicts(key);\n        this.map.delete(key);\n        // Delete old values, so they don't become tombstones.\n        // These correspond precisely to the conflicts deleted by map.delete,\n        // so the invariant is maintained (valueSet and map's values remain in sync).\n        oldConflicts.forEach((value) => this.valueSet.delete(value));\n    }\n    get(key) {\n        const id = this.map.get(key);\n        return id === undefined ? undefined : nonNull(this.valueSet.fromID(id));\n    }\n    /**\n     * Returns all conflicting concurrently-set values\n     * at key.\n     * Their order is arbitrary but consistent across replicas.\n     *\n     * If the key is not present, this returns `[]`.\n     */\n    getConflicts(key) {\n        /*\n         * This method is private because there is not a good way to work\n         * with conflicts: you can't re-set a key to one of its losing\n         * conflicts; conflicting values might be deleted unexpectedly\n         * by [[set]]'s deletion behavior;\n         * and they are not integrated with events.\n         * If you need to work with conflicts, use your own CSet (to generate\n         * values) and CValueMap (to control key-value mappings) instead of a CMap.\n         */\n        return this.map\n            .getConflicts(key)\n            .map((id) => nonNull(this.valueSet.fromID(id)));\n    }\n    has(key) {\n        return this.map.has(key);\n    }\n    *entries() {\n        for (const [key, id] of this.map) {\n            yield [key, nonNull(this.valueSet.fromID(id))];\n        }\n    }\n    /**\n     * Returns the unique key associated to a value\n     * in this map, in O(1) time.\n     *\n     * This method will succeed if value is the current value\n     * or a conflicting concurrently-set value (see [[getConflicts]]).\n     * Otherwise, it returns undefined.\n     *\n     * @param searchElement The value to locate in this map.\n     */\n    keyOf(searchElement) {\n        if (!this.valueSet.has(searchElement))\n            return undefined;\n        return this.valueSet.getArgs(searchElement)[0];\n    }\n    get size() {\n        return this.map.size;\n    }\n}\n//# sourceMappingURL=c_map.js.map","import { DefaultSerializer, Optional, int64AsNumber, nonNull, } from \"@collabs/core\";\nimport { PresenceMessage, PresenceSave, } from \"../../generated/proto_compiled\";\nimport { PrimitiveCRDT } from \"../base_collabs\";\n/**\n * A map for sharing *presence info* between present (simultaneously online)\n * replicas, e.g., usernames or shared cursors.\n *\n * Each replica controls a fixed key: its [[IRuntime.replicaID]].\n * Its value should be a plain object that contains presence info about\n * itself, such as its user's latest [[Cursor]] location in a collaborative\n * text editor.\n *\n * To make yourself present and start listening to others, call [[setOurs]]\n * followed by [[connect]]. To update your value, call [[updateOurs]]\n * or [[setOurs]] again. If you know you are about to go offline, try to call\n * [[disconnect]] to let others know; otherwise, they will infer it from\n * a timeout (default 10 seconds).\n *\n * CPresence attempts to detect presence accurately on a variety\n * of networks (centralized, peer-to-peer, op-based, state-based). You may\n * prefer a custom solution if you can detect presence more accurately,\n * e.g., by asking a central server who is connected.\n *\n * Values must be internally immutable;\n * mutating a value internally will not change it on\n * other replicas. Instead, use [[updateOurs]].\n *\n * See also:\n * - [[CValueMap]]: for an ordinary collaborative map.\n * - [[CMessenger]]: for sending ephemeral messages in general.\n *\n * @typeParam V The value type: a plain object that contains presence info\n * about a single replica.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class CPresence extends PrimitiveCRDT {\n    /**\n     * Constructs a CPresence.\n     *\n     * @param options.ttlMS The time-to-live for users who we have not heard from,\n     * after which their entry is deleted. Heartbeats sent twice as often\n     * keep present users alive. Default: [[TTL_MS_DEFAULT]].\n     * @param options.updateSerializer Serializer for updates ([[setOurs]] and\n     * [[updateOurs]]), which change a subset of V's keys.\n     * Defaults to [[DefaultSerializer]].\n     */\n    constructor(init, options = {}) {\n        super(init);\n        /** Excludes us. */\n        this.state = new Map();\n        this._size = 0;\n        this.ourValue = null;\n        this.heartbeatTimeout = null;\n        this._connected = false;\n        /** Whether we have joined, i.e., ever connected. */\n        this.joined = false;\n        this.heartbeat = () => {\n            if (this.connected) {\n                super.sendCRDT(PresenceMessage.encode({ heartbeat: true }).finish());\n            }\n            this.resetHeartbeat();\n        };\n        this.updateSerializer =\n            options.updateSerializer ?? DefaultSerializer.getInstance();\n        this.ttlMS = options.ttlMS ?? CPresence.TTL_MS_DEFAULT;\n        if (!(Number.isInteger(this.ttlMS) && this.ttlMS > 0)) {\n            throw new Error(`options.ttlMS must be a positive integer; got ${this.ttlMS}`);\n        }\n        this.heartbeatInterval = Math.ceil(this.ttlMS / 2);\n    }\n    /**\n     * Sets our value, overwriting the current value.\n     *\n     * To become present, call this method followed by [[connect]].\n     */\n    setOurs(value) {\n        const previousValue = this.ourValue === null ? Optional.empty() : Optional.of(this.ourValue);\n        if (this.ourValue === null)\n            this._size++;\n        this.ourValue = value;\n        if (this.connected) {\n            super.sendCRDT(PresenceMessage.encode({\n                set: {\n                    value: this.updateSerializer.serialize(this.ourValue),\n                },\n            }).finish());\n            this.resetHeartbeat();\n        }\n        this.emitOwnSetEvent(previousValue);\n    }\n    /**\n     * Updates a single property in our value, leaving the other\n     * properties unchanged.\n     *\n     * Use this method for frequently-changed properties like cursor positions.\n     */\n    updateOurs(property, propertyValue) {\n        if (this.ourValue === null) {\n            throw new Error(\"You must set our value with setOurs before updating it with updateOurs\");\n        }\n        const previousValue = Optional.of(this.ourValue);\n        this.ourValue = { ...this.ourValue, [property]: propertyValue };\n        if (this.connected) {\n            const updates = {};\n            updates[property] = propertyValue;\n            super.sendCRDT(PresenceMessage.encode({\n                update: this.updateSerializer.serialize(updates),\n            }).finish());\n            this.resetHeartbeat();\n        }\n        this.emitOwnSetEvent(previousValue);\n    }\n    emitOwnSetEvent(previousValue) {\n        this.emit(\"Set\", {\n            key: this.runtime.replicaID,\n            value: nonNull(this.ourValue),\n            previousValue,\n            meta: {\n                isLocalOp: true,\n                senderID: this.runtime.replicaID,\n                updateType: \"message\",\n                runtimeExtra: undefined,\n            },\n        });\n    }\n    /**\n     * Connects to the group, marking us as present.\n     * This method must only be called after setting our value with [[setOurs]].\n     */\n    connect() {\n        if (this._connected)\n            return;\n        if (this.ourValue === null) {\n            throw new Error(\"You must set our value with setOurs before calling connect()\");\n        }\n        // Connect, (re-)sending our current state, since setOurs/updateOurs do not\n        // send messages while disconnected.\n        super.sendCRDT(PresenceMessage.encode({\n            set: {\n                value: this.updateSerializer.serialize(this.ourValue),\n                isJoin: !this.joined,\n            },\n        }).finish());\n        this._connected = true;\n        this.joined = true;\n        // Start heartbeats.\n        this.resetHeartbeat();\n    }\n    /**\n     * Disconnects from the group, marking us as not present.\n     *\n     * If you know the local user is about to go offline, try to call\n     * this method to let others know; otherwise, they will infer it from\n     * a timeout (default 10 seconds).\n     *\n     * Disconnection affects others' view of us, not our view of them.\n     * When disconnected, you may wish to treat others as offline even though\n     * CPresence still has their state.\n     */\n    disconnect() {\n        if (!this._connected)\n            return;\n        super.sendCRDT(PresenceMessage.encode({ disconnect: true }).finish());\n        this._connected = false;\n        // Stop heartbeats.\n        this.resetHeartbeat();\n    }\n    /**\n     * Whether we are connected.\n     */\n    get connected() {\n        return this._connected;\n    }\n    resetHeartbeat() {\n        if (this.heartbeatTimeout !== null)\n            clearTimeout(this.heartbeatTimeout);\n        if (this._connected) {\n            this.heartbeatTimeout = setTimeout(this.heartbeat, this.heartbeatInterval);\n        }\n        else\n            this.heartbeatTimeout = null;\n    }\n    receiveCRDT(message, meta, _crdtMeta) {\n        // Ignore own messages. Their methods emit their own events.\n        if (meta.isLocalOp)\n            return;\n        // Before joining (= first connection), ignore remote messages,\n        // in case they are being replayed as part of loading (hence are old).\n        // Instead, we'll get up-to-date states in response to joining.\n        if (!this.joined)\n            return;\n        const decoded = PresenceMessage.decode(message);\n        switch (decoded.type) {\n            case \"heartbeat\": {\n                this.processHeartbeat(null, meta.senderID, meta);\n                break;\n            }\n            case \"set\": {\n                const set = decoded.set;\n                if (set.isResponse && this.state.has(meta.senderID)) {\n                    // It's a response that (probably) just repeats our current state.\n                    // Treat as a heartbeat, to avoid a redundant event.\n                    this.processHeartbeat(null, meta.senderID, meta);\n                }\n                else {\n                    const value = this.updateSerializer.deserialize(set.value);\n                    this.processHeartbeat(value, meta.senderID, meta);\n                }\n                if (set.isJoin)\n                    this.sendResponse();\n                break;\n            }\n            case \"update\": {\n                // Single-field update.\n                const info = this.state.get(meta.senderID);\n                if (info === undefined) {\n                    // We don't have the state to update; treat as a heartbeat, which\n                    // will trigger us to request the full state.\n                    this.processHeartbeat(null, meta.senderID, meta);\n                }\n                else {\n                    const newValue = {\n                        ...info.value,\n                        ...this.updateSerializer.deserialize(decoded.update),\n                    };\n                    this.processHeartbeat(newValue, meta.senderID, meta);\n                }\n                break;\n            }\n            case \"disconnect\": {\n                // Delete the entry. If they reconnect, they'll resend their whole state.\n                const info = this.state.get(meta.senderID);\n                if (info !== undefined) {\n                    if (info.timeout !== null)\n                        clearTimeout(info.timeout);\n                    this.state.delete(meta.senderID);\n                    this._size--;\n                    this.emit(\"Delete\", { key: meta.senderID, value: info.value, meta });\n                }\n                break;\n            }\n            case \"request\": {\n                if (decoded.request === this.runtime.replicaID)\n                    this.sendResponse();\n                // Requests don't count as a heartbeat.\n                break;\n            }\n        }\n    }\n    /**\n     * @param time The time of receipt. Defaults to now.\n     */\n    processHeartbeat(newValue, senderID, meta, time = Date.now()) {\n        let info = this.state.get(senderID);\n        if (info === undefined) {\n            if (newValue === null) {\n                // The sender has state but we don't know it; request it.\n                // Send in a separate task because Collabs does not allow\n                // send-during-receive.\n                // OPT: Wait a bit after connecting, since our join may have already\n                // triggered a response.\n                setTimeout(() => super.sendCRDT(PresenceMessage.encode({\n                    request: senderID,\n                }).finish()), \n                // Requests don't count as heartbeats, so don't call resetHeartbeat().\n                0);\n                return;\n            }\n            else {\n                info = { value: newValue, present: false, time: 0, timeout: null };\n                this.state.set(senderID, info);\n            }\n        }\n        const previousValue = info.present\n            ? Optional.of(info.value)\n            : Optional.empty();\n        if (newValue !== null)\n            info.value = newValue;\n        if (info.timeout !== null)\n            clearTimeout(info.timeout);\n        // Loading might give us a causally newer value but with an earlier timestamp\n        // than our current value. Take the max to avoid going backwards.\n        info.time = Math.max(info.time, time);\n        const ttlRemaining = info.time + this.ttlMS - Date.now();\n        if (ttlRemaining > 0) {\n            // The entry is now present.\n            if (!info.present)\n                this._size++;\n            info.present = true;\n            info.timeout = setTimeout(() => this.processTimeout(senderID, nonNull(info), meta), ttlRemaining);\n            if (!previousValue.isPresent || newValue !== null) {\n                // The value changed (possibly from timedout to not-timedout)\n                // and is present.\n                // Note that we emit an event even if newValue was set/updated to\n                // a deep-equal value, including when updated with a === property value.\n                // That is consistent with CValueMap and CVar.\n                // However, we don't emit an event when a heartbeat causes us to\n                // keep the same value alive.\n                this.emit(\"Set\", {\n                    key: senderID,\n                    value: info.value,\n                    previousValue,\n                    meta,\n                });\n            }\n        }\n        else\n            info.timeout = null;\n    }\n    processTimeout(senderID, info, meta) {\n        info.timeout = null;\n        if (!info.present)\n            return;\n        info.present = false;\n        this._size--;\n        this.emit(\"Delete\", { key: senderID, value: info.value, meta });\n    }\n    /**\n     * If connected, sends our state in response to a request/join.\n     */\n    sendResponse() {\n        // Send in a separate task because Collabs does not allow\n        // send-during-receive.\n        // OPT: wait a minimum amount of time between responses, to avoid flooding\n        // at startup.\n        setTimeout(() => {\n            if (!this.connected)\n                return;\n            super.sendCRDT(PresenceMessage.encode({\n                set: {\n                    value: this.updateSerializer.serialize(nonNull(this.ourValue)),\n                    isResponse: true,\n                },\n            }).finish());\n            this.resetHeartbeat();\n        });\n    }\n    /**\n     * Returns our value, i.e., the value at key [[IRuntime.replicaID]].\n     */\n    getOurs() {\n        return this.ourValue ?? undefined;\n    }\n    /**\n     * Returns the value associated to key `replicaID`, or undefined if\n     * `replicaID` is not present.\n     */\n    get(replicaID) {\n        if (replicaID === this.runtime.replicaID)\n            return this.getOurs();\n        const info = this.state.get(replicaID);\n        if (info === undefined || !info.present)\n            return undefined;\n        return info.value;\n    }\n    /**\n     * Returns whether key `replicaID` is present in the map.\n     */\n    has(replicaID) {\n        return this.get(replicaID) !== undefined;\n    }\n    /**\n     * The number of present keys in the map.\n     */\n    get size() {\n        return this._size;\n    }\n    /**\n     * Returns an iterator for entries in the map.\n     *\n     * The iteration order is NOT eventually consistent:\n     * it may differ on replicas with the same value.\n     */\n    *entries() {\n        if (this.ourValue !== null)\n            yield [this.runtime.replicaID, this.ourValue];\n        for (const [key, info] of this.state) {\n            if (info.present)\n                yield [key, info.value];\n        }\n    }\n    /**\n     * Returns an iterator for entries in the map.\n     *\n     * The iteration order is NOT eventually consistent:\n     * it may differ on replicas with the same value.\n     */\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n     * Executes a provided function once for each (key, value) pair in\n     * the map, in the same order as [[entries]].\n     *\n     * @param callbackfn Function to execute for each value.\n     * Its arguments are the value, key, and this map.\n     * @param thisArg Value to use as `this` when executing `callbackfn`.\n     */\n    forEach(callbackfn, thisArg // eslint-disable-line @typescript-eslint/no-explicit-any\n    ) {\n        // Not sure if this gives the exact same semantics\n        // as Map if callbackfn modifies this during the\n        // loop.  (Given that Array.forEach has a rather\n        // funky polyfill on MDN, I expect Map.forEach is\n        // similarly funky.)  Although users probably shouldn't\n        // be doing that anyway.\n        for (const [key, value] of this) {\n            callbackfn.call(thisArg, value, key, this);\n        }\n    }\n    /**\n     * Returns an iterator for keys (replicaIDs) in the map.\n     *\n     * The iteration order is NOT eventually consistent:\n     * it may differ on replicas with the same state.\n     */\n    *keys() {\n        for (const [key] of this)\n            yield key;\n    }\n    /**\n     * Returns an iterator for values in the map.\n     *\n     * The iteration order is NOT eventually consistent:\n     * it may differ on replicas with the same state.\n     */\n    *values() {\n        for (const [, value] of this)\n            yield value;\n    }\n    saveCRDT() {\n        const state = {};\n        for (const [replicaID, info] of this.state) {\n            if (info.present) {\n                state[replicaID] = {\n                    value: this.updateSerializer.serialize(info.value),\n                    time: info.time,\n                };\n            }\n        }\n        if (this.connected) {\n            state[this.runtime.replicaID] = {\n                value: this.updateSerializer.serialize(nonNull(this.ourValue)),\n                time: Date.now(),\n            };\n        }\n        return PresenceSave.encode({\n            state,\n            saverID: this.runtime.replicaID,\n        }).finish();\n    }\n    loadCRDT(savedState, meta, crdtMeta) {\n        if (savedState === null)\n            return;\n        const decoded = PresenceSave.decode(savedState);\n        for (const [replicaID, infoSave] of Object.entries(decoded.state)) {\n            if (crdtMeta.remoteVectorClock.get(replicaID) >\n                crdtMeta.localVectorClock.get(replicaID)) {\n                // The saved entry is newer; use it.\n                // Note this also causes us to skip overwriting our own value.\n                const value = this.updateSerializer.deserialize(infoSave.value);\n                let time = int64AsNumber(infoSave.time);\n                if (time > Date.now()) {\n                    // Impossible future time due to clock drift.\n                    // Reverse the drift direction so that in case of clock desync,\n                    // both users timeout for each other simultaneously\n                    // (neglecting network latency).\n                    time = 2 * Date.now() - time;\n                }\n                // Process the value and emit events if appropriate.\n                this.processHeartbeat(value, decoded.saverID, meta, time);\n            }\n        }\n    }\n}\n/**\n * The default time-to-live: 10 seconds.\n */\nCPresence.TTL_MS_DEFAULT = 10000;\n//# sourceMappingURL=c_presence.js.map","import { CObject, ConstSerializer, } from \"@collabs/core\";\nimport { CMultiValueMap } from \"../map\";\nconst nullSerializer = new ConstSerializer(null);\n/**\n * Default aggregator: return the first item (first replicaID wins).\n */\nconst defaultAggregator = {\n    aggregate(items) {\n        return items[0].value;\n    },\n};\n/**\n * A collaborative variable of type T.\n *\n * A `CVar<T>` represents an opaque value of type T. Set and get the value with [[value]]. If multiple users\n * set the value concurrently, one of them is picked\n * arbitrarily.\n *\n * Values must be internally immutable;\n * mutating [[value]] internally will not change it on\n * other replicas. To store (a reference to) a *mutable*\n * value of type T, use a `CVar<CollabID<C>>`, where\n * C is a Collab representing T.\n * ([Example](https://collabs.readthedocs.io/en/latest/guide/data_modeling.html#minesweeper))\n *\n * See also: [[CBoolean]], [[CCounter]].\n *\n * @typeParam T The variable type.\n */\nexport class CVar extends CObject {\n    /**\n     * Constructs a CVar with the given `initialValue`.\n     * The `initialValue` is used as the value before any\n     * value is set or just after [[clear]] is called.\n     *\n     * @param options.valueSerializer Serializer for set\n     * values. Defaults to [[DefaultSerializer]].\n     * @param options.aggregator If provided, used\n     * to \"aggregate\" concurrently-set values,\n     * instead of picking one arbitrarily.\n     */\n    constructor(init, initialValue, options = {}) {\n        super(init);\n        const aggregator = options.aggregator ?? defaultAggregator;\n        this.mvMap = super.registerCollab(\"\", (init) => new CMultiValueMap(init, {\n            keySerializer: nullSerializer,\n            valueSerializer: options.valueSerializer,\n            aggregator: options.aggregator,\n        }));\n        this.mvMap.on(\"Any\", (e) => {\n            const previousValue = this._value;\n            const items = this.mvMap.get(null);\n            this._value =\n                items === undefined ? initialValue : aggregator.aggregate(items);\n            // Note that we emit a Set event even when the new value ===\n            // the old value. That is useful if you are maintaining a view\n            // of conflicts(): it tells you to refresh the view\n            // even when the winning value doesn't change.\n            this.emit(\"Set\", { value: this._value, previousValue, meta: e.meta });\n        });\n        this._value = initialValue;\n    }\n    /**\n     * Sets the current value. Equivalent to `this.value = value`.\n     *\n     * @returns `value`\n     */\n    set(value) {\n        this.mvMap.set(null, value);\n        return this._value;\n    }\n    set value(value) {\n        this.set(value);\n    }\n    get value() {\n        return this._value;\n    }\n    /**\n     * Returns all conflicting concurrently-set values.\n     * Their order is arbitrary but consistent across replicas.\n     *\n     * If this CVar was just initialized or [[clear]]\n     * was just called, this returns `[]`. Otherwise, its first\n     * element is the set value.\n     */\n    conflicts() {\n        return (this.mvMap.get(null) ?? []).map((item) => item.value);\n    }\n    /**\n     * Resets this CVar to its initial state, so that its\n     * value is the constructor's `initialValue`.\n     *\n     * Unlike directly setting the value to `initialValue`,\n     * this operation clears the [[conflicts]] set, and\n     * a concurrent set-[[value]] operation will always\n     * win over this operation.\n     *\n     * A cleared CVar satisfies [[Collab.canGC]] and so can be\n     * \"garbage collected\" by [[CLazyMap]].\n     */\n    clear() {\n        this.mvMap.delete(null);\n    }\n    toString() {\n        return `${this.value}`;\n    }\n}\n//# sourceMappingURL=c_var.js.map","import { CVar } from \"../var\";\nconst trueBytes = new Uint8Array();\nconst falseBytes = new Uint8Array(1);\nconst BooleanSerializer = {\n    serialize(value) {\n        return value ? trueBytes : falseBytes;\n    },\n    deserialize(message) {\n        return message.length === 0;\n    },\n};\nconst TrueWinsAggregator = {\n    aggregate(items) {\n        // True if there are any true values.\n        return items.find((item) => item.value) !== undefined;\n    },\n};\nconst FalseWinsAggregator = {\n    aggregate(items) {\n        // False if there are any false values.\n        return items.find((item) => !item.value) === undefined;\n    },\n};\n/**\n * A collaborative `boolean` value.\n *\n * Set and get the value with [[value]]. If multiple\n * users set the value to `true` and `false` concurrently,\n * then the value is given by the constructor's `winner` option\n * (default: `true`).\n *\n * See also: [[CVar]]`<boolean>`.\n */\nexport class CBoolean extends CVar {\n    /**\n     * Constructs a CBoolean.\n     *\n     * @param options.winner The winner among concurrent sets.\n     * Default: `true`.\n     * @param options.initialValue The initial value, used before any\n     * value is set or just after [[clear]] is called. Default: `false`.\n     */\n    constructor(init, options = {}) {\n        const winner = options.winner ?? true;\n        const initialValue = options.initialValue ?? false;\n        super(init, initialValue, {\n            valueSerializer: BooleanSerializer,\n            aggregator: winner ? TrueWinsAggregator : FalseWinsAggregator,\n        });\n    }\n}\n//# sourceMappingURL=c_boolean.js.map","import { CPrimitive, nonNull, protobufHas, } from \"@collabs/core\";\nimport { TotalOrderCreateMessage, TotalOrderSave, } from \"../../generated/proto_compiled\";\nconst RADIX = 36;\n/**\n * A waypoint in the tree of positions. See\n * [[CTotalOrder]] for a description of the tree.\n *\n * Each waypoint is identified by its pair ([[senderID]], [[counter]]).\n */\nexport class Waypoint {\n    constructor(\n    /**\n     * The waypoint sender's replicaID, or\n     * \"\" for the root waypoint.\n     */\n    senderID, \n    /**\n     * A counter for waypoints sent by [[senderID]].\n     * Starts at 0 and increases contiguously.\n     */\n    counter, \n    /**\n     * The waypoint for this waypoint's parent position,\n     * or null if this is the root waypoint.\n     */\n    parentWaypoint, \n    /**\n     * The valueIndex for this waypoint's parent position.\n     *\n     * Unspecified for the root waypoint.\n     */\n    parentValueIndex, \n    /**\n     * This waypoint's side: a right (true) or left (false) child of\n     * the parent position.\n     */\n    isRight) {\n        this.senderID = senderID;\n        this.counter = counter;\n        this.parentWaypoint = parentWaypoint;\n        this.parentValueIndex = parentValueIndex;\n        this.isRight = isRight;\n        /**\n         * This waypoint's child waypoints in sort order: left children\n         * by valueIndex, then right children by reverse valueIndex,\n         * with ties broken by senderID.\n         *\n         * Only [[CTotalOrder]] may mutate this array.\n         */\n        this.children = [];\n    }\n}\n/**\n * A collaborative abstract total order on [[Position]]s.\n *\n * This is a low-level API intended for internal use by list CRDT implementations.\n * In most apps, you are better off using [[CValueList]] or [[CList]].\n *\n * A CTotalOrder represents the core of a list CRDT: a collaborative\n * list of Positions\n * that can be expanded over time, but without any associated values.\n * Instead, you use a [[LocalList]] to map a subset of Positions to\n * values, in list order with indexed access.\n * Note that LocalList is a local (non-collaborative) data structure, i.e.,\n * its value assignments are not automatically replicated.\n *\n * ### Waypoints\n *\n * Internally, CTotalOrder stores an append-only log of [[Waypoint]]s.\n * The allowed [[Position]]s correspond to pairs (waypoint, valueIndex)\n * where waypoint is an existing Waypoint and\n * valueIndex is a nonnegative number. Methods [[decode]],\n * [[encode]], and [[encodeAll]] convert between the two representations.\n *\n * Note that waypoints and positions are only created, never destroyed.\n * To create new positions (creating a new waypoint if needed),\n * call [[createPositions]].\n *\n * ### List Order\n *\n * The positions are ordered using a tree.\n * Each waypoint's positions form a descending, left-to-right branch\n * in the tree rooted at the position with valueIndex 0.\n * The position with valueIndex 0 is a child of the waypoint's\n * parent position, on the side given by [[Waypoint.isRight]].\n *\n * The position order is then an in-order traversal of this tree:\n * we traverse a position's left children, then visit\n * the position, then traverse its right children.\n * Same-side siblings are ordered by the tiebreakers:\n * - A position belonging to the same waypoint as the parent\n * (just with valueIndex + 1) is to the left of any other siblings.\n * - Other siblings (each belonging to different waypoints and with\n * valueIndex 0) are sorted lexicographically by their waypoints'\n * [[Waypoint.senderID]]s. We call these *waypoint children*.\n *\n * Note that positions belonging to the same waypoint are contiguous\n * when first created. Later, (left-side) waypoint children may\n * appear between them.\n */\nexport class CTotalOrder extends CPrimitive {\n    /**\n     * Constructs a CTotalOrder.\n     */\n    constructor(init) {\n        super(init);\n        /**\n         * Map key is waypoint.senderID, index in the array is waypoint.counter.\n         */\n        this.waypointsByID = new Map();\n        /**\n         * Tracks waypoints created by this specific object (i.e., the current\n         * replica & session). These are the only waypoints that we can\n         * extend, to prevent multiple users from extending a waypoint\n         * concurrently (giving non-unique positions).\n         *\n         * Each waypoint maps to the next valueIndex to create for that waypoint.\n         *\n         * This state is ephemeral (not saved), since a future loader will\n         * be in a different session.\n         */\n        this.ourWaypoints = new Map();\n        this.rootWaypoint = new Waypoint(\"\", 0, null, 0, true);\n        this.waypointsByID.set(\"\", [this.rootWaypoint]);\n    }\n    /**\n     * Creates `count` new positions between prevPosition and nextPosition.\n     * The positions are created collaboratively\n     * (replicated on all devices).\n     *\n     * If !(prevPosition < nextPosition), behavior is undefined.\n     *\n     * Note that this might not actually send a message.\n     *\n     * @param prevPosition The previous position, or null to\n     * create positions at the beginning of the list.\n     * @param nextPosition The next position, or null to\n     * create positions at the end of the list.\n     * @param count The number of positions to create.\n     * @returns The created [[Position]]s, in list order.\n     * Internally, they use the same waypoint with contiguously\n     * increasing valueIndex.\n     * @throws If count <= 0.\n     */\n    createPositions(prevPosition, nextPosition, count) {\n        if (prevPosition !== null && prevPosition === nextPosition) {\n            throw new Error(\"prevPosition == nextPosition\");\n        }\n        if (count <= 0)\n            throw new Error(`count is <= 0: ${count}`);\n        const [prevWaypoint, prevValueIndex] = prevPosition === null\n            ? [this.rootWaypoint, 0]\n            : this.decode(prevPosition);\n        // If nextPosition is a (right) descendant of prevPosition,\n        // create a new left descendant of nextPosition.\n        if (nextPosition !== null) {\n            const [nextWaypoint, nextValueIndex] = this.decode(nextPosition);\n            if (this.isDescendant(nextWaypoint, nextValueIndex, prevWaypoint, prevValueIndex)) {\n                // Create a new left descendant of nextPosition.\n                // We don't create always create a left *child* of nextPosition because\n                // there could be left child tombstones already.\n                // Instead, create a new left child of its leftmost descendant.\n                const [parentWaypoint, parentValueIndex] = this.leftmostDescendant(nextWaypoint, nextValueIndex);\n                return this.createChildren(parentWaypoint, parentValueIndex, false, count);\n            }\n        }\n        // Else we can go anywhere in prevPosition's right subtree.\n        // First see if we can extend prevWaypoint.\n        const extendValueIndex = this.ourWaypoints.get(prevWaypoint);\n        if (extendValueIndex !== undefined) {\n            // It's our waypoint, so we can extend it.\n            this.ourWaypoints.set(prevWaypoint, extendValueIndex + count);\n            return this.encodeAll(prevWaypoint, extendValueIndex, count);\n        }\n        // Next, see if we can create a new right child of prevPosition.\n        // We won't do this if there is already a (tombstone) right child\n        // of prevPosition.\n        const existingRight = this.firstRightChild(prevWaypoint, prevValueIndex);\n        if (existingRight === null) {\n            // Create a new right child of prevPosition.\n            // This is better than creating a left child of\n            // [prevWaypoint, prevValueIndex + 1] because it will be ordered after\n            // concurrently-created extensions of prevWaypoint (same-author gets\n            // non-interleaving priority).\n            return this.createChildren(prevWaypoint, prevValueIndex, true, count);\n        }\n        else {\n            // Treat (child, 0) like nextPosition. Since it's a descendant of\n            // prevPosition, we create a new leftmost descendant of child.\n            const parentWaypoint = this.leftmostDescendant0(existingRight);\n            return this.createChildren(parentWaypoint, 0, false, count);\n        }\n    }\n    /**\n     * Returns whether [aWaypoint, aValueIndex] is a descendant of [bWaypoint, bValueIndex].\n     * This includes valueIndex descendant relationships.\n     */\n    isDescendant(aWaypoint, aValueIndex, bWaypoint, bValueIndex) {\n        if (aWaypoint === bWaypoint)\n            return aValueIndex >= bValueIndex;\n        // Walk up the waypoint tree from a until we reach either a child of\n        // bWaypoint or the root.\n        let current = aWaypoint;\n        while (current.parentWaypoint !== bWaypoint) {\n            if (current.parentWaypoint === null) {\n                // We've reached current == root without encountering bWaypoint;\n                // it's not a descendant.\n                return false;\n            }\n            current = current.parentWaypoint;\n        }\n        // Now current's parent's waypoint is bWaypoint.\n        // See if the parent is a descendant of [bWaypoint, bValueIndex].\n        if (current.parentValueIndex > bValueIndex)\n            return true;\n        else if (current.parentValueIndex === bValueIndex)\n            return current.isRight;\n        else\n            return false;\n    }\n    /**\n     * Returns the (waypoint', valueIndex') for the leftmost\n     * descendant of (waypoint, valueIndex).\n     */\n    leftmostDescendant(waypoint, valueIndex) {\n        for (const child of waypoint.children) {\n            if (!child.isRight && child.parentValueIndex === valueIndex) {\n                // Found the first left child of the input.\n                return [this.leftmostDescendant0(child), 0];\n            }\n            else if (child.isRight || child.parentValueIndex > valueIndex) {\n                // We're past where a left child of the input would be\n                // without finding one.\n                break;\n            }\n        }\n        // The input has no left children, hence is its own\n        // leftmost descendant.\n        return [waypoint, valueIndex];\n    }\n    /**\n     * Returns the waypoint for the leftmost descendant of\n     * (waypoint, 0). The leftmost descendant\n     * is (returned waypoint, 0).\n     */\n    leftmostDescendant0(waypoint) {\n        // The leftmost child of a waypoint is always a child of\n        // its valueIndex 0.\n        let current = waypoint;\n        while (current.children.length > 0) {\n            const firstChild = current.children[0];\n            if (firstChild.parentValueIndex === 0 && !firstChild.isRight) {\n                current = firstChild;\n            }\n            else\n                break;\n        }\n        return current;\n    }\n    /**\n     * Returns the waypoint of the first right child of [waypoint, valueIndex],\n     * or null if it has no right children.\n     */\n    firstRightChild(waypoint, valueIndex) {\n        for (const child of waypoint.children) {\n            if (child.parentValueIndex === valueIndex && child.isRight)\n                return child;\n        }\n        return null;\n    }\n    createChildren(parentWaypoint, parentValueIndex, isRight, count) {\n        const message = {\n            parentWaypointSenderID: parentWaypoint.senderID === this.runtime.replicaID\n                ? undefined\n                : parentWaypoint.senderID,\n            parentWaypointCounterAndSide: this.valueAndSideEncode(parentWaypoint.counter, isRight),\n            parentValueIndex,\n        };\n        this.sendPrimitive(TotalOrderCreateMessage.encode(message).finish());\n        // Our new waypoint is last in our waypointsByID array.\n        const ourArray = nonNull(this.waypointsByID.get(this.runtime.replicaID));\n        const newWaypoint = ourArray[ourArray.length - 1];\n        // Record created positions in ourWaypoints.\n        this.ourWaypoints.set(newWaypoint, count);\n        // Return created positions.\n        return this.encodeAll(newWaypoint, 0, count);\n    }\n    valueAndSideEncode(value, isRight) {\n        return isRight ? value : ~value;\n    }\n    valueAndSideDecode(valueAndSide) {\n        const isRight = valueAndSide >= 0;\n        const value = isRight ? valueAndSide : ~valueAndSide;\n        return [value, isRight];\n    }\n    receivePrimitive(message, meta) {\n        const decoded = TotalOrderCreateMessage.decode(message);\n        // Get parentWaypoint.\n        const parentWaypointSender = protobufHas(decoded, \"parentWaypointSenderID\")\n            ? nonNull(decoded.parentWaypointSenderID)\n            : meta.senderID;\n        const [parentWaypointCounter, isRight] = this.valueAndSideDecode(decoded.parentWaypointCounterAndSide);\n        const parentWaypoint = this.getWaypoint(parentWaypointSender, parentWaypointCounter);\n        let senderWaypoints = this.waypointsByID.get(meta.senderID);\n        if (senderWaypoints === undefined) {\n            senderWaypoints = [];\n            this.waypointsByID.set(meta.senderID, senderWaypoints);\n        }\n        const waypoint = new Waypoint(meta.senderID, senderWaypoints.length, parentWaypoint, decoded.parentValueIndex, isRight);\n        // Store the waypoint.\n        senderWaypoints.push(waypoint);\n        this.addToChildren(waypoint);\n    }\n    /**\n     * Adds newWaypoint to parentWaypoint.childWaypoints\n     * in the proper order.\n     */\n    addToChildren(newWaypoint) {\n        // Recall child waypoints' sort order: left children\n        // by valueIndex, then right children by reverse valueIndex.\n        const children = nonNull(newWaypoint.parentWaypoint).children;\n        // Find i, the index of the first entry after newWaypoint.\n        // OPT: If children is large, use binary search.\n        let i = 0;\n        for (; i < children.length; i++) {\n            if (this.isSiblingLess(newWaypoint, children[i]))\n                break;\n        }\n        children.splice(i, 0, newWaypoint);\n    }\n    /**\n     * Returns true if sibling1 < sibling2 in the sibling order.\n     */\n    isSiblingLess(sibling1, sibling2) {\n        // Recall child order: left children ordered by\n        // valueIndex, then right children ordered by\n        // reverse valueIndex. senderID tiebreaker.\n        if (sibling1.isRight === sibling2.isRight) {\n            if (sibling1.parentValueIndex === sibling2.parentValueIndex) {\n                // senderID order. Identical senderIDs are impossible.\n                return sibling1.senderID < sibling2.senderID;\n            }\n            else {\n                // isRight: reverse valueIndex order;\n                // isLeft: valueIndex order.\n                // Use === as XNOR.\n                return (sibling1.isRight ===\n                    sibling1.parentValueIndex > sibling2.parentValueIndex);\n            }\n        }\n        else\n            return sibling2.isRight;\n    }\n    /**\n     * Returns the waypoint with the given senderID and counter,\n     * throwing an error if it does not exist.\n     */\n    getWaypoint(senderID, counter) {\n        const bySender = this.waypointsByID.get(senderID);\n        if (bySender === undefined) {\n            throw new Error(\"Invalid position: unknown senderID\");\n        }\n        if (counter < 0) {\n            throw new Error(\"Invalid position: counter < 0\");\n        }\n        if (counter >= bySender.length) {\n            throw new Error(\"Invalid position: unknown counter\");\n        }\n        return bySender[counter];\n    }\n    /**\n     * Returns the [[Position]] representation of (waypoint, valueIndex).\n     *\n     * Invert with [[decode]].\n     */\n    encode(waypoint, valueIndex) {\n        // OPT: more efficient number encodings?\n        return `${waypoint.counter.toString(RADIX)}.${valueIndex.toString(RADIX)},${waypoint.senderID}`;\n    }\n    /**\n     * Returns the positions representing (waypoint, valueIndex + i)\n     * for i in range [0, count).\n     */\n    encodeAll(waypoint, valueIndex, count) {\n        const ans = new Array(count);\n        for (let i = 0; i < count; i++) {\n            ans[i] = this.encode(waypoint, valueIndex + i);\n        }\n        return ans;\n    }\n    /**\n     * Returns the pair (waypoint, valueIndex) encoded by `position`,\n     * throwing an error if the position is invalid.\n     *\n     * Invert with [[encode]].\n     */\n    decode(position) {\n        const dot = position.indexOf(\".\");\n        const comma = position.indexOf(\",\", dot);\n        const counter = Number.parseInt(position.slice(0, dot), RADIX);\n        const valueIndex = Number.parseInt(position.slice(dot + 1, comma), RADIX);\n        const senderID = position.slice(comma + 1);\n        if (dot === -1 || comma === -1 || isNaN(counter) || isNaN(valueIndex)) {\n            throw new Error(`Not a Position: ${position}`);\n        }\n        const waypoint = this.getWaypoint(senderID, counter);\n        if (valueIndex < 0) {\n            throw new Error(`Invalid valueIndex < 0: ${valueIndex}`);\n        }\n        return [waypoint, valueIndex];\n    }\n    savePrimitive() {\n        const replicaIDs = [];\n        const replicaCounts = [];\n        // Maps replicaIDs to the first index corresponding\n        // to that replicaID in parentWaypoints.\n        const startIndices = new Map();\n        let index = 0;\n        for (const [replicaID, waypoints] of this.waypointsByID) {\n            if (replicaID === \"\")\n                continue;\n            replicaIDs.push(replicaID);\n            replicaCounts.push(waypoints.length);\n            startIndices.set(replicaID, index);\n            index += waypoints.length;\n        }\n        const parentWaypoints = [];\n        const parentValueIndexAndSides = [];\n        for (const waypoints of this.waypointsByID.values()) {\n            for (const waypoint of waypoints) {\n                if (waypoint !== this.rootWaypoint) {\n                    const parentWaypoint = nonNull(waypoint.parentWaypoint);\n                    if (parentWaypoint === this.rootWaypoint) {\n                        parentWaypoints.push(0);\n                    }\n                    else {\n                        parentWaypoints.push(1 +\n                            nonNull(startIndices.get(parentWaypoint.senderID)) +\n                            parentWaypoint.counter);\n                    }\n                    parentValueIndexAndSides.push(this.valueAndSideEncode(waypoint.parentValueIndex, waypoint.isRight));\n                }\n            }\n        }\n        const message = TotalOrderSave.create({\n            replicaIDs,\n            replicaCounts,\n            parentWaypoints,\n            parentValueIndexAndSides,\n        });\n        return TotalOrderSave.encode(message).finish();\n    }\n    loadPrimitive(savedState, _meta) {\n        if (savedState === null)\n            return;\n        const decoded = TotalOrderSave.decode(savedState);\n        // Create new waypoints, merging the saved state into ours.\n        // For replicaID's in order, the first new counter value.\n        const counterStarts = [];\n        // All of the savedState's waypoints in the order that decoded.parentWaypoints\n        // indexes into: root, then same order as parentWaypoints.\n        const statesWaypoints = [this.rootWaypoint];\n        // replicaID's first index into decoded.parentWaypoints.\n        let replicaStartIndex = 0;\n        for (let i = 0; i < decoded.replicaIDs.length; i++) {\n            const replicaID = decoded.replicaIDs[i];\n            const replicaCount = decoded.replicaCounts[i];\n            let byID = this.waypointsByID.get(replicaID);\n            if (byID === undefined) {\n                byID = [];\n                this.waypointsByID.set(replicaID, byID);\n            }\n            // Counter values [byID.length, replicaCount) are new.\n            counterStarts.push(byID.length);\n            for (let j = byID.length; j < replicaCount; j++) {\n                // Index into decoded.parentWaypoints.\n                const index = replicaStartIndex + j;\n                const newWaypoint = new Waypoint(replicaID, j, \n                // Temporarily null in case the parent doesn't exist yet.\n                // This is not externally visible.\n                null, ...this.valueAndSideDecode(decoded.parentValueIndexAndSides[index]));\n                byID.push(newWaypoint);\n            }\n            // Counter values [0, replicaCount) are known to savedState.\n            for (let j = 0; j < replicaCount; j++)\n                statesWaypoints.push(byID[j]);\n            replicaStartIndex += replicaCount;\n        }\n        // Now that all waypoints are created, for each new waypoint,\n        // fill in its parentWaypoint and add it to parentWaypoint.childWaypoints.\n        replicaStartIndex = 0;\n        for (let i = 0; i < decoded.replicaIDs.length; i++) {\n            const replicaID = decoded.replicaIDs[i];\n            const replicaCount = decoded.replicaCounts[i];\n            const counterStart = counterStarts[i];\n            const byID = nonNull(this.waypointsByID.get(replicaID));\n            // Counter values [counterStart, replicaCount) are new.\n            for (let j = counterStart; j < replicaCount; j++) {\n                // Index into decoded.parentWaypoints.\n                const index = replicaStartIndex + j;\n                const newWaypoint = byID[j];\n                // @ts-expect-error Override readonly parentWaypoint.\n                newWaypoint.parentWaypoint =\n                    statesWaypoints[decoded.parentWaypoints[index]];\n                this.addToChildren(newWaypoint);\n            }\n            replicaStartIndex += replicaCount;\n        }\n    }\n}\n//# sourceMappingURL=c_total_order.js.map","import { nonNull } from \"@collabs/core\";\nimport { LocalListSave } from \"../../generated/proto_compiled\";\n/**\n * A local (non-collaborative) data structure mapping [[Position]]s to\n * values, in list order.\n *\n * You can use a LocalList to maintain a sorted, indexable view of a\n * [[CValueList]], [[CList]], or [[CText]]'s values.\n * For example, when using a [[CList]],\n * you could store its archived values in a LocalList.\n * That would let you iterate over the archived values in list order.\n *\n * To construct a LocalList that uses an existing list's positions, pass\n * that list's `totalOrder` to our constructor.\n *\n * It is *not* safe to modify a LocalList while iterating over it. The iterator\n * will attempt to throw an exception if it detects such modification,\n * but this is not guaranteed.\n *\n * @typeParam T The value type.\n */\nexport class LocalList {\n    /**\n     * Constructs a LocalList whose allowed [[Position]]s are given by\n     * `source`.\n     *\n     * Using positions that were not generated by `source` (or a replica of\n     * `source`) will cause undefined behavior.\n     *\n     * @param source The source for positions that may be used with this\n     * LocalList.\n     */\n    constructor(source) {\n        this.source = source;\n        /**\n         * Includes all seen entries, even if they currently have total = 0.\n         */\n        this.valuesByWaypoint = new Map();\n        this._inInitialState = true;\n        /**\n         * State machine used to attempt to throw an exception if this is modified\n         * during an iterator: specifically, if a modification happens\n         * between when an iterator starts and when it yields some value.\n         *\n         * False negatives are possible if there are simultaneous iterators.\n         * One can prove that false positives are not possible.\n         *\n         * Transitions:\n         * - *     -> \"iter\"          : When an iterator starts.\n         * - *     -> \"mod\"           : When a mutation starts.\n         * - \"mod\" -> throw exception : Before an iterator yields contiguous values.\n         */\n        this.iterFailFast = \"mod\";\n    }\n    /**\n     * Sets the value at position.\n     */\n    set(position, value) {\n        this._inInitialState = false;\n        const [waypoint, valueIndex] = this.source.decode(position);\n        const info = this.valuesByWaypoint.get(waypoint);\n        if (info === undefined) {\n            // Waypoint has no values currently; set them to\n            // [valueIndex, [value]].\n            // Except, omit 0s.\n            const newItems = valueIndex === 0 ? [[value]] : [valueIndex, [value]];\n            this.valuesByWaypoint.set(waypoint, {\n                total: 0,\n                seen: valueIndex + 1,\n                items: newItems,\n            });\n            this.updateTotals(waypoint, 1);\n            return;\n        }\n        const items = info.items;\n        let remaining = valueIndex;\n        for (let i = 0; i < items.length; i++) {\n            const curItem = items[i];\n            if (typeof curItem !== \"number\") {\n                if (remaining < curItem.length) {\n                    // Already present. Replace the current value.\n                    curItem[remaining] = value;\n                    // Don't update info.seen: already seen.\n                    return;\n                }\n                else\n                    remaining -= curItem.length;\n            }\n            else {\n                if (remaining < curItem) {\n                    // Replace curItem with\n                    // [remaining, [value], curItem - 1 - remaining].\n                    // Except, omit 0s and combine [value] with\n                    // neighboring arrays if needed.\n                    let startIndex = i;\n                    let deleteCount = 1;\n                    const newItems = [[value]];\n                    if (remaining !== 0) {\n                        newItems.unshift(remaining);\n                    }\n                    else if (i !== 0) {\n                        // Combine [value] with left neighbor.\n                        startIndex--;\n                        deleteCount++;\n                        newItems[0].unshift(...items[i - 1]);\n                    }\n                    if (remaining !== curItem - 1) {\n                        newItems.push(curItem - 1 - remaining);\n                    }\n                    else if (i !== items.length - 1) {\n                        // Combine [value] with right neighbor.\n                        deleteCount++;\n                        newItems[newItems.length - 1].push(...items[i + 1]);\n                    }\n                    items.splice(startIndex, deleteCount, ...newItems);\n                    this.updateTotals(waypoint, 1);\n                    // Don't update info.seen: already seen.\n                    return;\n                }\n                else\n                    remaining -= curItem;\n            }\n        }\n        // If we get here, the position is in the implied last item,\n        // which is deleted.\n        // Note that the actual last element of items is necessarily present.\n        if (remaining !== 0) {\n            items.push(remaining, [value]);\n        }\n        else {\n            if (items.length === 0)\n                items.push([value]);\n            else {\n                // Merge value with the preceding present item.\n                items[items.length - 1].push(value);\n            }\n        }\n        info.seen = Math.max(info.seen, valueIndex + 1);\n        this.updateTotals(waypoint, 1);\n    }\n    /**\n     * Optimized variant of [[set]] for newly-created positions.\n     *\n     * If you (or a remote replica) just created `values.count`\n     * positions using [[CTotalOrder.createPosition]], you may call\n     * this method with the first created position and the values to\n     * set at the created positions. This may be faster than\n     * calling [[set]] on each (position, value) individually.\n     *\n     * @param firstPos The position for values[0].\n     * @param values The values to set.\n     * @throws If firstPos has been seen before, i.e., it or a later\n     * position has been set.\n     */\n    setCreated(firstPos, values) {\n        if (values.length === 0)\n            return;\n        this._inInitialState = false;\n        const [waypoint, valueIndex] = this.source.decode(firstPos);\n        const info = this.valuesByWaypoint.get(waypoint);\n        if (info === undefined) {\n            // Waypoint has no values currently; set them to\n            // [valueIndex, values].\n            // Except, omit 0s.\n            values = values.slice();\n            const newItems = valueIndex === 0 ? [values] : [valueIndex, values];\n            this.valuesByWaypoint.set(waypoint, {\n                total: 0,\n                seen: valueIndex + values.length,\n                items: newItems,\n            });\n        }\n        else {\n            if (valueIndex < info.seen) {\n                throw new Error(\"setCreated called on seen positions\");\n            }\n            // Get number of existing positions in info (which omits the\n            // final deleted items).\n            let existing = 0;\n            for (const item of info.items) {\n                existing += typeof item === \"number\" ? item : item.length;\n            }\n            if (existing < valueIndex) {\n                // Fill in deleted positions before values.\n                info.items.push(valueIndex - existing, values.slice());\n            }\n            else if (existing === valueIndex) {\n                if (info.items.length === 0) {\n                    info.items.push(values.slice());\n                }\n                else {\n                    // Merge with previous (present) item.\n                    info.items[info.items.length - 1].push(...values);\n                }\n            }\n            else {\n                throw new Error(\"setCreated called on seen positions\");\n            }\n            info.seen = Math.max(info.seen, valueIndex + values.length);\n        }\n        this.updateTotals(waypoint, values.length);\n    }\n    /**\n     * Deletes the given position, making it no longer\n     * present in this list.\n     *\n     * @returns Whether the position was actually deleted, i.e.,\n     * it was initially present.\n     */\n    delete(position) {\n        this._inInitialState = false;\n        const [waypoint, valueIndex] = this.source.decode(position);\n        const info = this.valuesByWaypoint.get(waypoint);\n        if (info === undefined) {\n            // Already not present.\n            return false;\n        }\n        const items = info.items;\n        let remaining = valueIndex;\n        for (let i = 0; i < items.length; i++) {\n            const curItem = items[i];\n            if (typeof curItem === \"number\") {\n                if (remaining < curItem) {\n                    // Already not present.\n                    return false;\n                }\n                else\n                    remaining -= curItem;\n            }\n            else {\n                if (remaining < curItem.length) {\n                    // Replace curItem[remaining] with\n                    // [curItem[:remaining], 1, curItem[remaining+1:]].\n                    // Except, omit empty slices and combine the 1 with\n                    // neighboring numbers if needed.\n                    let startIndex = i;\n                    let deleteCount = 1;\n                    const newItems = [1];\n                    if (remaining !== 0) {\n                        newItems.unshift(curItem.slice(0, remaining));\n                    }\n                    else if (i !== 0) {\n                        // Combine 1 with left neighbor.\n                        startIndex--;\n                        deleteCount++;\n                        newItems[0] += items[i - 1];\n                    }\n                    if (remaining !== curItem.length - 1) {\n                        newItems.push(curItem.slice(remaining + 1));\n                    }\n                    else if (i !== items.length - 1) {\n                        // Combine 1 with right neighbor.\n                        deleteCount++;\n                        newItems[newItems.length - 1] += items[i + 1];\n                    }\n                    items.splice(startIndex, deleteCount, ...newItems);\n                    // If the last item is a number (deleted), omit it.\n                    if (typeof items[items.length - 1] === \"number\")\n                        items.pop();\n                    this.updateTotals(waypoint, -1);\n                    return true;\n                }\n                else\n                    remaining -= curItem.length;\n            }\n        }\n        // If we get here, the position is in the implied last item,\n        // hence is already deleted.\n        return false;\n    }\n    /**\n     * Changes total by delta for waypoint and all of its ancestors.\n     * Creates WaypointValues as needed.\n     *\n     * delta must not be 0.\n     *\n     * Also updates the iterFailFast state machine.\n     */\n    updateTotals(waypoint, delta) {\n        this.iterFailFast = \"mod\";\n        for (let current = waypoint; current !== null; current = current.parentWaypoint) {\n            const info = this.valuesByWaypoint.get(current);\n            if (info === undefined) {\n                // Create WaypointValues.\n                this.valuesByWaypoint.set(current, {\n                    // Nonzero by assumption.\n                    total: delta,\n                    seen: 0,\n                    // Omit last deleted item (= only item).\n                    items: [],\n                });\n            }\n            else {\n                info.total += delta;\n            }\n        }\n    }\n    // Omitting clear() for now because it is usually a mistake to use it.\n    // /**\n    //  * Deletes every value in the list.\n    //  */\n    // clear() {\n    //   this.valuesByWaypoint.clear();\n    // }\n    /**\n     * Returns the value at position, or undefined if it is not currently present\n     * ([[hasPosition]] returns false).\n     */\n    getByPosition(position) {\n        return this.locate(...this.source.decode(position))[0];\n    }\n    /**\n     * Returns whether position is currently present in the list,\n     * i.e., its value is present.\n     */\n    hasPosition(position) {\n        return this.locate(...this.source.decode(position))[1];\n    }\n    /**\n     * @returns [value at position, whether position is present,\n     * number of present values within waypoint\n     * (not descendants) strictly prior to position]\n     */\n    locate(waypoint, valueIndex) {\n        const info = this.valuesByWaypoint.get(waypoint);\n        if (info === undefined) {\n            // No values within waypoint.\n            return [undefined, false, 0];\n        }\n        let remaining = valueIndex;\n        let waypointValuesBefore = 0;\n        for (const item of info.items) {\n            if (typeof item === \"number\") {\n                if (remaining < item) {\n                    return [undefined, false, waypointValuesBefore];\n                }\n                else\n                    remaining -= item;\n            }\n            else {\n                if (remaining < item.length) {\n                    return [item[remaining], true, waypointValuesBefore + remaining];\n                }\n                else {\n                    remaining -= item.length;\n                    waypointValuesBefore += item.length;\n                }\n            }\n        }\n        // If we get here, then the valueIndex is after all present values.\n        return [undefined, false, waypointValuesBefore];\n    }\n    /**\n     * The nubmer of present values within waypoint (not descendants).\n     */\n    valueCount(waypoint) {\n        const info = this.valuesByWaypoint.get(waypoint);\n        if (info === undefined) {\n            // No values within waypoint.\n            return 0;\n        }\n        let waypointValues = 0;\n        for (const item of info.items) {\n            if (typeof item !== \"number\") {\n                waypointValues += item.length;\n            }\n        }\n        return waypointValues;\n    }\n    /**\n     * Returns the current index of position.\n     *\n     * If position is not currently present in the list\n     * ([[hasPosition]] returns false), then the result depends on searchDir:\n     * - \"none\" (default): Returns -1.\n     * - \"left\": Returns the next index to the left of position.\n     * If there are no values to the left of position,\n     * returns -1.\n     * - \"right\": Returns the next index to the right of position.\n     * If there are no values to the right of position,\n     * returns [[length]].\n     *\n     * To find the index where a position would be if\n     * present, use `searchDir = \"right\"`.\n     */\n    indexOfPosition(position, searchDir = \"none\") {\n        const [waypoint, valueIndex] = this.source.decode(position);\n        const [, isPresent, waypointValuesBefore] = this.locate(waypoint, valueIndex);\n        // Will be the total number of values prior to position.\n        let valuesBefore = waypointValuesBefore;\n        // Add totals for child waypoints that come before valueIndex.\n        // These are precisely the left children with\n        // parentValueIndex <= valueIndex.\n        for (const child of waypoint.children) {\n            if (child.isRight || child.parentValueIndex > valueIndex)\n                break;\n            valuesBefore += this.total(child);\n        }\n        // Walk up the tree and add totals for sibling values & waypoints\n        // that come before our ancestor.\n        for (let current = waypoint; current.parentWaypoint !== null; current = current.parentWaypoint) {\n            // Sibling values that come before current.\n            if (current.isRight) {\n                // All sibling values come before current.\n                valuesBefore += this.valueCount(current.parentWaypoint);\n            }\n            else {\n                valuesBefore += this.locate(current.parentWaypoint, current.parentValueIndex)[2];\n            }\n            // Sibling waypoints that come before current.\n            for (const child of current.parentWaypoint.children) {\n                if (child === current)\n                    break;\n                valuesBefore += this.total(child);\n            }\n        }\n        if (isPresent)\n            return valuesBefore;\n        else {\n            switch (searchDir) {\n                case \"none\":\n                    return -1;\n                case \"left\":\n                    return valuesBefore - 1;\n                case \"right\":\n                    return valuesBefore;\n            }\n        }\n    }\n    /**\n     * Returns the position currently at index.\n     */\n    getPosition(index) {\n        if (index < 0 || index >= this.length) {\n            throw new Error(`Index out of bounds: ${index} (length: ${this.length})`);\n        }\n        let remaining = index;\n        let waypoint = this.source.rootWaypoint;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            waypointLoop: {\n                for (const next of this.valuesAndChildren(waypoint)) {\n                    if (next.isValues) {\n                        const length = next.end - next.start;\n                        if (remaining < length) {\n                            // Answer is values[remaining].\n                            return this.source.encode(waypoint, next.valueIndex + remaining);\n                        }\n                        else\n                            remaining -= length;\n                    }\n                    else {\n                        if (remaining < next.total) {\n                            // Recurse into child.\n                            waypoint = next.child;\n                            break waypointLoop;\n                        }\n                        else\n                            remaining -= next.total;\n                    }\n                }\n                // We should always end by the break statement (recursion), not by\n                // the for loop's finishing.\n                throw new Error(\"Internal error: failed to find index among children\");\n            }\n        }\n    }\n    // /**\n    //  * For debugging: print entries() walk through the tree to console.log.\n    //  */\n    // printTreeWalk(): void {\n    //   if (this.length === 0) return;\n    //   let index = 0;\n    //   let waypoint: Waypoint | null = this.source.rootWaypoint;\n    //   console.log(\n    //     `\"${waypoint.senderID}\",${waypoint.counter}: ${this.total(\n    //       waypoint\n    //     )} [${index}, ${index + this.total(waypoint)})`\n    //   );\n    //   // Manage our own stack instead of recursing, to avoid stack overflow\n    //   // in deep trees.\n    //   const stack: IterableIterator<ValuesOrChild<T>>[] = [\n    //     // root will indeed have total != 0 since we checked length != 0.\n    //     this.valuesAndChildren(this.source.rootWaypoint),\n    //   ];\n    //   while (waypoint !== null) {\n    //     const iter = stack[stack.length - 1];\n    //     const next = iter.next();\n    //     if (next.done) {\n    //       stack.pop();\n    //       waypoint = waypoint.parentWaypoint;\n    //     } else {\n    //       const prefix = new Array(stack.length).fill(\" \").join(\" \");\n    //       const valuesOrChild = next.value;\n    //       if (valuesOrChild.isValues) {\n    //         console.log(\n    //           prefix,\n    //           `${valuesOrChild.valueIndex}:`,\n    //           JSON.stringify(\n    //             valuesOrChild.item.slice(valuesOrChild.start, valuesOrChild.end)\n    //           ),\n    //           `@ [${index}, ${index + valuesOrChild.end - valuesOrChild.start})`\n    //         );\n    //         index += valuesOrChild.end - valuesOrChild.start;\n    //       } else {\n    //         // Recurse into child.\n    //         waypoint = valuesOrChild.child;\n    //         console.log(\n    //           prefix,\n    //           `\"${waypoint.senderID},${waypoint.counter} (${\n    //             waypoint.parentValueIndex\n    //           }, ${waypoint.isRight ? \"R\" : \"L\"}): ${this.total(\n    //             waypoint\n    //           )} @ [${index}, ${index + this.total(waypoint)})`\n    //         );\n    //         stack.push(this.valuesAndChildren(waypoint));\n    //       }\n    //     }\n    //   }\n    // }\n    /**\n     * Returns the value currently at index.\n     *\n     * @throws If index is not in `[0, this.length)`.\n     * Note that this differs from an ordinary Array,\n     * which would instead return undefined.\n     */\n    get(index) {\n        // OPT: combine these operations\n        // Use ! instead of nonNull because T might allow null.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return this.getByPosition(this.getPosition(index));\n    }\n    /**\n     * The length of the list.\n     */\n    get length() {\n        return this.total(this.source.rootWaypoint);\n    }\n    /** Returns an iterator for values in the list, in list order. */\n    [Symbol.iterator]() {\n        return this.values();\n    }\n    /**\n     * Returns an iterator of [index, value, position] tuples for every\n     * value in the list, in list order.\n     */\n    *entries() {\n        if (this.length === 0)\n            return;\n        this.iterFailFast = \"iter\";\n        let index = 0;\n        let waypoint = this.source.rootWaypoint;\n        // Manage our own stack instead of recursing, to avoid stack overflow\n        // in deep trees.\n        const stack = [\n            // root will indeed have total != 0 since we checked length != 0.\n            this.valuesAndChildren(this.source.rootWaypoint),\n        ];\n        while (waypoint !== null) {\n            const iter = stack[stack.length - 1];\n            const next = iter.next();\n            if (next.done) {\n                stack.pop();\n                waypoint = waypoint.parentWaypoint;\n            }\n            else {\n                const valuesOrChild = next.value;\n                if (valuesOrChild.isValues) {\n                    // TypeScript thinks the type is \"iter\" because we set it above.\n                    // @ts-expect-error Could have changed during previous yield.\n                    if (this.iterFailFast === \"mod\") {\n                        throw new Error(\"LocalList modified while iterating over it\");\n                    }\n                    for (let i = 0; i < valuesOrChild.end - valuesOrChild.start; i++) {\n                        yield [\n                            index,\n                            valuesOrChild.item[valuesOrChild.start + i],\n                            this.source.encode(waypoint, valuesOrChild.valueIndex + i),\n                        ];\n                        index++;\n                    }\n                }\n                else {\n                    // Recurse into child.\n                    waypoint = valuesOrChild.child;\n                    stack.push(this.valuesAndChildren(waypoint));\n                }\n            }\n        }\n    }\n    /**\n     * Yields non-trivial values and Waypoint children\n     * for waypoint, in list order. This is used when\n     * iterating over the list.\n     *\n     * Specifically, it yields:\n     * - \"Sub-items\" consisting of a slice of a present item.\n     * - Waypoint children with non-zero total.\n     *\n     * together with enough info to infer their starting valueIndex's.\n     *\n     * @throws If valuesByWaypoint does not have an entry for waypoint.\n     */\n    *valuesAndChildren(waypoint) {\n        const items = nonNull(this.valuesByWaypoint.get(waypoint)).items;\n        const children = waypoint.children;\n        let childIndex = 0;\n        let startValueIndex = 0;\n        for (const item of items) {\n            const itemSize = typeof item === \"number\" ? item : item.length;\n            // After (next startValueIndex)\n            const endValueIndex = startValueIndex + itemSize;\n            // Next value to yield\n            let valueIndex = startValueIndex;\n            for (; childIndex < children.length; childIndex++) {\n                const child = children[childIndex];\n                if (child.isRight || child.parentValueIndex >= endValueIndex) {\n                    // child comes after item. End the loop and visit child\n                    // during the next item.\n                    break;\n                }\n                const total = this.total(child);\n                if (total !== 0) {\n                    // Emit child. If needed, first emit values that come before it.\n                    if (valueIndex < child.parentValueIndex) {\n                        if (typeof item !== \"number\") {\n                            yield {\n                                isValues: true,\n                                item,\n                                start: valueIndex - startValueIndex,\n                                end: child.parentValueIndex - startValueIndex,\n                                valueIndex,\n                            };\n                        }\n                        valueIndex = child.parentValueIndex;\n                    }\n                    yield { isValues: false, child, total };\n                }\n            }\n            // Emit remaining values in item.\n            if (typeof item !== \"number\" && valueIndex < endValueIndex) {\n                yield {\n                    isValues: true,\n                    item,\n                    start: valueIndex - startValueIndex,\n                    end: itemSize,\n                    valueIndex,\n                };\n            }\n            startValueIndex = endValueIndex;\n        }\n        // Visit remaining children (left children among a possible deleted\n        // final item (which items omits) and right children).\n        for (; childIndex < children.length; childIndex++) {\n            const child = children[childIndex];\n            const total = this.total(child);\n            if (this.total(child) !== 0) {\n                yield { isValues: false, child, total };\n            }\n        }\n    }\n    /**\n     * Returns the total number of present values at this\n     * waypoint and its descendants.\n     */\n    total(waypoint) {\n        return this.valuesByWaypoint.get(waypoint)?.total ?? 0;\n    }\n    /** Returns an iterator for values in the list, in list order. */\n    *values() {\n        // OPT: do own walk and yield* value items, w/o encoding positions.\n        for (const [, value] of this.entries())\n            yield value;\n    }\n    /** Returns an iterator for present positions, in list order. */\n    *positions() {\n        for (const [, , position] of this.entries())\n            yield position;\n    }\n    /**\n     * Returns a copy of a section of this list, as an array.\n     * For both start and end, a negative index can be used to indicate an offset from the end of the list.\n     * For example, -2 refers to the second to last element of the list.\n     * @param start The beginning index of the specified portion of the list.\n     * If start is undefined, then the slice begins at index 0.\n     * @param end The end index of the specified portion of the list. This is exclusive of the element at the index 'end'.\n     * If end is undefined, then the slice extends to the end of the list.\n     */\n    slice(start, end) {\n        const len = this.length;\n        if (start === undefined || start < -len) {\n            start = 0;\n        }\n        else if (start < 0) {\n            start += len;\n        }\n        else if (start >= len) {\n            return [];\n        }\n        if (end === undefined || end >= len) {\n            end = len;\n        }\n        else if (end < -len) {\n            end = 0;\n        }\n        else if (end < 0) {\n            end += len;\n        }\n        if (end <= start)\n            return [];\n        // Optimize common case (slice())\n        if (start === 0 && end === len) {\n            return [...this.values()];\n        }\n        else {\n            // OPT: optimize.\n            const ans = new Array(end - start);\n            for (let i = 0; i < end - start; i++) {\n                ans[i] = this.get(start + i);\n            }\n            return ans;\n        }\n    }\n    /**\n     * Returns the number of \"seen\" positions for `waypoint`.\n     *\n     * This is useful in some optimized list CRDTs.\n     *\n     * Specifically, the return value is 1 + the max valueIndex across\n     * all positions of the form `[waypoint, valueIndex]` that have\n     * been passed to [[set]] or [[setCreated]].\n     */\n    getSeen(waypoint) {\n        return this.valuesByWaypoint.get(waypoint)?.seen ?? 0;\n    }\n    // /**\n    //  * Returns an iterable of all nonzero return values from [[getSeen]].\n    //  *\n    //  * This is useful in some optimized list CRDTs.\n    //  */\n    // *seenEntries(): IterableIterator<[waypoint: Waypoint, seen: number]> {\n    //   for (const [waypoint, info] of this.valuesByWaypoint) {\n    //     if (info.seen !== 0) yield [waypoint, info.seen];\n    //   }\n    // }\n    /**\n     * Whether this list is in its initial state, i.e.,\n     * it has never been mutated.\n     */\n    get inInitialState() {\n        return this._inInitialState;\n    }\n    // OPT: other IList methods: utility accessors, positionOf?\n    // If so, call those from CRDT versions.\n    /**\n     * Returns saved state describing the current state of this LocalList,\n     * including its values.\n     *\n     * The saved state may later be passed to [[load]]\n     * on a new instance of LocalList, to reconstruct the\n     * same list state.\n     *\n     * @param valueArraySerializer Used to serialize values.\n     * Note that this may be called multiple times on distinct\n     * value arrays, and value arrays may contain non-contiguous values.\n     */\n    save(valueArraySerializer) {\n        const replicaIDs = [];\n        const replicaIDsInv = new Map();\n        replicaIDsInv.set(\"\", 0);\n        const replicaIDIndices = [];\n        const counters = [];\n        const totals = [];\n        const seens = [];\n        const itemsLengths = [];\n        const itemSizes = [];\n        const values = [];\n        for (const [waypoint, info] of this.valuesByWaypoint) {\n            let replicaIDIndex = replicaIDsInv.get(waypoint.senderID);\n            if (replicaIDIndex === undefined) {\n                replicaIDs.push(waypoint.senderID);\n                // 1-indexed\n                replicaIDIndex = replicaIDs.length;\n                replicaIDsInv.set(waypoint.senderID, replicaIDIndex);\n            }\n            replicaIDIndices.push(replicaIDIndex);\n            counters.push(waypoint.counter);\n            totals.push(info.total);\n            seens.push(info.seen);\n            itemsLengths.push(info.items.length);\n            for (const item of info.items) {\n                if (typeof item === \"number\") {\n                    itemSizes.push(-item);\n                }\n                else {\n                    itemSizes.push(item.length);\n                    values.push(...item);\n                }\n            }\n        }\n        const message = LocalListSave.create({\n            replicaIDs,\n            replicaIDIndices,\n            counters,\n            totals,\n            seens,\n            itemsLengths,\n            itemSizes,\n            values: valueArraySerializer.serialize(values),\n        });\n        return LocalListSave.encode(message).finish();\n    }\n    /**\n     * Loads saved state. The saved state must be from\n     * a call to [[save]] on a LocalList whose `source`\n     * constructor argument was a replica of this's\n     * `source`, so that we can understand the\n     * saved state's Positions.\n     *\n     * This method may only be called on a LocalList in\n     * its initial state (see [[inInitialState]]); it\n     * does not support \"merging\" in the sense of [[CRuntime.load]].\n     *\n     * @param savedState Saved state from another LocalList's\n     * [[save]] call.\n     * @param valueArraySerializer Used to deserialize values.\n     * Must be equivalent to [[save]]'s valueArraySerializer.\n     */\n    load(savedState, valueArraySerializer) {\n        if (!this._inInitialState) {\n            throw new Error(\"Can only call load in the initial state\");\n        }\n        this._inInitialState = false;\n        const decoded = LocalListSave.decode(savedState);\n        const values = valueArraySerializer.deserialize(decoded.values);\n        let sizesIndex = 0;\n        let valuesIndex = 0;\n        for (let i = 0; i < decoded.replicaIDIndices.length; i++) {\n            const replicaIDIndex = decoded.replicaIDIndices[i];\n            const replicaID = replicaIDIndex === 0 ? \"\" : decoded.replicaIDs[replicaIDIndex - 1];\n            const waypoint = this.source.getWaypoint(replicaID, decoded.counters[i]);\n            const info = {\n                total: decoded.totals[i],\n                seen: decoded.seens[i],\n                items: new Array(decoded.itemsLengths[i]),\n            };\n            for (let j = 0; j < decoded.itemsLengths[i]; j++) {\n                const itemSize = decoded.itemSizes[sizesIndex];\n                sizesIndex++;\n                if (itemSize < 0)\n                    info.items[j] = -itemSize;\n                else {\n                    info.items[j] = values.slice(valuesIndex, valuesIndex + itemSize);\n                    valuesIndex += itemSize;\n                }\n            }\n            this.valuesByWaypoint.set(waypoint, info);\n        }\n    }\n}\n//# sourceMappingURL=local_list.js.map","import { AbstractList_CObject, CObject, DefaultSerializer, isRuntime, nonNull, PairSerializer, StringSerializer, } from \"@collabs/core\";\nimport { CBoolean } from \"../boolean\";\nimport { CSet } from \"../set\";\nimport { CVar } from \"../var\";\nimport { CTotalOrder } from \"./c_total_order\";\nimport { LocalList } from \"./local_list\";\nclass CListEntry extends CObject {\n    constructor(init, valueCallback, initialPosition) {\n        super(init);\n        this.value = super.registerCollab(\"\", valueCallback);\n        this.position = super.registerCollab(\"0\", (init) => new CVar(init, initialPosition));\n        // Restore-wins, with initial value \"present\".\n        this.present = super.registerCollab(\"1\", (init) => new CBoolean(init, { initialValue: true, winner: true }));\n    }\n}\n/**\n * A collaborative list with *mutable*\n * values of type C.\n *\n * Values are internally mutable.\n * Specifically, each value is its own [[Collab]], and\n * operations on that Collab are collaborative as usual.\n *\n * `CList<C>` has a similar API to `Array<C>`,\n * but it is mutated more like a linked list: instead of mutating\n * existing values, you [[insert]] and [[delete]]\n * list entries. Insertions and deletions\n * shift later entries, changing their indices, like\n * in collaborative text editing or\n * [Array.splice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice).\n *\n * To insert values, you use the pattern described in\n * [collections of Collabs](https://collabs.readthedocs.io/en/latest/guide/collections.html):\n * one user calls [[insert]] with `InsertArgs`; each\n * replica passes those `InsertArgs` to its\n * `valueConstructor`;\n * and `valueConstructor` returns the local copy of the new value Collab.\n *\n * When a value is deleted with [[delete]], it is deleted permanently and\n * can no longer be used; future and concurrent operations on that value\n * are ignored. Alternately, use [[archive]] and [[restore]].\n *\n * It is *not* safe to modify a CList while iterating over it. The iterator\n * will attempt to throw an exception if it detects such modification,\n * but this is not guaranteed.\n *\n * See also: [[CValueList]], [[CText]], [[CRichText]].\n *\n * @typeParam C The value type, which is a Collab.\n * @typeParam InsertArgs The type of arguments to [[insert]].\n */\nexport class CList extends AbstractList_CObject {\n    /**\n     * Constructs a CList with the given `valueConstructor`.\n     *\n     * @param valueConstructor Callback used to construct a\n     * value Collab with the given [[InitToken]] and arguments to [[insert]]. See [collections of Collabs](https://collabs.readthedocs.io/en/latest/guide/collections.html)\n     * for example usage.\n     * @param options.argsSerializer A serializer for `InsertArgs` as an array.\n     * Defaults to [[DefaultSerializer]].\n     */\n    constructor(init, valueConstructor, options = {}) {\n        super(init);\n        this.valueConstructor = valueConstructor;\n        const argsSerializer = options.argsSerializer ?? DefaultSerializer.getInstance();\n        // Register totalOrder first so that it is loaded first.\n        // (We could also ensure that by overriding CObject.load.)\n        // Otherwise, set's events during load will reference positions that\n        // haven't been loaded yet.\n        this.totalOrder = this.registerCollab(\"0\", (init) => new CTotalOrder(init));\n        this.set = this.registerCollab(\"\", (init) => new CSet(init, this.entryConstructor.bind(this), {\n            argsSerializer: new PairSerializer(StringSerializer.instance, argsSerializer),\n        }));\n        this.list = new LocalList(this.totalOrder);\n        // Maintain this.list's values as a cache of\n        // of the currently set locations, mapping to\n        // the corresponding entry.\n        // Also dispatch our own events.\n        this.set.on(\"Add\", (event) => {\n            // During load, CSet always emits a new value's Add event before\n            // loading that value. Thus the value starts off not-archived.\n            // If it was archived in the loaded state, we'll get a separate\n            // event from value itself later.\n            const position = event.value.position.value;\n            this.list.set(position, event.value.value);\n            this.emit(\"Insert\", {\n                index: this.list.indexOfPosition(position),\n                values: [event.value.value],\n                positions: [position],\n                method: \"insert\",\n                meta: event.meta,\n            });\n        });\n        this.set.on(\"Delete\", (event) => {\n            const position = event.value.position.value;\n            if (event.value.present.value) {\n                const index = this.list.indexOfPosition(position);\n                this.list.delete(position);\n                this.emit(\"Delete\", {\n                    index,\n                    values: [event.value.value],\n                    positions: [position],\n                    method: \"delete\",\n                    meta: event.meta,\n                });\n            }\n            else {\n                // Archived -> deleted.\n                this.emit(\"DeleteArchived\", {\n                    values: [event.value.value],\n                    positions: [position],\n                    meta: event.meta,\n                });\n            }\n        });\n    }\n    entryConstructor(entryInit, initialPosition, args) {\n        const entry = new CListEntry(entryInit, (valueInit) => this.valueConstructor(valueInit, ...args), initialPosition);\n        // Maintain this.list's values as a cache of\n        // of the currently set locations, mapping to\n        // the corresponding entry.\n        // Also dispatch our own events.\n        // Note that for the initial position, this is done\n        // in set's Add event listener, not here.\n        // Also note that entry is always non-deleted, since\n        // restore() skips deleted values.\n        // OPT: avoid creating closures for each entry here?\n        entry.position.on(\"Set\", (event) => {\n            // Handle move ops.\n            if (event.value === event.previousValue)\n                return;\n            if (entry.present.value) {\n                // Moving a present value.\n                const previousIndex = this.list.indexOfPosition(event.previousValue);\n                this.list.delete(event.previousValue);\n                this.list.set(event.value, entry.value);\n                this.emit(\"Move\", {\n                    index: this.list.indexOfPosition(event.value),\n                    previousIndex,\n                    values: [entry.value],\n                    previousPositions: [event.previousValue],\n                    positions: [event.value],\n                    meta: event.meta,\n                });\n            }\n            else {\n                // Moving an archived value.\n                // This happens when we receive a move operation after a\n                // concurrent archive operation.\n                // Some users may wish to track a view of archived values' positions\n                // (e.g., to show where they would be restored to), so we still emit\n                // an event, just without indices.\n                this.emit(\"MoveArchived\", {\n                    values: [entry.value],\n                    previousPositions: [event.previousValue],\n                    positions: [event.value],\n                    meta: event.meta,\n                });\n            }\n        });\n        entry.present.on(\"Set\", (event) => {\n            // Handle archive/restore ops.\n            if (event.value === event.previousValue)\n                return;\n            const position = entry.position.value;\n            if (event.value) {\n                // entry was un-archived.\n                this.list.set(position, entry.value);\n                this.emit(\"Insert\", {\n                    index: this.list.indexOfPosition(position),\n                    values: [entry.value],\n                    positions: [position],\n                    method: \"restore\",\n                    meta: event.meta,\n                });\n            }\n            else {\n                // entry was archived.\n                const index = this.list.indexOfPosition(position);\n                this.list.delete(position);\n                this.emit(\"Delete\", {\n                    index,\n                    values: [entry.value],\n                    positions: [position],\n                    method: \"archive\",\n                    meta: event.meta,\n                });\n            }\n        });\n        return entry;\n    }\n    entryFromValue(value) {\n        // Avoid errors from searchElement.parent in case it\n        // is the root.\n        if (isRuntime(value.parent))\n            return null;\n        return value.parent;\n    }\n    /**\n     * Inserts a value at the given index using args.\n     *\n     * All values currently at or after `index` shift\n     * to the right, incrementing their indices.\n     *\n     * The args are broadcast to all replicas in serialized form.\n     * Every replica then passes them to `valueConstructor` to construct the actual\n     * value of type C, a new Collab that is collaborative as usual.\n     *\n     * @param index The insertion index in the range\n     * `[0, this.length]`. If `this.length`, the value\n     * is appended to the end of the list.\n     * @return The inserted value, or undefined if it is not\n     * constructed immediately.\n     * @throws If index is not in `[0, this.length]`.\n     */\n    insert(index, ...args) {\n        const position = this.createPositions(index, 1)[0];\n        const newEntry = this.set.add(position, args);\n        return newEntry.value;\n    }\n    createPositions(index, count) {\n        return this.totalOrder.createPositions(index === 0 ? null : this.list.getPosition(index - 1), index === this.length ? null : this.list.getPosition(index), count);\n    }\n    /**\n     * Delete `count` values starting at `index`, i.e., values\n     * `[index, index + count - 1)`.\n     *\n     * All later values shift to the left,\n     * decreasing their indices by `count`.\n     *\n     * The values are deleted permanently and\n     * can no longer be used; future and concurrent operations on those values\n     * are ignored. Local operations will succeed but will not affect\n     * remote replicas. The values can perform cleanup in their\n     * [[Collab.finalize]] methods.\n     *\n     * See also: [[archive]], [[CSet.delete]].\n     */\n    delete(index, count = 1) {\n        if (count < 0 || !Number.isInteger(count)) {\n            throw new Error(`invalid count: ${count}`);\n        }\n        // Get the values to delete.\n        const toDelete = this.list.slice(index, index + count);\n        toDelete.reverse();\n        // Delete them.\n        for (const value of toDelete) {\n            this.set.delete(nonNull(this.entryFromValue(value)));\n        }\n    }\n    /**\n     * Archives `count` values starting at `index`, i.e., values\n     * `[index, index + count - 1)`.\n     *\n     * All later values shift to the left,\n     * decreasing their indices by `count`.\n     *\n     * Unlike [[delete]], archived merely marks values as not present.\n     * Archived values can still perform collaborative operations,\n     * and they can be made present again with [[restore]].\n     *\n     * @param count The number of values to archive.\n     * Defaults to 1 (archive the value at `index` only).\n     *\n     * @throws if `index < 0` or\n     * `index + count >= this.length`.\n     */\n    archive(index, count = 1) {\n        if (count < 0 || !Number.isInteger(count)) {\n            throw new Error(`invalid count: ${count}`);\n        }\n        // Get the values to archive.\n        const toArchive = this.list.slice(index, index + count);\n        toArchive.reverse();\n        // Archive them. Note the entry.position will \"remember\" the current\n        // position (and concurrent moves) for when we are restored.\n        for (const value of toArchive) {\n            const entry = nonNull(this.entryFromValue(value));\n            entry.present.value = false;\n        }\n    }\n    /**\n     * Restores the given value, marking it as present in the list.\n     *\n     * The value re-appears at its previous position, unless\n     * moved by [[move]].\n     * All values after that position shift to the right,\n     * incrementing their indices.\n     *\n     * In case of concurrent restore and [[archive]] operations, the restore\n     * wins. If the value is deleted (not just archived), this\n     * method has no effect.\n     *\n     * One usage pattern is to call restore on a value each time you\n     * mutate that value. That way, if one user archives a value while\n     * it is still in use by another user, the archive will be canceled\n     * (*update-wins* semantics).\n     */\n    restore(value) {\n        const entry = this.entryFromValue(value);\n        if (entry === null || !this.set.has(entry)) {\n            // Already deleted, or invalid.\n            return;\n        }\n        // For \"keepalive\" behavior (restore on every op), here we rely\n        // on the fact that CBoolean performs this set op even if it's redundant\n        // (already present).\n        entry.present.value = true;\n    }\n    /**\n     * Moves `count` values from `index` to `insertionIndex`.\n     *\n     * That is, the range of values at `[index, index + count - 1)` is moved to the position\n     * *currently* at `insertionIndex`.\n     *\n     * Other values shift to accommodate the move.\n     *\n     * Collaborative operations on the values continue to work\n     * normally, even if concurrent to the move.\n     *\n     * @param count The number of values to move.\n     * Defaults to 1 (move the value at `index` only).\n     * @returns The new index of the first moved value.\n     * This will be less then `insertionIndex` if `index < insertionIndex`.\n     * @throws if `index < 0` or\n     * `index + count >= this.length`.\n     */\n    move(index, insertionIndex, count = 1) {\n        if (count < 0 || !Number.isInteger(count)) {\n            throw new Error(`invalid count: ${count}`);\n        }\n        if (count === 0)\n            return insertionIndex;\n        // Positions to insert at.\n        const positions = this.createPositions(insertionIndex, count);\n        // Values to move.\n        const toMove = this.list.slice(index, index + count);\n        // Move them.\n        for (let i = 0; i < count; i++) {\n            const entry = nonNull(this.entryFromValue(toMove[i]));\n            entry.position.value = positions[i];\n        }\n        // Return the new index of toMove[0].\n        return this.list.indexOfPosition(positions[0]);\n    }\n    get(index) {\n        return this.list.get(index);\n    }\n    values() {\n        return this.list.values();\n    }\n    get length() {\n        return this.list.length;\n    }\n    /**\n     * Inserts a value at the end of the list using args.  Equivalent to\n     * `this.insert(this.length, ...args)`.\n     *\n     * @return The inserted value.\n     */\n    push(...args) {\n        return this.insert(this.length, ...args);\n    }\n    /**\n     * Inserts a value at the start of the list using args.  Equivalent to\n     * `this.insert(0, ...args)`.\n     *\n     * @return The inserted value.\n     */\n    unshift(...args) {\n        return this.insert(0, ...args);\n    }\n    slice(start, end) {\n        return this.list.slice(start, end);\n    }\n    getPosition(index) {\n        return this.list.getPosition(index);\n    }\n    indexOfPosition(position, searchDir = \"none\") {\n        return this.list.indexOfPosition(position, searchDir);\n    }\n    /**\n     * Returns whether position is currently present in the list,\n     * i.e., its value is present (neither deleted nor archived).\n     */\n    hasPosition(position) {\n        return this.list.hasPosition(position);\n    }\n    getByPosition(position) {\n        return this.list.getByPosition(position);\n    }\n    /**\n     * Returns an iterator of [index, value, position] tuples for every\n     * value in the list, in list order.\n     *\n     * Note: If you [[move]] list elements, you should not use `position`\n     * as a React key, since a value's position changes when it moves.\n     * Instead, [use the object itself as the key](https://stackoverflow.com/questions/31394774/reactjs-using-object-ref-as-key).\n     */\n    entries() {\n        return this.list.entries();\n    }\n    indexOf(searchElement, fromIndex = 0) {\n        // Override AbstractList's implementation to use entryFromValue (O(1) time)\n        // instead of a linear search.\n        const entry = this.entryFromValue(searchElement);\n        if (entry !== null && this.set.has(entry) && entry.present.value) {\n            const index = this.list.indexOfPosition(entry.position.value);\n            if (fromIndex < 0)\n                fromIndex += this.length;\n            if (index >= fromIndex)\n                return index;\n        }\n        return -1;\n    }\n    /**\n     * Returns value's position, or undefined if it is deleted or\n     * never an element of this list.\n     *\n     * For an archived (but not deleted) value, returns the position\n     * that it would have when restored. You can use\n     * `list.indexOfPosition(list.positionOf(value), \"right\")` to find\n     * the index that it would have when restored.\n     */\n    positionOf(value) {\n        const entry = this.entryFromValue(value);\n        if (entry !== null && this.set.has(entry) && entry.present.value) {\n            return entry.position.value;\n        }\n        return undefined;\n    }\n}\n//# sourceMappingURL=c_list.js.map","import { int64AsNumber, nonNull, protobufHas, } from \"@collabs/core\";\nimport { SpanLogPartialSpanMessage, SpanLogSaveMessage, } from \"../../generated/proto_compiled\";\nimport { PrimitiveCRDT } from \"../base_collabs\";\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nclass PartialSpanSerializer {\n    constructor(formatSerializer) {\n        this.formatSerializer = formatSerializer;\n    }\n    serialize(span) {\n        const message = SpanLogPartialSpanMessage.create({\n            ...span,\n            value: span.value === undefined\n                ? undefined\n                : this.formatSerializer.serialize(span.value),\n        });\n        return SpanLogPartialSpanMessage.encode(message).finish();\n    }\n    deserialize(message) {\n        const decoded = SpanLogPartialSpanMessage.decode(message);\n        return {\n            key: decoded.key,\n            value: protobufHas(decoded, \"value\")\n                ? this.formatSerializer.deserialize(decoded.value)\n                : undefined,\n            startPosition: decoded.startPosition,\n            endPosition: protobufHas(decoded, \"endPosition\")\n                ? decoded.endPosition\n                : null,\n            ...(decoded.endClosed ? { endClosed: true } : {}),\n        };\n    }\n}\n/**\n * Append-only log of formatting spans, used by CRichText.\n *\n * This is an internal class and is not exported.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class CSpanLog extends PrimitiveCRDT {\n    constructor(init, formatSerializer) {\n        super(init);\n        /**\n         * An append-only log of Spans. For easy searching, it\n         * is stored as a Map from senderID to that sender's Spans\n         * in send order.\n         */\n        this.log = new Map();\n        this.partialSpanSerializer = new PartialSpanSerializer(formatSerializer);\n    }\n    add(key, value, startPos, endPos, endClosed) {\n        super.sendCRDT(this.partialSpanSerializer.serialize({\n            key,\n            value,\n            startPosition: startPos,\n            endPosition: endPos,\n            endClosed: endClosed ? true : undefined,\n        }));\n    }\n    receiveCRDT(message, meta, crdtMeta) {\n        const decoded = this.partialSpanSerializer.deserialize(message);\n        const span = {\n            ...decoded,\n            lamport: nonNull(crdtMeta.lamportTimestamp),\n            senderID: crdtMeta.senderID,\n        };\n        let bySender = this.log.get(crdtMeta.senderID);\n        if (bySender === undefined) {\n            bySender = [];\n            this.log.set(crdtMeta.senderID, bySender);\n        }\n        bySender.push(span);\n        this.emit(\"Add\", { span, meta });\n    }\n    saveCRDT() {\n        const senderIDs = new Array(this.log.size);\n        const lengths = new Array(this.log.size);\n        const spans = [];\n        const lamports = [];\n        let i = 0;\n        for (const [senderID, senderSpans] of this.log) {\n            senderIDs[i] = senderID;\n            lengths[i] = senderSpans.length;\n            for (const span of senderSpans) {\n                spans.push(this.partialSpanSerializer.serialize(span));\n                lamports.push(span.lamport);\n            }\n            i++;\n        }\n        const message = SpanLogSaveMessage.create({\n            senderIDs,\n            lengths,\n            spans,\n            lamports,\n        });\n        return SpanLogSaveMessage.encode(message).finish();\n    }\n    loadCRDT(savedState, meta) {\n        if (savedState === null)\n            return;\n        const decoded = SpanLogSaveMessage.decode(savedState);\n        let spanIndex = 0;\n        for (let i = 0; i < decoded.senderIDs.length; i++) {\n            const senderID = decoded.senderIDs[i];\n            // Only add the spans we don't have already:\n            // those with larger Lamport timestamp than our most\n            // recent Span from senderID.\n            let lastLamport;\n            let bySender = this.log.get(senderID);\n            if (bySender === undefined) {\n                bySender = [];\n                this.log.set(senderID, bySender);\n                lastLamport = -1;\n            }\n            else {\n                lastLamport = bySender[bySender.length - 1].lamport;\n            }\n            for (let j = 0; j < decoded.lengths[i]; j++) {\n                const lamport = int64AsNumber(decoded.lamports[spanIndex]);\n                if (lamport > lastLamport) {\n                    const span = {\n                        ...this.partialSpanSerializer.deserialize(decoded.spans[spanIndex]),\n                        lamport,\n                        senderID,\n                    };\n                    bySender.push(span);\n                    this.emit(\"Add\", { span, meta });\n                }\n                spanIndex++;\n            }\n        }\n    }\n}\n//# sourceMappingURL=c_span_log.js.map","import { AbstractList_CObject, ArraySerializer, CMessenger, DefaultSerializer, Uint8ArraySerializer, nonNull, } from \"@collabs/core\";\nimport { ValueListMessage, } from \"../../generated/proto_compiled\";\nimport { CTotalOrder } from \"./c_total_order\";\nimport { LocalList } from \"./local_list\";\n/**\n * A collaborative list with values of type T.\n *\n * `CValueList<T>` has a similar API to `Array<T>`,\n * but it is mutated more like a linked list: instead of mutating\n * existing values, you [[insert]] and [[delete]]\n * list entries. Insertions and deletions\n * shift later entries, changing their indices, like\n * in collaborative text editing or\n * [Array.splice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice).\n *\n * Values must be internally immutable;\n * mutating a value internally will not change it on\n * other replicas. If you need to mutate values internally,\n * instead use a [[CList]].\n *\n * It is *not* safe to modify a CValueList while iterating over it. The iterator\n * will attempt to throw an exception if it detects such modification,\n * but this is not guaranteed.\n *\n * See also: [[CList]], [[CText]], [[CRichText]].\n *\n * @typeParam T The value type.\n */\nexport class CValueList extends AbstractList_CObject {\n    /**\n     * Constructs a CValueList.\n     *\n     * @param options.valueSerializer Serializer for values. Defaults to [[DefaultSerializer]].\n     * @param options.valueArraySerializer Serializer\n     * for an array of values, used for bulk operations and saved states.\n     * Defaults to using `valueSerializer` on each value.\n     */\n    constructor(init, options = {}) {\n        super(init);\n        this.valueSerializer =\n            options.valueSerializer ?? DefaultSerializer.getInstance();\n        this.valueArraySerializer =\n            options.valueArraySerializer !== undefined\n                ? options.valueArraySerializer\n                : ArraySerializer.getInstance(this.valueSerializer);\n        this.totalOrder = super.registerCollab(\"0\", (init) => new CTotalOrder(init));\n        this.list = new LocalList(this.totalOrder);\n        this.messenger = super.registerCollab(\"\", (init) => new CMessenger(init, {\n            messageSerializer: Uint8ArraySerializer.instance,\n        }));\n        // Message handler.\n        this.messenger.on(\"Message\", (e) => this.altReceivePrimitive(e.message, e.meta));\n    }\n    /**\n     * Analogous to CPrimitive.receivePrimitive, but actually for processing\n     * this.messenger's messages.\n     */\n    altReceivePrimitive(message, meta) {\n        const decoded = ValueListMessage.decode(message);\n        switch (decoded.op) {\n            case \"insert\": {\n                const insert = nonNull(decoded.insert);\n                const values = insert.data === \"value\"\n                    ? [this.valueSerializer.deserialize(insert.value)]\n                    : this.valueArraySerializer.deserialize(insert.valueArray);\n                const waypoint = this.totalOrder.getWaypoint(meta.senderID, insert.counter);\n                const positions = this.totalOrder.encodeAll(waypoint, \n                // OPT: In principle, we could infer the valueIndex from list.getSeen\n                // instead of sending it over the network. However, that would not\n                // work if someone else created positions in our total order\n                // that happened to extend one of our waypoints.\n                insert.valueIndex, values.length);\n                this.list.setCreated(positions[0], values);\n                // Here we exploit forward non-interleaving, which guarantees\n                // that the values are contiguous.\n                this.emit(\"Insert\", {\n                    index: this.list.indexOfPosition(positions[0]),\n                    values,\n                    positions,\n                    meta,\n                });\n                break;\n            }\n            case \"delete\": {\n                const position = decoded.delete;\n                // OPT: combine calls?\n                if (this.list.hasPosition(position)) {\n                    // Use ! instead of nonNull because T might allow null.\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    const value = this.list.getByPosition(position);\n                    const index = this.list.indexOfPosition(position);\n                    this.list.delete(position);\n                    this.emit(\"Delete\", {\n                        index,\n                        values: [value],\n                        positions: [position],\n                        meta,\n                    });\n                }\n                break;\n            }\n            default:\n                throw new Error(`Unknown decoded.op: ${decoded.op}`);\n        }\n    }\n    insert(index, ...values) {\n        if (index < 0 || index > this.length) {\n            throw new Error(`Index out of bounds: ${index} (length: ${this.length})`);\n        }\n        if (values.length === 0)\n            return undefined;\n        const firstNewPos = this.totalOrder.createPositions(\n        // OPT: Optimize LocalList for these sequential calls.\n        index === 0 ? null : this.list.getPosition(index - 1), index === this.length ? null : this.list.getPosition(index), values.length)[0];\n        const [waypoint, valueIndex] = this.totalOrder.decode(firstNewPos);\n        const insertMessage = {\n            counter: waypoint.counter,\n            valueIndex: valueIndex === 0 ? undefined : valueIndex,\n        };\n        if (values.length === 1) {\n            insertMessage.value = this.valueSerializer.serialize(values[0]);\n        }\n        else {\n            insertMessage.valueArray = this.valueArraySerializer.serialize(values);\n        }\n        this.messenger.sendMessage(ValueListMessage.encode({ insert: insertMessage }).finish());\n        return values[0];\n    }\n    delete(index, count = 1) {\n        if (index < 0) {\n            throw new Error(`index out of bounds: ${index}`);\n        }\n        if (index + count > this.length) {\n            throw new Error(`(index + count) out of bounds: ${index} + ${count} (length: ${this.length})`);\n        }\n        // OPT: native range deletes? E.g. compress waypoint valueIndex ranges.\n        // OPT: optimize range iteration (ListView.slice for positions?)\n        // Delete from back to front, so indices make sense.\n        for (let i = index + count - 1; i >= index; i--) {\n            this.messenger.sendMessage(ValueListMessage.encode({ delete: this.list.getPosition(i) }).finish());\n        }\n    }\n    get(index) {\n        return this.list.get(index);\n    }\n    values() {\n        return this.list.values();\n    }\n    get length() {\n        return this.list.length;\n    }\n    push(...values) {\n        return this.insert(this.length, ...values);\n    }\n    unshift(...values) {\n        return this.insert(0, ...values);\n    }\n    /**\n     * Deletes and inserts values like [Array.splice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice).\n     *\n     * If `deleteCount` is provided, this method first deletes\n     * `deleteCount` values starting at `start`.\n     * Next, this method inserts `values` at `start`.\n     *\n     * All values currently at or after `start + deleteCount`\n     * shift to accommodate the change in length.\n     *\n     * @returns The deleted values.\n     */\n    splice(start, deleteCount, ...values) {\n        // Sanitize start.\n        if (start < 0)\n            start += this.length;\n        if (start < 0)\n            start = 0;\n        if (start > this.length)\n            start = this.length;\n        // Sanitize deleteCount.\n        if (deleteCount === undefined || deleteCount > this.length - start)\n            deleteCount = this.length - start;\n        else if (deleteCount < 0)\n            deleteCount = 0;\n        // Delete then insert.\n        const ret = this.slice(start, start + deleteCount);\n        this.delete(start, deleteCount);\n        if (values.length > 0) {\n            this.insert(start, ...values);\n        }\n        return ret;\n    }\n    slice(start, end) {\n        return this.list.slice(start, end);\n    }\n    getPosition(index) {\n        return this.list.getPosition(index);\n    }\n    indexOfPosition(position, searchDir = \"none\") {\n        return this.list.indexOfPosition(position, searchDir);\n    }\n    hasPosition(position) {\n        return this.list.hasPosition(position);\n    }\n    getByPosition(position) {\n        return this.list.getByPosition(position);\n    }\n    positions() {\n        return this.list.positions();\n    }\n    entries() {\n        return this.list.entries();\n    }\n    save() {\n        // Override CObject.save to add our own state in SavedStateTree.self.\n        const ans = super.save();\n        ans.self = this.list.save(this.valueArraySerializer);\n        return ans;\n    }\n    load(savedStateTree, meta) {\n        super.load(savedStateTree, meta);\n        if (savedStateTree === null)\n            return;\n        const savedState = nonNull(savedStateTree.self);\n        if (this.list.inInitialState) {\n            // Shortcut: No need to merge, just load the state directly.\n            this.list.load(savedState, this.valueArraySerializer);\n            if (this.list.length > 0) {\n                // It's important that we don't do this when the length is zero:\n                // 0-length Insert events confuse CRichText and possibly others.\n                const values = new Array(this.list.length);\n                const positions = new Array(this.list.length);\n                for (const [i, value, position] of this.list.entries()) {\n                    values[i] = value;\n                    positions[i] = position;\n                }\n                this.emit(\"Insert\", { index: 0, values, positions, meta });\n            }\n        }\n        else {\n            // We need to merge savedState with our existing state.\n            const remote = new LocalList(this.totalOrder);\n            remote.load(savedState, this.valueArraySerializer);\n            // 1. Delete values whose positions were seen by the remote list but are not\n            // present in it.\n            // Those must have been deleted by (a replica of) us (= this CValueList).\n            // OPT: do changes by-waypoint instead, for shorter loops, optimized set/delete,\n            // and fewer events.\n            const deleteEvents = [];\n            for (const [index, value, position] of this.list.entries()) {\n                const [waypoint, valueIndex] = this.totalOrder.decode(position);\n                const remoteSeen = remote.getSeen(waypoint);\n                if (valueIndex < remoteSeen && !remote.hasPosition(position)) {\n                    // Wait to make changes until the end, to avoid modifications during iterators.\n                    deleteEvents.push({\n                        index,\n                        positions: [position],\n                        values: [value],\n                        meta,\n                    });\n                }\n            }\n            // Do deletions in reverse order so the original indices are accurate.\n            deleteEvents.reverse();\n            for (const e of deleteEvents) {\n                this.list.delete(e.positions[0]);\n                this.emit(\"Delete\", e);\n            }\n            // 2. Add values from remote whose positions were not seen by the local\n            // CTotalOrder.\n            const insertEvents = [];\n            let insertedSoFar = 0;\n            for (const [, value, position] of remote.entries()) {\n                // OPT: use waypoints to do bulk inserts. Need to be careful about: missing\n                // (remotely-deleted) elements; indices that skip over child waypoints.\n                // Also, double-check that CRichText's Insert event handler still works\n                // (it assumes no existing positions in the middle of an Insert event's values).\n                const [waypoint, valueIndex] = this.totalOrder.decode(position);\n                const localSeen = this.list.getSeen(waypoint);\n                if (valueIndex >= localSeen) {\n                    insertEvents.push({\n                        index: this.list.indexOfPosition(position, \"right\") + insertedSoFar,\n                        positions: [position],\n                        values: [value],\n                        meta,\n                    });\n                    insertedSoFar++;\n                }\n            }\n            // Do insertions in order, so that get(index) works even if\n            // you wait to handle all events until loading finishes.\n            for (const e of insertEvents) {\n                this.list.set(e.positions[0], e.values[0]);\n                this.emit(\"Insert\", e);\n            }\n        }\n    }\n}\n//# sourceMappingURL=c_value_list.js.map","import { StringSerializer } from \"@collabs/core\";\n/** Not exported publicly, just for CText and CRichText. */\nexport const charArraySerializer = {\n    serialize(value) {\n        return StringSerializer.instance.serialize(value.join(\"\"));\n    },\n    deserialize(message) {\n        return [...StringSerializer.instance.deserialize(message)];\n    },\n};\n//# sourceMappingURL=char_array_serializer.js.map","import { CObject, DefaultSerializer, StringSerializer, nonNull, } from \"@collabs/core\";\nimport { CSpanLog } from \"./c_span_log\";\nimport { CValueList } from \"./c_value_list\";\nimport { charArraySerializer } from \"./char_array_serializer\";\nimport { LocalList } from \"./local_list\";\n// TODO: algorithm description.\n// Behavior differences from Peritext:\n// - Does not infer *local* behavior using Peritext's rules (including\n// edge cases around paragraph starts and tombstones). Instead, you must specify\n// provide the desired format for each inserted char, then CRichText creates\n// new spans if needed to match (i.e., if the existing spans give the\n// wrong format). This is okay because you're usually using a rich-text editor\n// that infers the local behavior for you.\n// - Unformatting the second half of a noGrowAtEnd span: Peritext gives the unformat\n// span an open start, so that the remaining first half of the noGrowAtEnd span is\n// still closed at the end (won't grow). We don't yet implement this (TODO).\n// - We only support key-value type formats where the latest value overwrites\n// all previous values, not \"unique\" formats like comments. Instead, you should store\n// comments yourself together with their start & and end [[Position]]s.\n/**\n * A collaborative rich-text string, i.e., a text string with inline formatting.\n *\n * Each character has an associated *format* of type `Record<string, any>`, which\n * maps from format keys to format values. Use [[format]] to format a range, and use\n * [[formatted]] to access an efficient representation of the formatted text.\n * Otherwise, the API is similar to [[CText]].\n *\n * You can restrict the allowed format keys\n * and their value types by using an interface for the generic type `F`, e.g.,\n * ```ts\n * interface MyFormat {\n *   bold: true;\n *   link: string;\n * }\n * const text = new CRichText<MyFormat>(...);\n * ```\n * Note that undefined is always allowed as a format value, indicating that a\n * key is not present. Thus we use type `Partial<F>`\n * to describe a character's format.\n *\n * Internally, formats are controlled\n * by *formatting spans*, which set (or delete) a format key-value pair in a given\n * range of text. A span affects all characters in its range, including\n * concurrent or future characters, until overridden\n * by another span.\n *\n * For a detailed discussion of formatting spans' behavior, see [Peritext](https://www.inkandswitch.com/peritext/),\n * which this Collab approximately implements. Note that you can tune spans'\n * behavior using the `noGrowAtEnd` constructor option.\n *\n * It is *not* safe to modify a CRichText while iterating over it. The iterator\n * will attempt to throw an exception if it detects such modification,\n * but this is not guaranteed.\n *\n * See also:\n * - [[CText]]: for plain text.\n * - [[CValueList]], [[CList]]: for general lists.\n *\n * @typeParam F The allowed format keys and value types, represented as an\n * interface (or Record type) mapping string keys to their value types.\n * Default: `Record<string, any>`.\n */\nexport class CRichText extends CObject {\n    /**\n     * Constructs a CRichText.\n     *\n     * @param options.noGrowAtEnd A collection of format keys whose spans will *not* grow\n     * at the end: they will *not* affect concurrent and future characters inserted\n     * at the end of their original range (but will still affect the middle).\n     *\n     * By default, this is empty. You may wish to include formats like hyperlinks,\n     * as described in\n     * [Peritext's Example 9](https://www.inkandswitch.com/peritext/#example-9).\n     * @param options.formatSerializer Serializer for format values. Defaults to [[DefaultSerializer]].\n     */\n    constructor(init, options) {\n        super(init);\n        this.noGrowAtEnd = new Set(options?.noGrowAtEnd ?? []);\n        this.text = super.registerCollab(\"\", (init) => new CValueList(init, {\n            valueSerializer: StringSerializer.instance,\n            valueArraySerializer: charArraySerializer,\n        }));\n        this.spanLog = super.registerCollab(\"0\", (init) => new CSpanLog(init, options?.formatSerializer ?? DefaultSerializer.getInstance()));\n        this.formatList = new LocalList(this.text.totalOrder);\n        // Events.\n        // this.addSpan also updates this.formatList.\n        this.spanLog.on(\"Add\", (e) => this.addSpan(e.span, e.meta));\n        this.text.on(\"Insert\", (e) => this.emit(\"Insert\", {\n            index: e.index,\n            values: e.values.join(\"\"),\n            positions: e.positions,\n            // By non-interleaving and the fact that the positions are new,\n            // all inserted chars have the same initial format.\n            // This is true even for merged saved states because:\n            // 1. We load text before spanLog, so any merged formats referencing\n            // new positions have not yet been loaded.\n            // 2. CValueList only emits bulk (multi-char) insert events when the\n            // local state is empty (initial load, not merge), so there can't\n            // be any old tombstones in the middle of values.\n            format: this.getFormatInternal(e.positions[0]),\n            meta: e.meta,\n        }));\n        this.text.on(\"Delete\", (e) => this.emit(\"Delete\", {\n            index: e.index,\n            values: e.values.join(\"\"),\n            positions: e.positions,\n            meta: e.meta,\n        }));\n    }\n    /**\n     * this.spanLog \"Add\" event handler.\n     */\n    addSpan(span, meta) {\n        // 1. Update our view of the formatting spans in this.formatList.\n        this.createData(span.startPosition);\n        if (span.endPosition !== null)\n            this.createData(span.endPosition);\n        // Merge span into all FormatData.normalSpan in the range\n        // [startPos, endPos). While doing so, build slices for the events\n        // later.\n        const start = this.formatList.indexOfPosition(span.startPosition);\n        const end = span.endPosition === null\n            ? this.formatList.length\n            : this.formatList.indexOfPosition(span.endPosition);\n        const sliceBuilder = new SliceBuilder(this, formatChangeEquals);\n        for (let i = start; i < end; i++) {\n            const position = this.formatList.getPosition(i);\n            const data = nonNull(this.formatList.getByPosition(position));\n            if (this.wins(span, data.normalSpans.get(span.key))) {\n                const previousValueOpen = getDataValue(data, false, span.key);\n                const previousValueClosed = getDataValue(data, true, span.key);\n                data.normalSpans.set(span.key, span);\n                if (this.wins(span, data.endClosedSpans.get(span.key))) {\n                    // Overwrite the endClosedSpan (if it exists), to maintain the\n                    // invariant: an endClosedSpan is only present if it wins over the\n                    // normalSpan.\n                    data.endClosedSpans.delete(span.key);\n                    // Possible change in the interval [position].\n                    // (If it didn't actually delete anything, then previousValueClosed\n                    // === span.value, so we'll filter it when emitting events.)\n                    sliceBuilder.add({\n                        previousValue: previousValueClosed,\n                        format: getDataRecord(data, true),\n                    }, position, true);\n                }\n                else {\n                    // No change in the interval [position].\n                    sliceBuilder.add(null, position, true);\n                }\n                // Yes change in the interval starting (position,...\n                sliceBuilder.add({\n                    previousValue: previousValueOpen,\n                    format: getDataRecord(data, false),\n                }, position, false);\n            }\n            else {\n                // No change in the interval starting [position,...\n                sliceBuilder.add(null, position, true);\n            }\n        }\n        let slices;\n        if (span.endPosition !== null) {\n            if (span.endClosed === true) {\n                // Merge span into endPos's endClosedSpans.\n                // We only store span if it wins over both the existing endClosedSpan\n                // and the existing normalSpan, as described in FormatData.endClosedSpan's\n                // docs.\n                // Non-null assertion okay because we created the FormatData above.\n                const data = nonNull(this.formatList.getByPosition(span.endPosition));\n                if (this.wins(span, data.endClosedSpans.get(span.key)) &&\n                    this.wins(span, data.normalSpans.get(span.key))) {\n                    const previousValue = getDataValue(data, true, span.key);\n                    data.endClosedSpans.set(span.key, span);\n                    // Possible change in the interval [span.endPosition].\n                    sliceBuilder.add({\n                        previousValue,\n                        format: getDataRecord(data, true),\n                    }, span.endPosition, true);\n                    // In all cases, call finish with the first position (open/closed)\n                    // that span *doesn't* contain (including span.endPosition in the 2nd\n                    // case because it doesn't change anyway).\n                    slices = sliceBuilder.finish(span.endPosition, false);\n                }\n                else\n                    slices = sliceBuilder.finish(span.endPosition, true);\n            }\n            else\n                slices = sliceBuilder.finish(span.endPosition, true);\n        }\n        else\n            slices = sliceBuilder.finish(null, false);\n        // 2. Emit Format events for spans that actually changed.\n        for (const slice of slices) {\n            if (slice.data !== null && slice.data.previousValue !== span.value) {\n                this.emit(\"Format\", {\n                    startIndex: slice.startIndex,\n                    endIndex: slice.endIndex,\n                    key: span.key,\n                    value: span.value,\n                    previousValue: slice.data.previousValue,\n                    format: slice.data.format,\n                    meta,\n                });\n            }\n        }\n        // OPT: build formatList in loadObject instead of using span events, perhaps\n        // based on our own save of the formatList,\n        // then emit one big Quill delta at the end.\n        // For efficiency (esp on initial load), and to\n        // make fewer events.\n    }\n    /**\n     * Creates FormatData at position if it doesn't already exist,\n     * inferring the correct values from the previous FormatData.\n     */\n    createData(position) {\n        if (this.formatList.hasPosition(position))\n            return;\n        // OPT: LocalList prevPosition func or similar, so we can avoid getting\n        // prevIndex entirely.\n        const prevIndex = this.formatList.indexOfPosition(position, \"left\");\n        if (prevIndex === -1) {\n            // No previous FormatData; make an empty one.\n            this.formatList.set(position, {\n                normalSpans: new Map(),\n                endClosedSpans: new Map(),\n            });\n        }\n        else {\n            const prevSpan = this.formatList.get(prevIndex);\n            // Clone normalSpans from prevSpan, since they are the same.\n            // We don't clone endClosedSpans because the positions differ.\n            this.formatList.set(position, {\n                normalSpans: new Map(prevSpan.normalSpans),\n                endClosedSpans: new Map(),\n            });\n        }\n    }\n    /**\n     * Returns whether newSpans wins over oldSpan, either in the Lamport\n     * order (with senderID tiebreaker) or because\n     * oldSpan is undefined.\n     *\n     * If newSpan and oldSpan come from the same transaction, this also\n     * returns true. That is okay because we always call wins() in transaction order,\n     * and later spans in the same transaction win over\n     * earlier spans.\n     */\n    wins(newSpan, oldSpan) {\n        if (oldSpan === undefined)\n            return true;\n        if (newSpan.lamport > oldSpan.lamport)\n            return true;\n        if (newSpan.lamport === oldSpan.lamport) {\n            // In === case, the two spans come from the same transaction,\n            // but newSpan is newer (a later message in the same transaction).\n            if (newSpan.senderID >= oldSpan.senderID)\n                return true;\n        }\n        return false;\n    }\n    /**\n     * Inserts values as a substring at the given index, with the given initial format.\n     *\n     * All values currently at or after `index` shift\n     * to the right, increasing their indices by `values.length`.\n     *\n     * Initially, the characters inherit some format from existing formatting spans.\n     * If this does not match `format`, we create new formatting spans\n     * for the differing format keys.\n     *\n     * @param index The insertion index in the range\n     * `[0, this.length]`. If `this.length`, the values\n     * are appended to the end of the list.\n     * @param values The characters to insert. They are inserted\n     * as individual UTF-16 codepoints.\n     * @param format The characters' initial format.\n     * @throws If index is not in `[0, this.length]`.\n     */\n    insert(index, values, format) {\n        if (values.length === 0)\n            return;\n        this.text.insert(index, ...values);\n        // Change formatting to match format.\n        // No existing positions can be interleaved with the chars' positions,\n        // so the chars all have the same existing formatting.\n        const startPos = this.text.getPosition(index);\n        const existing = this.getFormatInternal(startPos);\n        const endPosClosed = this.text.getPosition(index + values.length - 1);\n        const endPosOpen = index + values.length === this.text.length\n            ? null\n            : this.text.getPosition(index + values.length);\n        for (const [key, value] of Object.entries(format)) {\n            if (value !== undefined && existing[key] !== value) {\n                const endClosed = this.noGrowAtEnd.has(key);\n                this.spanLog.add(key, value, startPos, endClosed ? endPosClosed : endPosOpen, endClosed);\n            }\n        }\n        for (const key of Object.keys(existing)) {\n            if (format[key] === undefined) {\n                // In the Peritext essay, deleting a noGrowAtEnd key creates\n                // a fully open span (start - 1, end + 1).\n                // (3rd paragraph of https://www.inkandswitch.com/peritext/#inserting-text-at-span-boundaries)\n                // We don't yet make the start open; to make the end open, we don't\n                // treat noGrowAtEnd spans specially - all spans have endClosed = false.\n                this.spanLog.add(key, undefined, startPos, endPosOpen, false);\n            }\n        }\n    }\n    /**\n     * Formats the range of text `[startIndex, endIndex)`\n     * (i.e., `text.slice(startIndex, endIndex)`), setting the\n     * given format key to `value`.\n     *\n     * Internally, this creates a new formatting span, even if it is\n     * redundant. The span's grow-at-end behavior is determined by\n     * the `noGrowAtEnd` constructor option.\n     *\n     * @param value If undefined, the format key is deleted, clearing its\n     * current value.\n     */\n    format(startIndex, endIndex, key, value) {\n        if (startIndex < 0 || startIndex >= this.length) {\n            throw new Error(`startIndex out of bounds: ${startIndex} (length: ${this.length})`);\n        }\n        if (endIndex < 0 || endIndex > this.length) {\n            throw new Error(`endIndex out of bound: ${endIndex} (length: ${this.length})`);\n        }\n        if (endIndex < startIndex) {\n            throw new Error(`endIndex ${endIndex} is less than startIndex ${startIndex}`);\n        }\n        if (endIndex === startIndex) {\n            // Trivial span.\n            return;\n        }\n        const endClosed = value !== undefined && this.noGrowAtEnd.has(key);\n        // From trivial span case, we're guaranteed endIndex >= 1, so this is\n        // in [0, this.length].\n        const actualEndIndex = endClosed ? endIndex - 1 : endIndex;\n        const endPos = actualEndIndex === this.length ? null : this.getPosition(actualEndIndex);\n        this.spanLog.add(key, value, this.getPosition(startIndex), endPos, endClosed);\n    }\n    /**\n     * Delete `count` characters starting at `index`, i.e., characters\n     * `[index, index + count - 1)`.\n     *\n     * All later characters shift to the left,\n     * decreasing their indices by `count`.\n     *\n     * @param count The number of characters to delete.\n     * Defaults to 1 (delete the character at `index` only).\n     *\n     * @throws if `index < 0` or\n     * `index + count >= this.length`.\n     */\n    delete(index, count) {\n        this.text.delete(index, count);\n    }\n    /**\n     * Deletes every character in the text string.\n     */\n    clear() {\n        this.text.clear();\n    }\n    /**\n     * Returns a string consisting of the single character\n     * (UTF-16 codepoint) at `index`.\n     *\n     * @throws If index is not in `[0, this.length)`.\n     * Note that this differs from an ordinary string,\n     * which would instead return an empty string.\n     */\n    charAt(index) {\n        return this.text.get(index);\n    }\n    /**\n     * Returns the format for the character at `index`.\n     *\n     * @throws If index is not in `[0, this.length)`.\n     */\n    getFormat(index) {\n        return this.getFormatInternal(this.text.getPosition(index));\n    }\n    /**\n     * Returns the format at position.\n     *\n     * If position is not currently present, returns the formatting that\n     * a character at position would have if present..\n     */\n    getFormatInternal(position) {\n        // Find the closest <= FormatData.\n        // OPT: direct method for this in LocalList, to avoid getting index.\n        const dataIndex = this.formatList.indexOfPosition(position, \"left\");\n        if (dataIndex === -1) {\n            // No format.\n            return {};\n        }\n        const dataPos = this.formatList.getPosition(dataIndex);\n        const data = nonNull(this.formatList.getByPosition(dataPos));\n        return getDataRecord(data, dataPos === position);\n    }\n    /**\n     * Returns an iterator for characters (values) in the text string, in order.\n     *\n     * See also: [[toString]], which returns the entire (plain) text as a string.\n     */\n    values() {\n        return this.text.values();\n    }\n    /**\n     * Returns an iterator of [index, value, format, position] tuples\n     * for every character (value) in the text string, in order.\n     *\n     * Typically, you should instead use [[formatted]], which returns\n     * a more efficient representation of the formatted text.\n     */\n    *entries() {\n        const positionsIter = this.text.positions();\n        for (const { index, values, format } of this.formatted()) {\n            for (let i = 0; i < values.length; i++) {\n                yield [index + i, values[i], format, positionsIter.next().value];\n            }\n        }\n    }\n    // We omit Positions for efficiency. If you want them, use entries().\n    /**\n     * Iterates over an efficient representation of the formatted text.\n     *\n     * Specifically, this method iterates over the formatted ranges in text order\n     * (as returned by [[formatted]]).\n     */\n    [Symbol.iterator]() {\n        return this.formatted()[Symbol.iterator]();\n    }\n    /**\n     * Returns an efficient representation of the formatted text.\n     *\n     * Specifically, returns an array of formatted ranges in text order.\n     */\n    formatted() {\n        const sliceBuilder = new SliceBuilder(this, recordEquals);\n        // Starting chars have no format.\n        sliceBuilder.add({}, null, false);\n        for (const [, data, position] of this.formatList.entries()) {\n            // Format exactly at position, including closedEnds.\n            if (this.text.hasPosition(position)) {\n                sliceBuilder.add(getDataRecord(data, true), position, true);\n            } // Else it is safe to skip.\n            // Format for the rest of the span (the open part).\n            sliceBuilder.add(getDataRecord(data, false), position, false);\n            // OPT: stop early if we reach the end of the present list.\n            // E.g. it was cleared and restarted, so there is a lot of junk at the end.\n        }\n        const slices = sliceBuilder.finish(null, false);\n        // Map the slices to the expected format.\n        return slices.map((slice) => ({\n            index: slice.startIndex,\n            values: this.text.slice(slice.startIndex, slice.endIndex).join(\"\"),\n            format: slice.data,\n        }));\n    }\n    /**\n     * The length of the text string.\n     */\n    get length() {\n        return this.text.length;\n    }\n    /**\n     * Returns the plain text as an ordinary string.\n     */\n    toString() {\n        return this.text.slice().join(\"\");\n    }\n    // Convenience mutators.\n    /**\n     * Inserts values as a substring at the end of the text, with the given format.\n     * Equivalent to `this.insert(this.length, values, format)`.\n     */\n    push(values, format) {\n        this.insert(this.length, values, format);\n    }\n    /**\n     * Inserts values as a substring at the beginning of the text, with the given format.\n     * Equivalent to `this.insert(0, values, format)`.\n     */\n    unshift(values, format) {\n        return this.insert(0, values, format);\n    }\n    splice(start, deleteCount, values, format) {\n        // Sanitize start.\n        if (start < 0)\n            start += this.length;\n        if (start < 0)\n            start = 0;\n        if (start > this.length)\n            start = this.length;\n        // Sanitize deleteCount.\n        if (deleteCount === undefined || deleteCount > this.length - start)\n            deleteCount = this.length - start;\n        else if (deleteCount < 0)\n            deleteCount = 0;\n        // Delete then insert.\n        const ret = this.slice(start, start + deleteCount);\n        this.delete(start, deleteCount);\n        if (values !== undefined) {\n            this.insert(start, values, nonNull(format));\n        }\n        return ret;\n    }\n    // Convenience accessors.\n    // slice() is the most reasonable out of {slice, substring, substr}.\n    /**\n     * Returns a section of this text string,\n     * with behavior like\n     * [String.slice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/slice).\n     */\n    slice(start, end) {\n        return this.text.slice(start, end).join(\"\");\n    }\n    // Positions.\n    /**\n     * @return The position currently at index.\n     */\n    getPosition(index) {\n        return this.text.getPosition(index);\n    }\n    /**\n     * Returns the current index of position.\n     *\n     * If position is not currently present in the list\n     * ([[hasPosition]] returns false), then the result depends on searchDir:\n     * - \"none\" (default): Returns -1.\n     * - \"left\": Returns the next index to the left of position.\n     * If there are no values to the left of position,\n     * returns -1.\n     * - \"right\": Returns the next index to the right of position.\n     * If there are no values to the left of position,\n     * returns [[length]].\n     */\n    indexOfPosition(position, searchDir) {\n        return this.text.indexOfPosition(position, searchDir);\n    }\n    /**\n     * Returns whether position is currently present in the list,\n     * i.e., its value is present.\n     */\n    hasPosition(position) {\n        return this.text.hasPosition(position);\n    }\n    /**\n     * Returns the value at position, or undefined if it is not currently present\n     * ([[hasPosition]] returns false).\n     */\n    getByPosition(position) {\n        return this.text.getByPosition(position);\n    }\n    /** Returns an iterator for present positions, in list order. */\n    positions() {\n        return this.text.positions();\n    }\n    /**\n     * The abstract total order underlying this text CRDT.\n     *\n     * Access this to construct separate [[LocalList]] views on top of\n     * the same total order.\n     */\n    get totalOrder() {\n        return this.text.totalOrder;\n    }\n}\n// OPT: remove from CSpanLog any spans that are no longer referenced in\n// formatData (because they were completely overridden by later spans).\n// Could potentially do this using WeakRefs/WeakValueMap, so JS tells us\n// which spans are no longer referenced.\n/**\n * Returns data's format value for key.\n *\n * @param includeClosed Whether to consider endClosedSpans, i.e., you are\n * getting the format exactly at data's position.\n */\nfunction getDataValue(data, includeClosed, key) {\n    // eslint fails to infer types here, but TypeScript is fine.\n    if (includeClosed && data.endClosedSpans.has(key)) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return nonNull(data.endClosedSpans.get(key)).value;\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    }\n    else\n        return data.normalSpans.get(key)?.value;\n}\n/**\n * Returns data's complete format.\n *\n * The value is a new immutable object; mutations to it do not\n * affect CRichText and vice-versa.\n *\n * @param includeClosed Whether to consider endClosedSpans, i.e., you are\n * getting the format exactly at data's position.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction getDataRecord(data, includeClosed) {\n    const ans = {};\n    // Copy normalSpans, except omit undefined entries.\n    for (const [key, span] of data.normalSpans) {\n        if (span.value !== undefined)\n            ans[key] = span.value;\n    }\n    if (includeClosed) {\n        // data is exactly at position, so we need to copy endClosedSpans\n        // on top of normalSpans. If the result would be undefined, omit it.\n        for (const [key, span] of data.endClosedSpans) {\n            if (span.value === undefined)\n                delete ans[key];\n            else\n                ans[key] = span.value;\n        }\n    }\n    return ans;\n}\n/**\n * Utility class for outputting ranges in Format events and formatted().\n * This class takes care of converting positions and open/closed flags\n * to indexes, omitting empty ranges, and merging neighboring ranges\n * with the same data (according to the constructor's `equals` arg).\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nclass SliceBuilder {\n    constructor(list, equals) {\n        this.list = list;\n        this.equals = equals;\n        this.slices = [];\n        this.prevIndex = -1;\n        this.prevData = null;\n    }\n    /**\n     * Add a new range with the given data and interval start (start position\n     * + whether it's closed).\n     */\n    add(data, startPos, startClosed) {\n        // The index where this new span begins.\n        let index;\n        if (startPos === null)\n            index = 0;\n        else if (startClosed) {\n            index = this.list.indexOfPosition(startPos, \"right\");\n        }\n        else\n            index = this.list.indexOfPosition(startPos, \"left\") + 1;\n        if (this.prevIndex !== -1) {\n            // Record the previous call's data.\n            // Use ! instead of nonNull because D might allow null.\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this.record(this.prevIndex, index, this.prevData);\n        }\n        this.prevIndex = index;\n        this.prevData = data;\n    }\n    finish(nextPos, nextClosed) {\n        if (this.prevIndex !== -1) {\n            // Record the previous call's data.\n            // index is where the next span would begin, computed as in\n            // add except that null maps to the end.\n            let index;\n            if (nextPos === null)\n                index = this.list.length;\n            else if (nextClosed) {\n                index = this.list.indexOfPosition(nextPos, \"right\");\n            }\n            else\n                index = this.list.indexOfPosition(nextPos, \"left\") + 1;\n            // Use ! instead of nonNull because D might allow null.\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this.record(this.prevIndex, index, this.prevData);\n        }\n        return this.slices;\n    }\n    record(startIndex, endIndex, data) {\n        if (startIndex === endIndex)\n            return;\n        if (this.slices.length !== 0) {\n            const prevSlice = this.slices[this.slices.length - 1];\n            if (this.equals(prevSlice.data, data)) {\n                // Extend prevSlice.\n                prevSlice.endIndex = endIndex;\n                return;\n            }\n        }\n        // Add a new slice.\n        this.slices.push({ startIndex, endIndex, data });\n    }\n}\nfunction recordEquals(a, b) {\n    for (const [key, value] of Object.entries(a)) {\n        if (b[key] !== value)\n            return false;\n    }\n    for (const [key, value] of Object.entries(b)) {\n        if (a[key] !== value)\n            return false;\n    }\n    return true;\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction formatChangeEquals(a, b) {\n    if (a === null || b === null)\n        return a === b;\n    return (a.previousValue === b.previousValue && recordEquals(a.format, b.format));\n}\n//# sourceMappingURL=c_rich_text.js.map","import { CObject, StringSerializer, } from \"@collabs/core\";\nimport { CValueList } from \"./c_value_list\";\nimport { charArraySerializer } from \"./char_array_serializer\";\n/**\n * A collaborative text string, with the usual behavior\n * for collaborative text editing.\n *\n * CText is functionally equivalent to a [[CValueList]]`<string>` where each value\n * is a single character (UTF-16 codepoint),\n * but with an API more like [string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String).\n *\n * It is *not* safe to modify a CText while iterating over it. The iterator\n * will attempt to throw an exception if it detects such modification,\n * but this is not guaranteed.\n *\n * See also:\n * - [[CRichText]]: for rich text (text with inline formatting).\n * - [[CValueList]], [[CList]]: for general lists.\n * - [[CVar]]`<string>`: for a string that can be set and get atomically instead of\n * edited like text.\n */\nexport class CText extends CObject {\n    /**\n     * Constructs a CText.\n     */\n    constructor(init) {\n        super(init);\n        this.list = super.registerCollab(\"\", (init) => new CValueList(init, {\n            valueSerializer: StringSerializer.instance,\n            valueArraySerializer: charArraySerializer,\n        }));\n        // Events.\n        this.list.on(\"Insert\", (e) => this.emit(\"Insert\", {\n            index: e.index,\n            values: e.values.join(\"\"),\n            positions: e.positions,\n            meta: e.meta,\n        }));\n        this.list.on(\"Delete\", (e) => this.emit(\"Delete\", {\n            index: e.index,\n            values: e.values.join(\"\"),\n            positions: e.positions,\n            meta: e.meta,\n        }));\n    }\n    /**\n     * Inserts values as a substring at the given index.\n     *\n     * All values currently at or after `index` shift\n     * to the right, increasing their indices by `values.length`.\n     *\n     * @param index The insertion index in the range\n     * `[0, this.length]`. If `this.length`, the values\n     * are appended to the end of the list.\n     * @param values The characters to insert. They are inserted\n     * as individual UTF-16 codepoints.\n     * @throws If index is not in `[0, this.length]`.\n     */\n    insert(index, values) {\n        this.list.insert(index, ...values);\n    }\n    /**\n     * Delete `count` characters starting at `index`, i.e., characters\n     * `[index, index + count - 1)`.\n     *\n     * All later characters shift to the left,\n     * decreasing their indices by `count`.\n     *\n     * @param count The number of characters to delete.\n     * Defaults to 1 (delete the character at `index` only).\n     *\n     * @throws if `index < 0` or\n     * `index + count >= this.length`.\n     */\n    delete(index, count = 1) {\n        this.list.delete(index, count);\n    }\n    /**\n     * Deletes every character in the text string.\n     */\n    clear() {\n        this.list.clear();\n    }\n    /**\n     * Returns a string consisting of the single character\n     * (UTF-16 codepoint) at `index`.\n     *\n     * @throws If index is not in `[0, this.length)`.\n     * Note that this differs from an ordinary string,\n     * which would instead return an empty string.\n     */\n    charAt(index) {\n        return this.list.get(index);\n    }\n    /**\n     * Returns an iterator for characters (values) in the text string, in order.\n     *\n     * See also: [[toString]], which returns the entire text as a string.\n     */\n    values() {\n        return this.list.values();\n    }\n    /** Returns an iterator for characters (values) in the text string, in order. */\n    [Symbol.iterator]() {\n        return this.values();\n    }\n    /**\n     * Returns an iterator of [index, value, position] tuples for every\n     * character (value) in the text string, in order.\n     */\n    entries() {\n        return this.list.entries();\n    }\n    /**\n     * The length of the text string.\n     */\n    get length() {\n        return this.list.length;\n    }\n    /**\n     * Returns the text string as an ordinary string.\n     */\n    toString() {\n        return this.list.slice().join(\"\");\n    }\n    // Convenience mutators.\n    /**\n     * Inserts values as a substring at the end of the text.\n     * Equivalent to `this.insert(this.length, values)`.\n     *\n     * @param values The characters to push. They are inserted\n     * as individual UTF-16 codepoints.\n     */\n    push(values) {\n        this.insert(this.length, values);\n    }\n    /**\n     * Inserts values as a substring at the beginning of the text.\n     * Equivalent to `this.insert(0, values)`.\n     *\n     * @param values The characters to unshift. They are inserted\n     * as individual UTF-16 codepoints.\n     */\n    unshift(values) {\n        return this.insert(0, values);\n    }\n    /**\n     * Deletes and inserts values like [Array.splice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice).\n     *\n     * If `deleteCount` is provided, this method first deletes\n     * `deleteCount` values starting at `start`.\n     * Next, this method inserts `values` as a substring at `start`.\n     *\n     * All values currently at or after `start + deleteCount`\n     * shift to accommodate the change in length.\n     *\n     * @param values The characters to insert. They are inserted\n     * as individual UTF-16 codepoints.\n     * @returns The deleted substring.\n     */\n    splice(start, deleteCount, values) {\n        // Sanitize start.\n        if (start < 0)\n            start += this.length;\n        if (start < 0)\n            start = 0;\n        if (start > this.length)\n            start = this.length;\n        // Sanitize deleteCount.\n        if (deleteCount === undefined || deleteCount > this.length - start)\n            deleteCount = this.length - start;\n        else if (deleteCount < 0)\n            deleteCount = 0;\n        // Delete then insert.\n        const ret = this.slice(start, start + deleteCount);\n        this.delete(start, deleteCount);\n        if (values !== undefined) {\n            this.insert(start, values);\n        }\n        return ret;\n    }\n    // Convenience accessors.\n    // slice() is the most reasonable out of {slice, substring, substr}.\n    /**\n     * Returns a section of this text string,\n     * with behavior like\n     * [String.slice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/slice).\n     */\n    slice(start, end) {\n        return this.list.slice(start, end).join(\"\");\n    }\n    // Positions.\n    /**\n     * @return The position currently at index.\n     */\n    getPosition(index) {\n        return this.list.getPosition(index);\n    }\n    /**\n     * Returns the current index of position.\n     *\n     * If position is not currently present in the list\n     * ([[hasPosition]] returns false), then the result depends on searchDir:\n     * - \"none\" (default): Returns -1.\n     * - \"left\": Returns the next index to the left of position.\n     * If there are no values to the left of position,\n     * returns -1.\n     * - \"right\": Returns the next index to the right of position.\n     * If there are no values to the left of position,\n     * returns [[length]].\n     */\n    indexOfPosition(position, searchDir = \"none\") {\n        return this.list.indexOfPosition(position, searchDir);\n    }\n    /**\n     * Returns whether position is currently present in the list,\n     * i.e., its value is present.\n     */\n    hasPosition(position) {\n        return this.list.hasPosition(position);\n    }\n    /**\n     * Returns the value at position, or undefined if it is not currently present\n     * ([[hasPosition]] returns false).\n     */\n    getByPosition(position) {\n        return this.list.getByPosition(position);\n    }\n    /** Returns an iterator for present positions, in list order. */\n    positions() {\n        return this.list.positions();\n    }\n    /**\n     * The abstract total order underlying this text CRDT.\n     *\n     * Access this to construct separate [[LocalList]] views on top of\n     * the same total order.\n     */\n    get totalOrder() {\n        return this.list.totalOrder;\n    }\n}\n//# sourceMappingURL=c_text.js.map","import { CPrimitive, int64AsNumber, } from \"@collabs/core\";\nimport { CounterMessage, CounterSave } from \"../../generated/proto_compiled\";\n/**\n * A collaborative counter with an [[add]] operation.\n *\n * If multiple users call [[add]] concurrently, all\n * of their additions take effect.\n *\n * Values and add args are required to be safe integers, since floating-point addition is not\n * commutative. If you need non-integer values,\n * you should use e.g. `counter.value / 100`.\n *\n * See also: [[CVar]]`<number>`: for a number that can be set and get atomically instead of\n * counting.\n */\nexport class CCounter extends CPrimitive {\n    /**\n     * Constructs a CCounter.\n     *\n     * @param options.initialValue The initial value. Defaults to 0.\n     */\n    constructor(init, options = {}) {\n        super(init);\n        this.p = new Map();\n        this.n = new Map();\n        this.initialValue = options.initialValue ?? 0;\n        this._value = this.initialValue;\n    }\n    /**\n     * Adds the given number to [[value]].\n     *\n     * If multiple users call [[add]] concurrently, all\n     * of their additions take effect.\n     *\n     * @throws If `toAdd` is not a safe integer.\n     */\n    add(toAdd) {\n        if (!Number.isSafeInteger(toAdd)) {\n            throw new Error(\"toAdd must be a safe integer\");\n        }\n        if (toAdd === 0)\n            return;\n        const message = CounterMessage.create(toAdd === 1 ? {} : { arg: toAdd });\n        this.sendPrimitive(CounterMessage.encode(message).finish());\n    }\n    receivePrimitive(message, meta) {\n        const decoded = CounterMessage.decode(message);\n        const toAdd = int64AsNumber(decoded.arg);\n        if (toAdd > 0) {\n            this.p.set(meta.senderID, (this.p.get(meta.senderID) ?? 0) + toAdd);\n        }\n        else {\n            this.n.set(meta.senderID, (this.n.get(meta.senderID) ?? 0) - toAdd);\n        }\n        this._value += toAdd;\n        this.emit(\"Add\", { added: toAdd, value: this._value, meta });\n    }\n    /**\n     * The current value.\n     */\n    get value() {\n        return this._value;\n    }\n    savePrimitive() {\n        const message = CounterSave.create({\n            p: Object.fromEntries(this.p),\n            n: Object.fromEntries(this.n),\n        });\n        return CounterSave.encode(message).finish();\n    }\n    loadPrimitive(savedState, meta) {\n        if (savedState === null)\n            return;\n        const oldValue = this._value;\n        const decoded = CounterSave.decode(savedState);\n        this.mergeOne(this.p, decoded.p, 1);\n        this.mergeOne(this.n, decoded.n, -1);\n        if (this._value !== oldValue) {\n            this.emit(\"Add\", {\n                added: this._value - oldValue,\n                value: this._value,\n                meta,\n            });\n        }\n    }\n    mergeOne(current, incoming, sign) {\n        for (const [key, value] of Object.entries(incoming)) {\n            const a = current.get(key) ?? 0;\n            const b = int64AsNumber(value);\n            if (b > a) {\n                current.set(key, b);\n                this._value += sign * (b - a);\n            }\n        }\n    }\n}\n//# sourceMappingURL=c_counter.js.map","import { int64AsNumber, nonNull, protobufHas, } from \"@collabs/core\";\nimport { CRDTMessageMetaMessage, } from \"../../generated/proto_compiled\";\nexport class BasicVectorClock {\n    constructor(vcEntries) {\n        this.vcEntries = vcEntries;\n    }\n    get(replicaID) {\n        return this.vcEntries.get(replicaID) ?? 0;\n    }\n}\nexport class SendCRDTMeta {\n    constructor(senderID, actualVC, \n    /**\n     * Causally maximal VC keys minus senderID (even if it's causally maximal).\n     *\n     * We \"copy\" this right away, so okay if it is mutated later.\n     */\n    causallyMaximalVCKeys, actualWallClockTime, actualLamportTimestamp) {\n        this.senderID = senderID;\n        this.actualVC = actualVC;\n        this.actualWallClockTime = actualWallClockTime;\n        this.actualLamportTimestamp = actualLamportTimestamp;\n        /**\n         * The requested vector clock entries so far, plus\n         * senderID and causallyMaximalVCKeys.\n         *\n         * Iterator order is guaranteed to start with senderID,\n         * then causallyMaximalVCKeys.\n         *\n         * Public only for [[CRDTMetaSerializer]].\n         */\n        this.vcEntries = new Map();\n        this.wallClockTimeIfRequested = null;\n        this.lamportTimestampIfRequested = null;\n        /**\n         * Note this may be toggled back and forth.\n         */\n        this.isAutomatic = false;\n        this.isFrozen = false;\n        this.senderCounter = nonNull(actualVC.get(senderID));\n        this.vcEntries.set(senderID, this.senderCounter);\n        if (causallyMaximalVCKeys.has(senderID)) {\n            throw new Error(\"Internal error: causallyMaximalVCKeys has senderID\");\n        }\n        this.maximalVCKeyCount = causallyMaximalVCKeys.size;\n        for (const replicaID of causallyMaximalVCKeys) {\n            this.vcEntries.set(replicaID, nonNull(actualVC.get(replicaID)));\n        }\n        this.vectorClock = { get: this.vectorClockGet.bind(this) };\n    }\n    vectorClockGet(replicaID) {\n        if (this.isAutomatic) {\n            this.requestVectorClockEntry(replicaID);\n        }\n        const clock = this.vcEntries.get(replicaID);\n        if (!this.isFrozen && clock === undefined) {\n            throw new Error(\"You must request a vector clock entry (or automatic mode) to access it (entry:\" +\n                replicaID +\n                \")\");\n        }\n        return clock ?? 0;\n    }\n    get wallClockTime() {\n        if (this.isAutomatic) {\n            this.requestWallClockTime();\n        }\n        else if (!this.isFrozen && this.wallClockTimeIfRequested === null) {\n            throw new Error(\"You must request wallClockTime (or automatic mode) to access it\");\n        }\n        return this.wallClockTimeIfRequested;\n    }\n    get lamportTimestamp() {\n        if (this.isAutomatic) {\n            this.requestLamportTimestamp();\n        }\n        else if (!this.isFrozen && this.lamportTimestampIfRequested === null) {\n            throw new Error(\"You must request lamportTimestamp (or automatic mode) to access it\");\n        }\n        return this.lamportTimestampIfRequested;\n    }\n    requestAutomatic(value) {\n        this.isAutomatic = value;\n    }\n    requestVectorClockEntry(replicaID) {\n        const entry = this.actualVC.get(replicaID);\n        if (entry === undefined) {\n            throw new Error(\"Unknown replicaID: \" + replicaID);\n        }\n        // Don't re-set if already present, to avoid messing up iterator order\n        // (needed for causallyMaximalVCKeys).\n        if (!this.vcEntries.has(replicaID)) {\n            this.vcEntries.set(replicaID, entry);\n        }\n    }\n    requestWallClockTime() {\n        this.wallClockTimeIfRequested = this.actualWallClockTime;\n    }\n    requestLamportTimestamp() {\n        this.lamportTimestampIfRequested = this.actualLamportTimestamp;\n    }\n    /**\n     * Freezes this SendCRDTMeta at the end of its sending transaction.\n     *\n     * After freezing, all getters behave like ReceiveCRDTMeta. In\n     * particular, getting a non-requested property will return a\n     * default value instead of an error. This is in case a Collab\n     * stores SendCRDTMeta after a transaction, then later queries it\n     * for e.g. newly-relevant VC entries (expecting 0).\n     */\n    freeze() {\n        this.isFrozen = true;\n    }\n    toString() {\n        return JSON.stringify({\n            sender: this.senderID,\n            senderCounter: this.senderCounter,\n            vectorClock: Object.entries(this.vcEntries),\n            wallClockTime: this.wallClockTime,\n            lamportTimestamp: this.lamportTimestamp,\n        });\n    }\n}\nexport class ReceiveCRDTMeta {\n    constructor(senderID, senderCounter, \n    /**\n     * Iterator order must be the same as in SendCRDTMeta.\n     *\n     * Public only for [[RuntimeMetaSerializer]].\n     */\n    vcEntries, \n    /**\n     * The number of entries at the beginning of vcEntries's\n     * iterator order but after senderID (which is first)\n     * that are causally maximal.\n     *\n     * Empty if CRDTMetaLayer's\n     * causalityGuaranteed flag is true.\n     */\n    maximalVCKeyCount, wallClockTime, lamportTimestamp) {\n        this.senderID = senderID;\n        this.senderCounter = senderCounter;\n        this.vcEntries = vcEntries;\n        this.maximalVCKeyCount = maximalVCKeyCount;\n        this.wallClockTime = wallClockTime;\n        this.lamportTimestamp = lamportTimestamp;\n        this.vectorClock = new BasicVectorClock(vcEntries);\n    }\n    toString() {\n        return JSON.stringify({\n            sender: this.senderID,\n            senderCounter: this.senderCounter,\n            vectorClock: Object.entries(this.vcEntries),\n            wallClockTime: this.wallClockTime,\n            lamportTimestamp: this.lamportTimestamp,\n        });\n    }\n}\n/**\n * Serializer for MessageMeta produced by CRuntime.\n *\n * runtimeExtra field must be either ReceiveCRDTMeta\n * or a frozen SendCRDTMeta.\n *\n * Implements Serializer<MessageMeta>.\n */\nexport const RuntimeMetaSerializer = {\n    serialize(value, replicaIDEncoder) {\n        const crdtMeta = value.runtimeExtra;\n        const vcKeysMaybeEncoded = new Array(crdtMeta.vcEntries.size - 1);\n        const vcValues = new Array(crdtMeta.vcEntries.size - 1);\n        // Write vc entries in the order they were set, skipping senderID\n        // (which is first).\n        // Thus the order starts with non-sender causallyMaximalVCKeys.\n        let i = 0;\n        for (const [key, value] of crdtMeta.vcEntries) {\n            if (key === crdtMeta.senderID)\n                continue;\n            if (replicaIDEncoder)\n                vcKeysMaybeEncoded[i] = replicaIDEncoder(key);\n            else\n                vcKeysMaybeEncoded[i] = key;\n            vcValues[i] = value;\n            i++;\n        }\n        const message = {\n            senderID: crdtMeta.senderID,\n            senderCounter: crdtMeta.senderCounter,\n            vcValues,\n            maximalVcKeyCount: crdtMeta.maximalVCKeyCount === 0\n                ? undefined\n                : crdtMeta.maximalVCKeyCount,\n            wallClockTime: crdtMeta.wallClockTime,\n            lamportTimestamp: crdtMeta.lamportTimestamp,\n        };\n        if (replicaIDEncoder)\n            message.encodedVcKeys = vcKeysMaybeEncoded;\n        else\n            message.vcKeys = vcKeysMaybeEncoded;\n        return CRDTMessageMetaMessage.encode(message).finish();\n    },\n    deserialize(message, replicaIDDecoder) {\n        const decoded = CRDTMessageMetaMessage.decode(message);\n        const vc = new Map();\n        vc.set(decoded.senderID, decoded.senderCounter);\n        for (let i = 0; i < decoded.vcValues.length; i++) {\n            const vcKey = replicaIDDecoder\n                ? replicaIDDecoder[decoded.encodedVcKeys[i]]\n                : decoded.vcKeys[i];\n            vc.set(vcKey, decoded.vcValues[i]);\n        }\n        const crdtMeta = new ReceiveCRDTMeta(decoded.senderID, decoded.senderCounter, vc, \n        // Missing converted to 0 by protobufjs - okay.\n        decoded.maximalVcKeyCount, protobufHas(decoded, \"wallClockTime\")\n            ? int64AsNumber(decoded.wallClockTime)\n            : null, protobufHas(decoded, \"lamportTimestamp\")\n            ? int64AsNumber(decoded.lamportTimestamp)\n            : null);\n        return {\n            senderID: crdtMeta.senderID,\n            updateType: \"message\",\n            isLocalOp: false,\n            runtimeExtra: crdtMeta,\n        };\n    },\n};\nexport class LoadCRDTMeta {\n    constructor(senderID, localVCEntries, remoteVCEntries, localLamportTimestamp, remoteLamportTimestamp) {\n        this.senderID = senderID;\n        this.localLamportTimestamp = localLamportTimestamp;\n        this.remoteLamportTimestamp = remoteLamportTimestamp;\n        this.localVectorClock = new BasicVectorClock(localVCEntries);\n        this.remoteVectorClock = new BasicVectorClock(remoteVCEntries);\n    }\n    toString() {\n        return JSON.stringify({\n            localVectorClock: Object.entries(this.localVectorClock.vcEntries),\n            remoteVectorClock: Object.entries(this.remoteVectorClock.vcEntries),\n        });\n    }\n}\n//# sourceMappingURL=crdt_meta_implementations.js.map","var _a;\nimport { MessageStacksSerializer, } from \"@collabs/core\";\nimport { MessageSerializerMergeInfo } from \"../../generated/proto_compiled\";\nimport { RuntimeMetaSerializer } from \"./crdt_meta_implementations\";\nvar MessageType;\n(function (MessageType) {\n    MessageType[\"Merged\"] = \"m\";\n})(MessageType || (MessageType = {}));\n/**\n * Serializer for the messages sent by CRuntime.\n */\nexport class MessageSerializer {\n    constructor() {\n        // Singleton class - use instance instead.\n    }\n    serialize(value) {\n        if (value.length === 1) {\n            // Default message type (single-transaction message).\n            // We indicate this by using a Uint8Array as the footer, instead of a\n            // (string) MessageType.\n            const { messageStacks, meta } = value[0];\n            messageStacks.push([RuntimeMetaSerializer.serialize(meta)]);\n            return MessageStacksSerializer.instance.serialize(messageStacks);\n        }\n        else {\n            // Merged message (multiple transactions in one).\n            // To compress vector clocks, we encode replicaIDs using their index in this array.\n            const replicaIDs = [];\n            const replicaIDsInv = new Map();\n            const replicaIDEncoder = (replicaID) => {\n                let index = replicaIDsInv.get(replicaID);\n                if (index === undefined) {\n                    index = replicaIDs.length;\n                    replicaIDs.push(replicaID);\n                    replicaIDsInv.set(replicaID, index);\n                }\n                return index;\n            };\n            const allMessageStacks = [];\n            const lengths = new Array(value.length);\n            let i = 0;\n            for (const { messageStacks, meta } of value) {\n                // Push the messageStacks themselves followed by the serialized meta.\n                allMessageStacks.push(...messageStacks);\n                allMessageStacks.push([\n                    RuntimeMetaSerializer.serialize(meta, replicaIDEncoder),\n                ]);\n                lengths[i] = messageStacks.length;\n                i++;\n            }\n            // Push info and footer.\n            allMessageStacks.push([\n                MessageSerializerMergeInfo.encode({ replicaIDs, lengths }).finish(),\n            ]);\n            allMessageStacks.push([MessageType.Merged]);\n            return MessageStacksSerializer.instance.serialize(allMessageStacks);\n        }\n    }\n    deserialize(message, trMessages = false) {\n        const allMessageStacks = MessageStacksSerializer.instance.deserialize(message);\n        const footer = allMessageStacks.pop()[0];\n        if (typeof footer === \"string\") {\n            // footer indicates the message type.\n            switch (footer) {\n                case MessageType.Merged: {\n                    // Merged message (multiple transactions in one).\n                    const ans = [];\n                    const info = MessageSerializerMergeInfo.decode(\n                    // Note: footer removed by earlier pop().\n                    allMessageStacks.pop()[0]);\n                    let nextStart = 0;\n                    for (const length of info.lengths) {\n                        const messageStacks = allMessageStacks.slice(nextStart, nextStart + length);\n                        const meta = RuntimeMetaSerializer.deserialize(allMessageStacks[nextStart + length][0], info.replicaIDs);\n                        const tr = { messageStacks, meta };\n                        if (trMessages) {\n                            tr.trMessage = this.serialize([\n                                { messageStacks: messageStacks.slice(), meta },\n                            ]);\n                        }\n                        ans.push(tr);\n                        nextStart += length + 1;\n                    }\n                    // We should have processed all of allMessageStacks.\n                    // Note: footer and info removed by earlier pop()s.\n                    if (nextStart !== allMessageStacks.length) {\n                        throw new Error(\"Internal error: lengths/allMessageStacks mismatch\");\n                    }\n                    return ans;\n                }\n                default:\n                    throw new Error('Unknown message type \"' +\n                        footer +\n                        '\"; your @collabs/collabs version may need updating');\n            }\n        }\n        else {\n            // No message type - use default (single-transaction message).\n            const meta = RuntimeMetaSerializer.deserialize(footer);\n            return [\n                {\n                    trMessage: trMessages ? message : undefined,\n                    // Note: footer removed by earlier pop().\n                    messageStacks: allMessageStacks,\n                    meta,\n                },\n            ];\n        }\n    }\n}\n_a = MessageSerializer;\nMessageSerializer.instance = new _a();\n//# sourceMappingURL=message_serializer.js.map","import { int64AsNumber, nonNull } from \"@collabs/core\";\nimport { CausalMessageBufferSave } from \"../../generated/proto_compiled\";\nimport { LoadCRDTMeta } from \"./crdt_meta_implementations\";\nimport { MessageSerializer } from \"./message_serializer\";\n/**\n * A buffer for delivering messages in causal order, used\n * by [[CRuntime]].\n *\n * Also manages CRDT metadata (vector clock, causally maximal keys,\n * Lamport timestamp).\n */\nexport class CausalMessageBuffer {\n    /**\n     * @param deliver Callback to deliver messages, where\n     * \"deliver\" means \"actually process since it's causally\n     * ready now\".\n     */\n    constructor(replicaID, causalityGuaranteed, deliver) {\n        this.replicaID = replicaID;\n        this.causalityGuaranteed = causalityGuaranteed;\n        this.deliver = deliver;\n        /**\n         * The vector clock. Missing entries are presumed 0.\n         *\n         * An entry for this replica is always present, even when 0.\n         *\n         * Do not modify externally.\n         */\n        this.vc = new Map();\n        /**\n         * Never includes us, even if we are causally maximal.\n         *\n         * If causalityGuaranteed, this is always empty.\n         *\n         * Do not modify externally.\n         */\n        this.maximalVCKeys = new Set();\n        /**\n         * The Lamport timestamp.\n         *\n         * Do not modify externally.\n         *\n         * Although this starts at 0, any transaction that uses the Lamport timestamp\n         * will have a positive value, since tick() increments it.\n         */\n        this.lamportTimestamp = 0;\n        /**\n         * Internal buffer for messages that have been received but not\n         * yet delivered, either because check() was not called or they\n         * are not causally ready.\n         *\n         * Keyed by encodeDot's output.\n         */\n        this.buffer = new Map();\n        // this.replicaID is the first map entry.\n        this.vc.set(this.replicaID, 0);\n    }\n    encodeDot(crdtMeta) {\n        return `${crdtMeta.senderCounter},${crdtMeta.senderID}`;\n    }\n    /**\n     * Processes the given remote message:\n     * - If already delivered, does nothing.\n     * - Else if ready for delivery, delivers it.\n     * - Else adds it to the buffer.\n     *\n     * @param message Must be a transaction-message, not a merged-message.\n     * @returns Whether the message was delivered.\n     */\n    process(message, messageStacks, meta, caller) {\n        const crdtMeta = meta.runtimeExtra;\n        if (!this.isAlreadyDelivered(crdtMeta)) {\n            if (this.isReady(crdtMeta)) {\n                // Ready for delivery.\n                this.deliver(message, messageStacks, meta, caller);\n                this.processRemoteDelivery(crdtMeta);\n                return true;\n            }\n            else {\n                // Add to this.buffer if it's not already present.\n                const dot = this.encodeDot(crdtMeta);\n                if (!this.buffer.has(dot)) {\n                    this.buffer.set(dot, { message, messageStacks, meta, caller });\n                }\n            }\n        }\n        return false;\n    }\n    /**\n     * Checks the buffer and delivers any causally ready\n     * messages.\n     *\n     * @returns Whether any messages were delivered.\n     */\n    check() {\n        let delivered = false;\n        let recheck = false;\n        do {\n            recheck = false;\n            for (const [dot, tr] of this.buffer) {\n                const crdtMeta = tr.meta.runtimeExtra;\n                if (this.isReady(crdtMeta)) {\n                    // Ready for delivery.\n                    this.buffer.delete(dot);\n                    this.deliver(tr.message, tr.messageStacks, tr.meta, tr.caller);\n                    this.processRemoteDelivery(crdtMeta);\n                    delivered = true;\n                    // Delivering messages may make new ones ready, so go\n                    // through the whole buffer again.\n                    recheck = true;\n                }\n                else {\n                    if (this.isAlreadyDelivered(crdtMeta)) {\n                        // Remove from the buffer.\n                        this.buffer.delete(dot);\n                    }\n                }\n            }\n        } while (recheck);\n        return delivered;\n    }\n    /**\n     * @return whether a message with the given crdtMeta\n     * is ready for delivery, according to the causal order.\n     */\n    isReady(crdtMeta) {\n        if (this.causalityGuaranteed)\n            return true;\n        // Check that sender's entry is one more than ours.\n        if ((this.vc.get(crdtMeta.senderID) ?? 0) !== crdtMeta.senderCounter - 1) {\n            return false;\n        }\n        // Check that other causally maximal entries are <= ours.\n        let i = 0;\n        for (const [key, value] of crdtMeta.vcEntries) {\n            // maximalVCKeyCount omits senderID, so skip it without\n            // incrementing i.\n            if (key === crdtMeta.senderID)\n                continue;\n            if (i === crdtMeta.maximalVCKeyCount)\n                break;\n            if ((this.vc.get(key) ?? 0) < value) {\n                return false;\n            }\n            i++;\n        }\n        return true;\n    }\n    /**\n     * @return whether a message with the given sender and\n     * senderCounter\n     * has already been delivered.\n     */\n    isAlreadyDelivered(crdtMeta) {\n        const senderEntry = this.vc.get(crdtMeta.senderID);\n        if (senderEntry !== undefined) {\n            if (senderEntry >= crdtMeta.senderCounter)\n                return true;\n        }\n        return false;\n    }\n    processRemoteDelivery(crdtMeta) {\n        if (!this.causalityGuaranteed) {\n            // Delete any current keys that are causally dominated by\n            // crdtMeta.\n            let i = 0;\n            for (const [key, value] of crdtMeta.vcEntries) {\n                // maximalVCKeyCount omits senderID, so skip it without\n                // incrementing i.\n                if (key === crdtMeta.senderID)\n                    continue;\n                if (i === crdtMeta.maximalVCKeyCount)\n                    break;\n                if (this.vc.get(key) === value) {\n                    this.maximalVCKeys.delete(key);\n                }\n                i++;\n            }\n            // Add a new key for this message.\n            // Since it's remote, we know senderID is not our ID.\n            this.maximalVCKeys.add(crdtMeta.senderID);\n        }\n        // Update vc.\n        this.vc.set(crdtMeta.senderID, crdtMeta.senderCounter);\n        // Update Lamport timestamp if it's present.\n        // Skipping this when it's not present technically violates the def\n        // of Lamport timestamp, but it is still causally-compatible due to\n        // causal order delivery.\n        this.lamportTimestamp = Math.max(this.lamportTimestamp, crdtMeta.lamportTimestamp ?? 0);\n    }\n    /**\n     * Update our meta for a new local transaction.\n     */\n    tick() {\n        // Update vc.\n        this.vc.set(this.replicaID, nonNull(this.vc.get(this.replicaID)) + 1);\n        if (!this.causalityGuaranteed) {\n            // Our own message causally dominates every current key.\n            this.maximalVCKeys.clear();\n        }\n        // Update Lamport timestamp.\n        this.lamportTimestamp++;\n    }\n    save() {\n        const vcKeys = new Array(this.vc.size);\n        const vcValues = new Array(this.vc.size);\n        let i = 0;\n        for (const [key, value] of this.vc) {\n            // Since this.replicaID is the first map entry, it is stored in\n            // vcKeys[0].\n            vcKeys[i] = key;\n            vcValues[i] = value;\n            i++;\n        }\n        const bufferMessages = new Array(this.buffer.size);\n        i = 0;\n        for (const tr of this.buffer.values()) {\n            bufferMessages[i] = tr.message;\n            i++;\n        }\n        const saveMessage = CausalMessageBufferSave.create({\n            vcKeys,\n            vcValues,\n            maximalVcKeys: [...this.maximalVCKeys],\n            lamportTimestamp: this.lamportTimestamp,\n            bufferMessages,\n        });\n        return CausalMessageBufferSave.encode(saveMessage).finish();\n    }\n    /**\n     * @param savedState\n     * @param used\n     */\n    load(savedState, caller) {\n        const oldLocalVC = new Map(this.vc);\n        const oldLocalLamportTimestamp = this.lamportTimestamp;\n        const decoded = CausalMessageBufferSave.decode(savedState);\n        const remoteVC = new Map();\n        for (let i = 0; i < decoded.vcKeys.length; i++) {\n            remoteVC.set(decoded.vcKeys[i], int64AsNumber(decoded.vcValues[i]));\n        }\n        const remoteMaximalVCKeys = new Set(decoded.maximalVcKeys);\n        // 1. Delete our maximal entries that are not present in the saved\n        // state and that are causally dominated by the remote VC.\n        // (Strictly speaking, we compare entries not keys: values must match\n        // to be present in the intersection.)\n        for (const key of this.maximalVCKeys) {\n            const localValue = nonNull(this.vc.get(key));\n            const remoteValue = remoteVC.get(key) ?? 0;\n            // If the entry is not in the intersection...\n            if (!(remoteMaximalVCKeys.has(key) && localValue === remoteValue)) {\n                // ...and it's causally dominated, then delete it.\n                if (remoteValue >= localValue)\n                    this.maximalVCKeys.delete(key);\n            }\n        }\n        // 2. Add new maximal entries that are not\n        // causally dominated by the local VC.\n        for (const key of remoteMaximalVCKeys) {\n            if ((this.vc.get(key) ?? 0) < nonNull(remoteVC.get(key))) {\n                this.maximalVCKeys.add(key);\n            }\n        }\n        // Delete our replicaID if it ended up in maximalVCKeys.\n        this.maximalVCKeys.delete(this.replicaID);\n        for (const [key, value] of remoteVC) {\n            this.vc.set(key, Math.max(this.vc.get(key) ?? 0, value));\n        }\n        const remoteLamportTimestamp = int64AsNumber(decoded.lamportTimestamp);\n        this.lamportTimestamp = Math.max(this.lamportTimestamp, remoteLamportTimestamp);\n        // Blindly merge buffers for now. CRuntime will call check() later\n        // to process any newly-ready messages (local or remote)\n        // and delete already-received messages.\n        for (let i = 0; i < decoded.bufferMessages.length; i++) {\n            const message = decoded.bufferMessages[i];\n            // Buffer messages are always transaction-messages (not merged).\n            const { messageStacks, meta } = MessageSerializer.instance.deserialize(message)[0];\n            const dot = this.encodeDot(meta.runtimeExtra);\n            if (!this.buffer.has(dot)) {\n                this.buffer.set(dot, {\n                    message,\n                    messageStacks,\n                    meta,\n                    caller,\n                });\n            }\n        }\n        return new LoadCRDTMeta(\n        // First vc entry is the sender's replicaID.\n        decoded.vcKeys[0], oldLocalVC, remoteVC, oldLocalLamportTimestamp, remoteLamportTimestamp);\n    }\n}\n//# sourceMappingURL=causal_message_buffer.js.map","import { AbstractRuntime, CObject, nonNull, ReplicaIDs, SavedStateTreeSerializer, } from \"@collabs/core\";\nimport { CausalMessageBuffer } from \"./causal_message_buffer\";\nimport { SendCRDTMeta } from \"./crdt_meta_implementations\";\nimport { MessageSerializer } from \"./message_serializer\";\nclass PublicCObject extends CObject {\n    registerCollab(name, childCallback) {\n        return super.registerCollab(name, childCallback);\n    }\n}\n/**\n * A runtime for a Collabs document, responsible for managing the document's\n * [[Collab]]s.\n *\n * To get started with CRuntime, see\n * [Documents](https://collabs.readthedocs.io/en/latest/guide/documents.html).\n *\n * CRuntime is network- and storage-agnostic. By itself, it does not connect\n * to remote collaborators or persistent storage.\n * To easily set up networking and storage, configure\n * [Providers](https://collabs.readthedocs.io/en/latest/guide/providers.html).\n * Or, manually manage updates using the methods in this class; see\n * [Updates and Sync](https://collabs.readthedocs.io/en/latest/advanced/updates.html).\n *\n * See also: [[AbstractDoc]], which lets you encapsulate\n * a CRuntime and its registered Collabs in a single object.\n */\nexport class CRuntime extends AbstractRuntime {\n    /**\n     * Constructs a [[CRuntime]].\n     *\n     * @param options See [[DocOptions]].\n     */\n    constructor(options = {}) {\n        super(options.debugReplicaID ?? ReplicaIDs.random());\n        // State vars.\n        this.used = false;\n        this.inReceiveOrLoad = false;\n        // Transaction vars.\n        this.inTransaction = false;\n        this.crdtMeta = null;\n        this.meta = null;\n        this.messageBatches = [];\n        // batchDeliveries() vars.\n        this.inBatchRemote = false;\n        this.batchChanged = false;\n        this.isCRDTRuntime = true;\n        const causalityGuaranteed = options.causalityGuaranteed ?? false;\n        this.autoTransactions = options.autoTransactions ?? \"microtask\";\n        this.allowRedundantLoads = options.allowRedundantLoads ?? false;\n        this.registry = super.setRootCollab((init) => new PublicCObject(init));\n        this.buffer = new CausalMessageBuffer(this.replicaID, causalityGuaranteed, this.deliverFromBuffer.bind(this));\n    }\n    /**\n     * Registers a [[Collab]] as part of this document.\n     * See [Documents - Using CRuntime](https://collabs.readthedocs.io/en/latest/guide/documents.html#using-cruntime).\n     *\n     * Typically, you will call this method right after creating this CRuntime, with the style:\n     * ```ts\n     * const foo = runtime.registerCollab(\"foo\", (init) => new FooClass(init, constructor args...));\n     * ```\n     * where `const foo: FooClass;` is a top-level variable.\n     *\n     * Registrations must be identical across all replicas, i.e., all CRuntime instances that share\n     * messages and saved states.\n     *\n     * @param name A name for the registered Collab, unique among\n     * this document's `registerCollab` calls.\n     * We recommend using the same name as the variable where you store the Collab,\n     * but you can also use short strings to reduce\n     * network usage (\"\", \"0\", \"1\", ...).\n     * @param collabCallback A callback that uses the\n     * given [[InitToken]] to construct the registered [[Collab]].\n     * @return The registered Collab.\n     */\n    registerCollab(name, collabCallback) {\n        if (this.used) {\n            throw new Error(\"Already used (sent/received message or loaded state)\");\n        }\n        return this.registry.registerCollab(name, collabCallback);\n    }\n    beginTransaction() {\n        // We don't ban local ops during batchRemoteUpdates but outside\n        // of a receive/load call (e.g., during the \"Change\" event handler -\n        // a reasonable place to update CPresence state).\n        this.inTransaction = true;\n        // Wait to set meta until we actually send a message, if we do.\n        // messageBatches was already cleared by the previous endTransaction.\n    }\n    endTransaction() {\n        this.inTransaction = false;\n        if (this.meta === null) {\n            // Trivial transaction, skip.\n            return;\n        }\n        const meta = this.meta;\n        const crdtMeta = nonNull(this.crdtMeta);\n        crdtMeta.freeze();\n        const message = MessageSerializer.instance.serialize([\n            { messageStacks: this.messageBatches, meta },\n        ]);\n        this.messageBatches = [];\n        this.meta = null;\n        this.crdtMeta = null;\n        // Send. This message, or a saved state containing its transaction, should\n        // be delivered to each other replica, eventually at-least-once.\n        this.emit(\"Send\", {\n            message,\n            senderID: this.replicaID,\n            senderCounter: crdtMeta.senderCounter,\n        });\n        this.emit(\"Update\", {\n            update: message,\n            caller: undefined,\n            updateType: \"message\",\n            senderID: this.replicaID,\n            senderCounter: crdtMeta.senderCounter,\n            isLocalOp: true,\n        });\n        this.emit(\"Change\", { isLocalOp: true });\n    }\n    /**\n     * Wraps `f`'s operations in a\n     * [transaction](https://collabs.readthedocs.io/en/latest/advanced/updates.html#terminology).\n     *\n     * `f()` is called immediately, then if it performed any local Collab operations,\n     * their transaction is ended (emitting \"Send\", \"Update\", and \"Change\" events).\n     *\n     * Notes:\n     * - Operations not wrapped in a `transact` call use the constructor's\n     * [[DocOptions.autoTransactions]] option.\n     * - If there are nested `transact` calls (possibly due to\n     * DocOptions.autoTransactions), only the outermost one matters.\n     *\n     * See also: [[batchRemoteUpdates]], a similar method for remote updates.\n     */\n    transact(f) {\n        if (this.inTransaction)\n            f();\n        else {\n            this.beginTransaction();\n            try {\n                f();\n            }\n            finally {\n                this.endTransaction();\n            }\n        }\n    }\n    childSend(child, messageStack, metaRequests) {\n        if (child !== this.rootCollab) {\n            throw new Error(`childSend called by non-root: ${child}`);\n        }\n        if (this.inReceiveOrLoad) {\n            throw new Error(\"CRuntime.send called during a receive/load call;\" +\n                \" did you try to perform an operation in an event handler?\");\n        }\n        this.used = true;\n        let autoEndTransaction = false;\n        if (!this.inTransaction) {\n            // Create a transaction according to options.autoTransactions.\n            // Note that calls to transact() inside this transaction do nothing,\n            // so we don't have to worry about ending them early or double-ending.\n            switch (this.autoTransactions) {\n                case \"microtask\":\n                    this.beginTransaction();\n                    void Promise.resolve().then(() => this.endTransaction());\n                    break;\n                case \"debugOp\":\n                    this.beginTransaction();\n                    autoEndTransaction = true;\n                    break;\n                case \"error\":\n                    throw new Error('Operation outside of transaction when options.autoTransactions = \"error\"');\n            }\n        }\n        try {\n            if (this.meta === null) {\n                // First message in a transaction; tick our current VC etc.\n                // and use the new values to create the transaction's meta.\n                // OPT: avoid this copy (not required by SendCRDTMeta,\n                // but required due to tick()).\n                const causallyMaximalVCKeys = new Set(this.buffer.maximalVCKeys);\n                this.buffer.tick();\n                this.crdtMeta = new SendCRDTMeta(this.replicaID, this.buffer.vc, causallyMaximalVCKeys, Date.now(), this.buffer.lamportTimestamp);\n                this.meta = {\n                    senderID: this.replicaID,\n                    updateType: \"message\",\n                    isLocalOp: true,\n                    runtimeExtra: this.crdtMeta,\n                };\n            }\n            // Process meta requests, including automatic mode by default.\n            const crdtMeta = nonNull(this.crdtMeta);\n            crdtMeta.requestAutomatic(true);\n            for (const metaRequest of metaRequests) {\n                if (metaRequest.lamportTimestamp)\n                    crdtMeta.requestLamportTimestamp();\n                if (metaRequest.wallClockTime)\n                    crdtMeta.requestWallClockTime();\n                if (metaRequest.vectorClockKeys) {\n                    for (const sender of metaRequest.vectorClockKeys) {\n                        crdtMeta.requestVectorClockEntry(sender);\n                    }\n                }\n            }\n            // Local echo.\n            this.rootCollab.receive(messageStack.slice(), this.meta);\n            // Disable automatic meta request, to prevent accesses outside of\n            // the local echo from changing the meta locally only.\n            crdtMeta.requestAutomatic(false);\n            this.messageBatches.push(messageStack);\n        }\n        finally {\n            if (autoEndTransaction)\n                this.endTransaction();\n        }\n    }\n    /**\n     * Delivers remotes updates (receive/load calls) in a *batch*,\n     * so that only a single \"Change\" event is emitted for the entire batch.\n     *\n     * `f()` is called immediately, then if it delivered any remote updates,\n     * a single \"Change\" event is emitted.\n     * That way, \"Change\" listeners know that they only need\n     * to refresh the display once at the end, instead of once per receive/load\n     * call.\n     *\n     * Notes:\n     * - Each delivered update still emits its own \"Update\" event immediately,\n     * as usual.\n     * - If there are nested batchRemoteUpdates calls, only the outermost\n     * one matters.\n     *\n     * See also: [[transact]], a similar method for local operations.\n     *\n     * @param f A callback that delivers the remote updates by calling\n     * [[receive]]/[[load]].\n     */\n    batchRemoteUpdates(f) {\n        if (this.inTransaction) {\n            throw new Error(\"Cannot apply remote updates during a local transaction\");\n            // That would violate the constraint that all ops during a transaction\n            // have the same metadata, including the same vector clock.\n        }\n        if (this.inBatchRemote)\n            f();\n        else {\n            this.inBatchRemote = true;\n            this.batchChanged = false;\n            try {\n                f();\n            }\n            finally {\n                this.inBatchRemote = false;\n                if (this.batchChanged) {\n                    this.emit(\"Change\", { isLocalOp: false });\n                }\n            }\n        }\n    }\n    /**\n     * Receives a message from another replica's [[DocEventsRecord.Send]] event.\n     * The message's sender must be a CRuntime that is a\n     * replica of this one (i.e., it has the same\n     * [\"schema\"](https://collabs.readthedocs.io/en/latest/guide/documents.html#using-cruntime)).\n     *\n     * The local Collabs process the message, change the\n     * local state accordingly, and emit events describing the\n     * local changes.\n     *\n     * Messages from other replicas should be received eventually and at-least-once. Arbitrary delays, duplicates,\n     * reordering, and delivery of (redundant) messages from this replica\n     * are acceptable. Two replicas will be in the same\n     * state once they have the same set of received (or sent) messages.\n     *\n     * @param caller Optionally, a value to use as the \"Update\" event's\n     * [[MessageEvent.caller]] field.\n     * A caller can use that field to distinguish its own updates from updates\n     * delivered by other sources.\n     */\n    receive(message, caller) {\n        if (this.inTransaction) {\n            throw new Error(\"Cannot call receive() during a transaction\");\n        }\n        if (this.inReceiveOrLoad) {\n            throw new Error(\"Cannot call receive() during another receive/load call;\" +\n                \" did you try to deliver a message in a Collab's event handler?\");\n        }\n        this.used = true;\n        this.batchRemoteUpdates(() => {\n            this.inReceiveOrLoad = true;\n            try {\n                const decoded = MessageSerializer.instance.deserialize(message, true);\n                let anyDelivered = false;\n                // If message is a merged-message, then decoded will have more\n                // than one transaction-message. We process them one at a time.\n                for (const { trMessage, messageStacks, meta } of decoded) {\n                    if (this.buffer.process(trMessage, messageStacks, meta, caller)) {\n                        anyDelivered = true;\n                        this.batchChanged = true;\n                    }\n                }\n                if (anyDelivered)\n                    this.buffer.check();\n            }\n            finally {\n                this.inReceiveOrLoad = false;\n            }\n        });\n    }\n    /**\n     * Called by this.buffer when a (remote) transaction is ready for delivery.\n     * This is always within our call to this.buffer.check() in [[receive]]\n     * or [[load]], so that method handles thrown errors and calls\n     * batchRemoteUpdates.\n     */\n    deliverFromBuffer(message, messageStacks, meta, caller) {\n        for (const messageStack of messageStacks) {\n            this.rootCollab.receive(messageStack, meta);\n        }\n        const crdtMeta = meta.runtimeExtra;\n        this.emit(\"Update\", {\n            update: message,\n            caller,\n            updateType: \"message\",\n            senderID: crdtMeta.senderID,\n            senderCounter: crdtMeta.senderCounter,\n            isLocalOp: false,\n        });\n    }\n    /**\n     * Returns saved state describing the current state of this runtime,\n     * including its Collabs.\n     *\n     * The saved state may later be passed to [[load]]\n     * on a replica of this CRuntime, possibly in a different\n     * collaboration session. That is equivalent to delivering all messages\n     * that this document has already sent or received.\n     */\n    save() {\n        if (this.inTransaction) {\n            throw new Error(\"Cannot call save() during a transaction\");\n        }\n        if (this.inReceiveOrLoad) {\n            throw new Error(\"Cannot call save() during a load/receive call\");\n        }\n        const savedStateTree = this.rootCollab.save();\n        // We know that PublicCObject's save has empty self, so it's okay to overwrite.\n        savedStateTree.self = this.buffer.save();\n        return SavedStateTreeSerializer.instance.serialize(savedStateTree);\n    }\n    /**\n     * Loads saved state. The saved state must be from\n     * a call to [[save]] on a CRuntime that is a replica\n     * of this one (i.e., it has the same\n     * [\"schema\"](https://collabs.readthedocs.io/en/latest/guide/documents.html#using-cruntime)).\n     *\n     * The local Collabs merge in the saved state, change the\n     * local state accordingly, and emit events describing the\n     * local changes.\n     *\n     * Calling load is roughly equivalent to calling [[receive]]\n     * on every message that influenced the saved state\n     * (skipping already-received messages),\n     * but it is typically much more efficient.\n     *\n     * @param savedState Saved state from another replica's [[save]] call.\n     * @param caller Optionally, a value to use as the \"Update\" event's\n     * [[SavedStateEvent.caller]] field.\n     * A caller can use that field to distinguish its own updates from updates\n     * delivered by other sources.\n     */\n    load(savedState, caller) {\n        if (this.inTransaction) {\n            throw new Error(\"Cannot call load() during a transaction\");\n        }\n        if (this.inReceiveOrLoad) {\n            throw new Error(\"Cannot call load() during another receive/load call;\" +\n                \" did you try to load in a Collab's event handler?\");\n        }\n        this.used = true;\n        this.batchRemoteUpdates(() => {\n            this.inReceiveOrLoad = true;\n            try {\n                const savedStateTree = SavedStateTreeSerializer.instance.deserialize(savedState);\n                const loadCRDTMeta = this.buffer.load(nonNull(savedStateTree.self), caller);\n                savedStateTree.self = undefined;\n                const meta = {\n                    updateType: \"savedState\",\n                    runtimeExtra: loadCRDTMeta,\n                    isLocalOp: false,\n                };\n                let isRedundant = true;\n                const vectorClock = new Map();\n                const redundant = new Map();\n                for (const [replicaID, remote] of loadCRDTMeta.remoteVectorClock\n                    .vcEntries) {\n                    vectorClock.set(replicaID, remote);\n                    const local = loadCRDTMeta.localVectorClock.get(replicaID);\n                    // If local > remote (fully redundant), set to remote, so that\n                    // redundant.get(replicaID) == vectorClock.get(replicaID).\n                    redundant.set(replicaID, Math.min(local, remote));\n                    if (local < remote)\n                        isRedundant = false;\n                }\n                if (isRedundant && !this.allowRedundantLoads) {\n                    // The saved state is redundant. Don't load or emit events.\n                    // We did still call buffer.load. This doesn't affect our VC because\n                    // the remote VC was redundant, but it may still have added\n                    // new messages to the buffer. Check if any of these are ready in\n                    // our state, and if so, emit a Change event.\n                    if (this.buffer.check())\n                        this.batchChanged = true;\n                }\n                else {\n                    this.rootCollab.load(savedStateTree, meta);\n                    this.batchChanged = true;\n                    this.emit(\"Update\", {\n                        update: savedState,\n                        caller,\n                        updateType: \"savedState\",\n                        vectorClock,\n                        redundant,\n                        isLocalOp: false,\n                    });\n                    this.buffer.check();\n                }\n            }\n            finally {\n                this.inReceiveOrLoad = false;\n            }\n        });\n    }\n    /**\n     *\n     * The vector clock for our current state, mapping each senderID\n     * to the number of applied transactions from that senderID.\n     *\n     * Our current state includes precisely the transactions\n     * with ID `(senderID, senderCounter)` where\n     * `senderCounter <= (vectorClock.get(senderID) ?? 0)`.\n     */\n    vectorClock() {\n        const vc = new Map(this.buffer.vc);\n        if (vc.get(this.replicaID) === 0)\n            vc.delete(this.replicaID);\n        return vc;\n    }\n}\n//# sourceMappingURL=c_runtime.js.map","import { EventEmitter, } from \"@collabs/core\";\nimport { CRuntime } from \"./c_runtime\";\nconst runtimeEventNames = [\n    \"Change\",\n    \"Update\",\n    \"Send\",\n];\n/**\n * Base class for an encapsulated Collabs document, which wraps\n * its [[CRuntime]] and registered Collabs in a single object.\n *\n * To get started with AbstractDoc, see\n * [Documents - Using AbstractDoc](https://collabs.readthedocs.io/en/latest/guide/documents.html#using-abstractdoc).\n *\n * AbstractDoc is network- and storage-agnostic. By itself, it does not connect\n * to remote collaborators or persistent storage.\n * To easily set up networking and storage, configure\n * [Providers](https://collabs.readthedocs.io/en/latest/guide/providers.html).\n * Or, manually manage updates using the methods in this class; see\n * [Updates and Sync](https://collabs.readthedocs.io/en/latest/advanced/updates.html).\n */\nexport class AbstractDoc extends EventEmitter {\n    /**\n     * Constructs an AbstractDoc.\n     *\n     * @param options See [[DocOptions]].\n     */\n    constructor(options) {\n        super();\n        this.runtime = new CRuntime(options);\n        for (const eventName of runtimeEventNames) {\n            this.runtime.on(eventName, (e) => this.emit(eventName, e));\n        }\n    }\n    /**\n     * Wraps `f`'s operations in a\n     * [transaction](https://collabs.readthedocs.io/en/latest/advanced/updates.html#terminology).\n     *\n     * `f()` is called immediately, then if it performed any local Collab operations,\n     * their transaction is ended (emitting \"Send\", \"Update\", and \"Change\" events).\n     *\n     * Notes:\n     * - Operations not wrapped in a `transact` call use the constructor's\n     * [[DocOptions.autoTransactions]] option.\n     * - If there are nested `transact` calls (possibly due to\n     * DocOptions.autoTransactions), only the outermost one matters.\n     *\n     * See also: [[batchRemoteUpdates]], a similar method for remote updates.\n     */\n    transact(f) {\n        this.runtime.transact(f);\n    }\n    /**\n     * Delivers remotes updates (receive/load calls) in a *batch*,\n     * so that only a single \"Change\" event is emitted for the entire batch.\n     *\n     * `f()` is called immediately, then if it delivered any remote updates,\n     * a single \"Change\" event is emitted.\n     * That way, \"Change\" listeners know that they only need\n     * to refresh the display once at the end, instead of once per receive/load\n     * call.\n     *\n     * Notes:\n     * - Each delivered update still emits its own \"Update\" event immediately,\n     * as usual.\n     * - If there are nested batchRemoteUpdates calls, only the outermost\n     * one matters.\n     *\n     * See also: [[transact]], a similar method for local operations.\n     *\n     * @param f A callback that delivers the remote updates by calling\n     * [[receive]]/[[load]].\n     */\n    batchRemoteUpdates(f) {\n        this.runtime.batchRemoteUpdates(f);\n    }\n    /**\n     * Receives a message from another replica's [[DocEventsRecord.Send]] event.\n     * The message's sender must be an AbstractDoc that is a\n     * replica of this one (i.e., it has the same\n     * [\"schema\"](https://collabs.readthedocs.io/en/latest/guide/documents.html#using-cruntime)).\n     *\n     * The local Collabs process the message, change the\n     * local state accordingly, and emit events describing the\n     * local changes.\n     *\n     * Messages from other replicas should be received eventually and at-least-once. Arbitrary delays, duplicates,\n     * reordering, and delivery of (redundant) messages from this replica\n     * are acceptable. Two replicas will be in the same\n     * state once they have the same set of received (or sent) messages.\n     *\n     * @param caller Optionally, a value to use as the \"Update\" event's\n     * [[MessageEvent.caller]] field.\n     * A caller can use that field to distinguish its own updates from updates\n     * delivered by other sources.\n     */\n    receive(message, caller) {\n        this.runtime.receive(message, caller);\n    }\n    /**\n     * Returns saved state describing the current state of this document.\n     *\n     * The saved state may later be passed to [[load]]\n     * on a replica of this AbstractDoc, possibly in a different\n     * collaboration session. That is equivalent to delivering all messages\n     * that this document has already sent or received.\n     */\n    save() {\n        return this.runtime.save();\n    }\n    /**\n     * Loads saved state. The saved state must be from\n     * a call to [[save]] on an AbstractDoc that is a replica\n     * of this one (i.e., it has the same\n     * [\"schema\"](https://collabs.readthedocs.io/en/latest/guide/documents.html#using-cruntime)).\n     *\n     * The local Collabs merge in the saved state, change the\n     * local state accordingly, and emit events describing the\n     * local changes.\n     *\n     * Calling load is roughly equivalent to calling [[receive]]\n     * on every message that influenced the saved state\n     * (skipping already-received messages),\n     * but it is typically much more efficient.\n     *\n     * @param savedState Saved state from another replica's [[save]] call.\n     * @param caller Optionally, a value to use as the \"Update\" event's\n     * [[SavedStateEvent.caller]] field.\n     * A caller can use that field to distinguish its own updates from updates\n     * delivered by other sources.\n     */\n    load(savedState, caller) {\n        this.runtime.load(savedState, caller);\n    }\n    /**\n     * Returns a [[CollabID]] for the given Collab.\n     *\n     * The CollabID may be passed to [[fromID]] on any replica of this\n     * AbstractDoc to obtain that replica's copy of `collab`.\n     *\n     * @param collab A Collab that belongs to this AbstractDoc.\n     */\n    idOf(collab) {\n        if (collab.runtime !== this.runtime) {\n            throw new Error(\"idOf called with Collab from different AbstractDoc\");\n        }\n        return this.runtime.idOf(collab);\n    }\n    /**\n     * Inverse of [[idOf]].\n     *\n     * Specifically, given a [[CollabID]] returned by [[idOf]] on some replica of\n     * this AbstractDoc, returns this replica's copy of the original\n     * `collab`. If that Collab does not exist (e.g., it was deleted\n     * or it is not present in this program version), returns undefined.\n     *\n     * @param id A CollabID from [[idOf]].\n     */\n    fromID(id) {\n        return this.runtime.fromID(id);\n    }\n    /**\n     * An ID that uniquely identifies this replica among\n     * all connected replicas.\n     *\n     * See [[CRuntime.replicaID]].\n     */\n    get replicaID() {\n        return this.runtime.replicaID;\n    }\n    /**\n     *\n     * The vector clock for our current state, mapping each senderID\n     * to the number of applied transactions from that senderID.\n     *\n     * Our current state includes precisely the transactions\n     * with ID `(senderID, senderCounter)` where\n     * `senderCounter <= (vectorClock.get(senderID) ?? 0)`.\n     */\n    vectorClock() {\n        return this.runtime.vectorClock();\n    }\n}\n//# sourceMappingURL=abstract_doc.js.map","import { MessageSerializer } from \"./message_serializer\";\n/**\n * **Experimental** - message format is unstable.\n *\n * Merges the given messages, returning a single message that incorporates\n * all of their transactions. This message may be passed to\n * [[AbstractDoc.receive]]/[[CRuntime.receive]] as usual.\n *\n * @param messages The messages to merge. These must come from either\n * [[DocEventsRecord.Send]] events or previous `mergeMessages` calls.\n * @throws If `messages.length` is 0.\n */\nexport function mergeMessages(messages) {\n    if (messages.length === 0) {\n        throw new Error(\"messages.length is 0\");\n    }\n    if (messages.length === 1)\n        return messages[0];\n    const originals = [];\n    for (const message of messages) {\n        originals.push(...MessageSerializer.instance.deserialize(message));\n    }\n    return MessageSerializer.instance.serialize(originals);\n}\n//# sourceMappingURL=merge_messages.js.map","import { ReplicaIDs, nonNull } from \"@collabs/core\";\nimport { CRuntime } from \"../runtime\";\n/**\n * Creates a collection of [[CRuntime]]s linked together\n * (in-memory networking) that delivers messages\n * when [[release]] is called.\n *\n * This is useful for tests, including tests with concurrent operations.\n */\nexport class TestingRuntimes {\n    constructor() {\n        /**\n         * Maps sender and recipient to an array of queued messages.\n         */\n        this.messageQueues = new Map();\n        /**\n         * Maps sender to the number of bytes they have sent.\n         */\n        this.sentBytes = new Map();\n        /**\n         * Maps sender to the number of bytes they have received.\n         */\n        this.receivedBytes = new Map();\n        /**\n         * The last sent message, if any.\n         *\n         * This is sometimes convenient to access during benchmarks.\n         */\n        this.lastMessage = undefined;\n    }\n    /**\n     * Returns a new [[CRuntime]] linked with all prior\n     * runtimes created by this TestingRuntime.\n     *\n     * @param options.rng A PRNG used to deterministically set the replicaID\n     * (via [[ReplicaIDs.pseudoRandom]]).\n     * @param options.causalityGuaranteed See [[DocOptions.causalityGuaranteed]].\n     * @param options.skipRedundantLoads Opposite of [[DocOptions.allowRedundantLoads]].\n     * This defaults to false, so that redundant loads are allowed by default, opposite to\n     * CRuntime's default; that way you can test your load functions' idempotence.\n     */\n    newRuntime(options = {}) {\n        const debugReplicaID = options.rng\n            ? ReplicaIDs.pseudoRandom(options.rng)\n            : undefined;\n        const runtime = new CRuntime({\n            autoTransactions: \"debugOp\",\n            debugReplicaID,\n            causalityGuaranteed: options.causalityGuaranteed,\n            allowRedundantLoads: !(options.skipRedundantLoads ?? false),\n        });\n        const appQueue = new Map();\n        for (const [oldApp, oldAppQueue] of this.messageQueues) {\n            appQueue.set(oldApp, []);\n            oldAppQueue.set(runtime, []);\n        }\n        this.messageQueues.set(runtime, appQueue);\n        this.sentBytes.set(runtime, 0);\n        this.receivedBytes.set(runtime, 0);\n        runtime.on(\"Send\", (e) => {\n            this.sentBytes.set(runtime, nonNull(this.sentBytes.get(runtime)) + e.message.byteLength);\n            for (const queue of appQueue.values()) {\n                queue.push(e.message);\n            }\n            this.lastMessage = e.message;\n        });\n        return runtime;\n    }\n    /**\n     * Releases all queued messages from sender to the specified recipients.\n     * If recipients are not specified, releases them to all\n     * recipients.\n     *\n     * Only recipients that existed at the time\n     * of sending will receive a message.\n     */\n    release(sender, ...recipients) {\n        if (recipients.length === 0)\n            recipients = [...this.messageQueues.keys()];\n        const senderMap = nonNull(this.messageQueues.get(sender));\n        for (const recipient of recipients) {\n            if (recipient === sender)\n                continue;\n            for (const queued of nonNull(senderMap.get(recipient))) {\n                this.receivedBytes.set(recipient, nonNull(this.receivedBytes.get(recipient)) + queued.byteLength);\n                recipient.receive(queued);\n            }\n            senderMap.set(recipient, []);\n        }\n    }\n    /**\n     * Release all queued messages.\n     *\n     * Only recipients that existed at the time\n     * of sending will receive a message.\n     */\n    releaseAll() {\n        for (const sender of this.messageQueues.keys())\n            this.release(sender);\n    }\n    /**\n     * Returns the total number of bytes in messages\n     * sent by all runtimes.\n     */\n    getTotalSentBytes() {\n        let ret = 0;\n        for (const value of this.sentBytes.values())\n            ret += value;\n        return ret;\n    }\n}\n//# sourceMappingURL=testing_runtimes.js.map","import { EventEmitter, } from \"@collabs/collabs\";\nimport { nonNull } from \"@collabs/core\";\n/** How many updates before we consider a checkpoint. */\nconst updatesBeforeCheckpoint = 100;\n/** The minimum time between checkpoints. */\nconst checkpointInterval = 10000;\nconst objectStoreName = \"updates\";\n/**\n * Stores updates to Collabs documents in IndexeddDB.\n *\n * To load existing state into a document (if any) and store future updates\n * to that document, call [[subscribe]]. You will need to supply a `docID`\n * that identifies which stored state to use.\n *\n * This class is designed to work seamlessly with other sources of updates,\n * such as [@collabs/ws-client](https://www.npmjs.com/package/@collabs/ws-client).\n * In particular, updates from those sources will be stored alongside local\n * operations.\n * - Exception: Updates from other tabs via\n * [@collabs/tab-sync](https://www.npmjs.com/package/@collabs/tab-sync) are not\n * saved, since the source tab should save them.\n *\n * See also: [@collabs/local-storage](https://www.npmjs.com/package/@collabs/local-storage),\n * which stores updates in localStorage instead of IndexedDB.\n */\nexport class IndexedDBDocStore extends EventEmitter {\n    /**\n     * Constructs an IndexedDBDocStore.\n     *\n     * You typically only need one IndexedDBDocStore per app, since it\n     * can [[subscribe]] multiple documents.\n     *\n     * @param options.dbName The name of the database to use.\n     * Default: \"@collabs/indexeddb\".\n     */\n    constructor(options = {}) {\n        var _a;\n        super();\n        this.db = null;\n        this.subs = new Map();\n        this.docsByID = new Map();\n        this.closed = false;\n        this.onError = (err) => {\n            this.emit(\"Error\", { err });\n        };\n        this.onUpdate = (e, doc) => {\n            // Skip updates that we delivered.\n            if (e.caller === this)\n                return;\n            // Skip updates delivered by other tabs; they should be storing\n            // their own updates themselves.\n            if (typeof e.caller === \"object\" &&\n                e.caller.isTabSyncNetwork === true)\n                return;\n            const info = this.subs.get(doc);\n            if (info === undefined)\n                return;\n            if (e.updateType === \"message\") {\n                if (info.currentUpdates.size >= updatesBeforeCheckpoint &&\n                    Date.now() >= info.lastCheckpointTime + checkpointInterval) {\n                    // Time for a checkpoint.\n                    // Do it in a separate task because we are on the critical path\n                    // for local ops.\n                    setTimeout(() => void this.checkpoint(doc, info), 0);\n                }\n                else {\n                    // Append the message to the log.\n                    void this.appendMessage(doc, info, e.update);\n                }\n            }\n            else {\n                // Since savedState updates are usually rare and large, do a\n                // checkpoint instead of storing it.\n                // Do it in a separate task because we are on the critical path\n                // for local ops.\n                setTimeout(() => void this.checkpoint(doc, info), 0);\n            }\n        };\n        this.dbName = (_a = options.dbName) !== null && _a !== void 0 ? _a : \"@collabs/indexeddb\";\n        this.dbPromise = new Promise((resolve, reject) => {\n            const openRequest = indexedDB.open(this.dbName, 1);\n            openRequest.onupgradeneeded = () => {\n                const db = openRequest.result;\n                const objectStore = db.createObjectStore(objectStoreName, {\n                    autoIncrement: true,\n                });\n                objectStore.createIndex(\"docID\", \"docID\", { unique: false });\n            };\n            openRequest.onsuccess = () => {\n                this.db = openRequest.result;\n                this.db.onerror = this.onError;\n                resolve(openRequest.result);\n            };\n            openRequest.onerror = (event) => {\n                this.onError(event);\n                reject(event);\n            };\n        });\n    }\n    /**\n     * Waits for tr to finish, returning whether it succeeded.\n     *\n     * Errors are suppressed (not thrown) since they are already reported to this.onError.\n     */\n    trFinish(tr) {\n        return new Promise((resolve) => {\n            tr.oncomplete = () => resolve(true);\n            tr.onabort = () => resolve(false);\n            tr.onerror = () => resolve(false);\n        });\n    }\n    // Implicit (not documented): works well with other tabs, but won't\n    // actively load their stored states - only checks at time of subscribe.\n    // Also, multiple tabs will duplicate checkpoints, increasing IndexedDB usage.\n    /**\n     * Subscribes `doc` to updates stored under `docID`.\n     *\n     * All existing updates under `docID` will be loaded into `doc`\n     * asynchronously, emitting a \"Load\" event when finished (including\n     * if there are no existing updates).\n     *\n     * Also, all new updates to `doc` will be saved under `docID`,\n     * emitting a \"Save\" event whenever the IndexedDB state becomes up-to-date with `doc`.\n     * This includes both local operations and updates from other sources.\n     *\n     * @param doc The document to subscribe.\n     * @param docID An arbitrary string that identifies which stored state to use.\n     * @throws If `doc` is already subscribed to a docID.\n     * @throws If another doc is subscribed to `docID`.\n     */\n    subscribe(doc, docID) {\n        if (this.closed)\n            throw new Error(\"Already closed\");\n        if (this.subs.has(doc)) {\n            throw new Error(\"doc is already subscribed to a docID\");\n        }\n        if (this.docsByID.has(docID)) {\n            throw new Error(\"Unsupported: multiple docs with same docID\");\n        }\n        // Store subscription info.\n        const info = {\n            docID,\n            currentUpdates: new Set(),\n            lastCheckpointTime: 0,\n        };\n        this.subs.set(doc, info);\n        this.docsByID.set(docID, doc);\n        // Load existing state into the doc and subscribe to future\n        // updates, asynchronously.\n        void this.subscribeAsync(doc, docID, info);\n    }\n    async subscribeAsync(doc, docID, info) {\n        let db;\n        try {\n            db = await this.dbPromise;\n        }\n        catch (err) {\n            // The error is already sent to onError; no need to send it again\n            // or let the unhandled error spam the console.\n            return;\n        }\n        // Skip if we've been unsubscribed already.\n        if (info.unsubscribed)\n            return;\n        // 1. Read existing state from IndexedDB.\n        const savedStates = [];\n        const messages = [];\n        {\n            const tr = db.transaction([objectStoreName], \"readonly\");\n            const objectStore = tr.objectStore(objectStoreName);\n            const request = objectStore.index(\"docID\").openCursor(docID);\n            request.onsuccess = () => {\n                const cursor = request.result;\n                if (!cursor)\n                    return;\n                const value = cursor.value;\n                if (typeof value === \"object\") {\n                    if (value.savedState !== undefined) {\n                        savedStates.push(value.savedState);\n                        info.currentUpdates.add(cursor.primaryKey);\n                    }\n                    if (value.message !== undefined) {\n                        messages.push(value.message);\n                        info.currentUpdates.add(cursor.primaryKey);\n                    }\n                } // Else ignore (wrong type).\n                cursor.continue();\n            };\n            if (!(await this.trFinish(tr)))\n                return;\n        }\n        if (info.unsubscribed)\n            return;\n        // 3. Load the updates into doc.\n        doc.batchRemoteUpdates(() => {\n            // Load saved states first, to reduce causal buffering of updates.\n            for (const savedState of savedStates) {\n                doc.load(savedState, this);\n            }\n            for (const message of messages) {\n                doc.receive(message, this);\n            }\n        });\n        this.emit(\"Load\", { doc, docID });\n        // Do the next part's save() in a separate task to avoid blocking\n        // for too long.\n        await new Promise((resolve) => setTimeout(resolve, 0));\n        if (info.unsubscribed)\n            return;\n        // 3. Just before calling doc.save() (in checkpoint), add a listener for\n        // future updates to the doc - local or received from other sources.\n        info.off = doc.on(\"Update\", this.onUpdate);\n        // 4. Save the loaded state as a checkpoint.\n        // That will also deleted the loaded keys (info.currentUpdates).\n        await this.checkpoint(doc, info);\n    }\n    /**\n     * Unsubscribes `doc` from its subscribed `docID` (if any).\n     *\n     * Further updates to `doc` will not be saved.\n     */\n    unsubscribe(doc) {\n        const info = this.subs.get(doc);\n        if (info === undefined)\n            return;\n        info.unsubscribed = true;\n        this.subs.delete(doc);\n        this.docsByID.delete(info.docID);\n        if (info.off !== undefined)\n            info.off();\n    }\n    async appendMessage(doc, info, message) {\n        // We only register onUpdate after using db, so we don't need to\n        // await this.dbPromise.\n        const db = nonNull(this.db);\n        const tr = db.transaction([objectStoreName], \"readwrite\");\n        const objectStore = tr.objectStore(objectStoreName);\n        const request = objectStore.add({ docID: info.docID, message });\n        if (await this.trFinish(tr)) {\n            // Add the update's primary key to currentUpdates.\n            info.currentUpdates.add(request.result);\n            this.emit(\"Save\", { doc, docID: info.docID });\n        }\n    }\n    async checkpoint(doc, info) {\n        if (info.unsubscribed)\n            return;\n        // We only call checkpoint after using db, so we don't need to\n        // await this.dbPromise.\n        const db = nonNull(this.db);\n        const tr = db.transaction([objectStoreName], \"readwrite\");\n        const objectStore = tr.objectStore(objectStoreName);\n        // The updates definitely included in the following doc.save() call.\n        const includedUpdates = [...info.currentUpdates];\n        const addRequest = objectStore.add({\n            docID: info.docID,\n            savedState: doc.save(),\n        });\n        // Delete includedUpdates, which have been incorporated into our new checkpoint.\n        // Since we do this in the save tr as addRequest, we don't\n        // have to worry about accidentally deleting these but failing to\n        // set the checkpoint.\n        for (const key of includedUpdates) {\n            objectStore.delete(key);\n        }\n        if (await this.trFinish(tr)) {\n            // In case of concurrent addUpdate/checkpoint calls, only delete the keys\n            // we definitely included, instead of resetting currentUpdates entirely.\n            for (const key of includedUpdates)\n                info.currentUpdates.delete(key);\n            // Add the new checkpoint's primary key.\n            info.currentUpdates.add(addRequest.result);\n            info.lastCheckpointTime = Date.now();\n            this.emit(\"Save\", { doc, docID: info.docID });\n        }\n    }\n    /**\n     * Closes our IndexedDB database connection and unsubscribes all documents.\n     *\n     * Future method calls will throw an error.\n     */\n    close() {\n        if (this.closed)\n            return;\n        this.closed = true;\n        // Unsubscribe all docs.\n        for (const doc of this.subs.keys())\n            this.unsubscribe(doc);\n        // Close our DB connection.\n        void (async () => {\n            try {\n                const db = await this.dbPromise;\n                db.close();\n            }\n            catch (err) {\n                // The error is already sent to onError; no need to send it again\n                // or let the unhandled error spam the console.\n                return;\n            }\n        })();\n    }\n    /**\n     * Deletes `docID` from localStorage.\n     */\n    async delete(docID) {\n        if (this.closed)\n            throw new Error(\"Already closed\");\n        const db = await this.dbPromise;\n        const tr = db.transaction([objectStoreName], \"readwrite\");\n        const objectStore = tr.objectStore(objectStoreName);\n        // Delete all values with the given docID.\n        const request = objectStore.index(\"docID\").openKeyCursor(docID);\n        await new Promise((resolve, reject) => {\n            request.onsuccess = () => {\n                const cursor = request.result;\n                if (!cursor) {\n                    resolve();\n                    return;\n                }\n                objectStore.delete(cursor.primaryKey);\n                cursor.continue();\n            };\n            request.onerror = reject;\n        });\n        if (!(await this.trFinish(tr))) {\n            // Throw the error here in addition to the Error event.\n            throw nonNull(tr.error);\n        }\n    }\n    /**\n     * Deletes all documents in our database.\n     */\n    async clear() {\n        if (this.closed)\n            throw new Error(\"Already closed\");\n        const db = await this.dbPromise;\n        const tr = db.transaction([objectStoreName], \"readwrite\");\n        const objectStore = tr.objectStore(objectStoreName);\n        objectStore.clear();\n        if (!(await this.trFinish(tr))) {\n            // Throw the error here in addition to the Error event.\n            throw nonNull(tr.error);\n        }\n    }\n    /**\n     * Returns all `docID`s with state stored in our database.\n     */\n    async docIDs() {\n        if (this.closed)\n            throw new Error(\"Already closed\");\n        const db = await this.dbPromise;\n        const tr = db.transaction([objectStoreName], \"readonly\");\n        const objectStore = tr.objectStore(objectStoreName);\n        const results = new Set();\n        const request = objectStore\n            .index(\"docID\")\n            .openKeyCursor(null, \"nextunique\");\n        await new Promise((resolve, reject) => {\n            request.onsuccess = () => {\n                const cursor = request.result;\n                if (!cursor) {\n                    resolve();\n                    return;\n                }\n                // cursor.key is the *index* key (= docID), not the primary key.\n                results.add(cursor.key);\n                cursor.continue();\n            };\n            request.onerror = reject;\n        });\n        if (!(await this.trFinish(tr))) {\n            // Throw the error here in addition to the Error event.\n            throw nonNull(tr.error);\n        }\n        return results;\n    }\n}\n//# sourceMappingURL=indexed_db_doc_store.js.map","import { EventEmitter, } from \"@collabs/collabs\";\nimport { fromByteArray, toByteArray } from \"base64-js\";\n/** How many updates before we consider a checkpoint. */\nconst updatesBeforeCheckpoint = 50;\n/** The minimum time between checkpoints. */\nconst checkpointInterval = 5000;\nfunction setBytes(key, value) {\n    window.localStorage.setItem(key, fromByteArray(value));\n}\nfunction getBytes(key) {\n    const value = window.localStorage.getItem(key);\n    if (value === null)\n        return null;\n    return toByteArray(value);\n}\n/**\n * Returns an \"escaped\" version of str with no \".\"s.\n */\nfunction escapeDots(str) {\n    // \".\" -> \"\\d\"; to make this reversible, also replace existing\n    // \"\\\" with \"\\\\\".\n    return str.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\./g, \"\\\\d\");\n}\n/**\n * Inverse of escapeDots.\n */\nfunction unescapeDots(str) {\n    // \"\\d\" -> \".\", \"\\\\\" -> \"\\\"\n    let ans = \"\";\n    for (let i = 0; i < str.length; i++) {\n        if (str[i] === \"\\\\\") {\n            switch (str[i + 1]) {\n                case \"\\\\\":\n                    ans += \"\\\\\";\n                    i++;\n                    break;\n                case \"d\":\n                    ans += \".\";\n                    i++;\n                    break;\n                default:\n                    // Bad string.\n                    return null;\n            }\n        }\n        else\n            ans += str[i];\n    }\n    return ans;\n}\n/**\n * Stores updates to Collabs documents in localStorage.\n *\n * To load existing state into a document (if any) and store future updates\n * to that document, call [[subscribe]]. You will need to supply a `docID`\n * that identifies which stored state to use.\n *\n * This class is designed to work seamlessly with other sources of updates,\n * such as [@collabs/ws-client](https://www.npmjs.com/package/@collabs/ws-client).\n * In particular, updates from those sources will be stored alongside local\n * operations.\n * - Exception: Updates from other tabs via\n * [@collabs/tab-sync](https://www.npmjs.com/package/@collabs/tab-sync) are not\n * saved, since the source tab should save them.\n *\n * Warning: This class is subject to localStorage's small storage quotas.\n * Also, some methods (including [[subscribe]]) loop over all localStorage keys,\n * which may be slow.\n *\n * See also: [@collabs/indexeddb](https://www.npmjs.com/package/@collabs/indexeddb),\n * which stores updates in IndexedDB instead of localStorage.\n */\nexport class LocalStorageDocStore extends EventEmitter {\n    /**\n     * Constructs a LocalStorageDocStore.\n     *\n     * You typically only need one LocalStorageDocStore per app, since it\n     * can [[subscribe]] multiple documents.\n     *\n     * @param options.keyPrefix The prefix to use for all of this\n     * class's localStorage keys. Default: \"@collabs/local-storage\".\n     */\n    constructor(options = {}) {\n        var _a;\n        super();\n        this.subs = new Map();\n        this.docsByID = new Map();\n        this.closed = false;\n        this.onUpdate = (e, doc) => {\n            // Skip updates that we delivered.\n            if (e.caller === this)\n                return;\n            // Skip updates delivered by other tabs; they should be storing\n            // their own updates themselves.\n            if (typeof e.caller === \"object\" &&\n                e.caller.isTabSyncNetwork === true)\n                return;\n            const info = this.subs.get(doc);\n            if (info === undefined)\n                return;\n            if (e.updateType === \"message\") {\n                if (info.currentUpdates.length >= updatesBeforeCheckpoint &&\n                    Date.now() >= info.lastCheckpointTime + checkpointInterval) {\n                    // Time for a checkpoint.\n                    // Do it in a separate task because we are on the critical path\n                    // for local ops.\n                    setTimeout(() => this.checkpoint(doc, info), 0);\n                }\n                else {\n                    // Append the message to the log.\n                    const trID = escapeDots(`${e.senderCounter},${e.senderID}`);\n                    const key = info.docPrefix + \".message\" + trID;\n                    try {\n                        setBytes(key, e.update);\n                    }\n                    catch (err) {\n                        this.emit(\"Error\", { err });\n                        return;\n                    }\n                    info.currentUpdates.push(key);\n                    this.emit(\"Save\", { doc, docID: info.docID });\n                }\n            }\n            else {\n                // Since savedState updates are usually rare and large, do a\n                // checkpoint instead of storing it.\n                // Do it in a separate task because we are on the critical path\n                // for local ops.\n                setTimeout(() => this.checkpoint(doc, info), 0);\n            }\n        };\n        this.keyPrefix = (_a = options.keyPrefix) !== null && _a !== void 0 ? _a : \"@collabs/local-storage\";\n        this.keyPrefixDot = this.keyPrefix + \".\";\n    }\n    /** docPrefix: \"<keyPrefix>.<docID>\" */\n    getDocPrefix(docID) {\n        return this.keyPrefix + \".\" + escapeDots(docID);\n    }\n    /** ourPrefix: \"<keyPrefix>.<docID>.<replicaID>\" */\n    getOurPrefix(docID, doc) {\n        return this.getDocPrefix(docID) + \".\" + escapeDots(doc.replicaID);\n    }\n    // Implicit (not documented): works well with other tabs, but won't\n    // actively load their stored states - only checks at time of subscribe.\n    // Also, multiple tabs will duplicate checkpoints, increasing localStorage usage.\n    /**\n     * Subscribes `doc` to updates stored under `docID`.\n     *\n     * All existing updates under `docID` will be loaded into `doc`\n     * asynchronously, emitting a \"Load\" event when finished (including\n     * if there are no existing updates).\n     *\n     * Also, all new updates to `doc` will be saved under `docID`,\n     * emitting a \"Save\" event whenever the localStorage state becomes up-to-date with `doc`.\n     * This includes both local operations and updates from other sources.\n     *\n     * @param doc The document to subscribe.\n     * @param docID An arbitrary string that identifies which stored state to use.\n     * @throws If `doc` is already subscribed to a docID.\n     * @throws If another doc is subscribed to `docID`.\n     */\n    subscribe(doc, docID) {\n        if (this.closed)\n            throw new Error(\"Already closed\");\n        if (this.subs.has(doc)) {\n            throw new Error(\"doc is already subscribed to a docID\");\n        }\n        if (this.docsByID.has(docID)) {\n            throw new Error(\"Unsupported: multiple docs with same docID\");\n        }\n        const docPrefix = this.getDocPrefix(docID);\n        const docPrefixDot = docPrefix + \".\";\n        const ourPrefix = this.getOurPrefix(docID, doc);\n        // 1. Store subscription info.\n        const info = {\n            docID,\n            docPrefix,\n            ourPrefix,\n            saveCounter: 0,\n            currentUpdates: [],\n            lastCheckpointTime: 0,\n        };\n        this.subs.set(doc, info);\n        this.docsByID.set(docID, doc);\n        // 2. Read existing state from localStorage.\n        // Do this (& especially step 3) in a separate task to match\n        // other doc stores' behaviors:\n        // - Subscribe returns quickly.\n        // - Update listeners added later in the same task see our updates.\n        setTimeout(() => {\n            // Skip if we've been unsubscribed already.\n            if (info.unsubscribed)\n                return;\n            const savedStates = [];\n            const messages = [];\n            for (let i = 0; i < window.localStorage.length; i++) {\n                const key = window.localStorage.key(i);\n                if (key !== null && key.startsWith(docPrefixDot)) {\n                    let lastDot = key.lastIndexOf(\".\");\n                    const suffix = key.slice(lastDot + 1);\n                    try {\n                        if (suffix.startsWith(\"savedState\")) {\n                            const savedState = getBytes(key);\n                            if (savedState !== null) {\n                                savedStates.push(savedState);\n                                info.currentUpdates.push(key);\n                            }\n                        }\n                        else if (suffix.startsWith(\"message\")) {\n                            const message = getBytes(key);\n                            if (message !== null) {\n                                messages.push(message);\n                                info.currentUpdates.push(key);\n                            }\n                        }\n                    }\n                    catch (err) {\n                        // Problem with this value - e.g. not base64 formatted.\n                        // Emit error and continue.\n                        this.emit(\"Error\", { err });\n                    }\n                }\n            }\n            // 3. Load the updates into doc.\n            doc.batchRemoteUpdates(() => {\n                // Load saved states first, to reduce causal buffering of updates.\n                for (const savedState of savedStates) {\n                    doc.load(savedState, this);\n                }\n                for (const message of messages) {\n                    doc.receive(message, this);\n                }\n            });\n            this.emit(\"Load\", { doc, docID });\n            // Do the next part's save() in a separate task to avoid blocking\n            // for too long.\n            setTimeout(() => {\n                // Skip if we've been unsubscribed already.\n                if (info.unsubscribed)\n                    return;\n                // 3. Just before calling doc.save() (in checkpoint), add a listener for\n                // future updates to the doc - local or received from other sources.\n                info.off = doc.on(\"Update\", this.onUpdate);\n                // 4. Save the loaded state as a checkpoint.\n                // That will also deleted the loaded keys (info.currentUpdates).\n                this.checkpoint(doc, info);\n            });\n        }, 0);\n    }\n    /**\n     * Unsubscribes `doc` from its subscribed `docID` (if any).\n     *\n     * Further updates to `doc` will not be saved.\n     */\n    unsubscribe(doc) {\n        const info = this.subs.get(doc);\n        if (info === undefined)\n            return;\n        info.unsubscribed = true;\n        this.subs.delete(doc);\n        this.docsByID.delete(info.docID);\n        if (info.off !== undefined)\n            info.off();\n    }\n    checkpoint(doc, info) {\n        if (info.unsubscribed)\n            return;\n        const checkpointKey = info.ourPrefix + \".savedState\" + info.saveCounter;\n        const savedState = doc.save();\n        try {\n            setBytes(checkpointKey, savedState);\n        }\n        catch (err) {\n            this.emit(\"Error\", { err });\n            return;\n        }\n        // Delete currentUpdates, which have been incorporated into our new checkpoint.\n        // Note: setting the savedState before deleting the old one effectively\n        // doubles our max memory usage.\n        // But the alternative could lose data in a crash.\n        for (const key of info.currentUpdates) {\n            localStorage.removeItem(key);\n        }\n        info.saveCounter++;\n        info.currentUpdates = [checkpointKey];\n        info.lastCheckpointTime = Date.now();\n        this.emit(\"Save\", { doc, docID: info.docID });\n    }\n    /**\n     * Unsubscribes all documents.\n     *\n     * Future [[subscribe]] calls will throw an error.\n     */\n    close() {\n        if (this.closed)\n            return;\n        this.closed = true;\n        // Unsubscribe all docs.\n        for (const doc of this.subs.keys())\n            this.unsubscribe(doc);\n    }\n    /**\n     * Deletes `docID` from localStorage.\n     */\n    delete(docID) {\n        // localStorage doesn't like concurrent iter/delete, so wait\n        // to delete until the end.\n        const toDelete = [];\n        const docPrefixDot = this.getDocPrefix(docID) + \".\";\n        for (let i = 0; i < window.localStorage.length; i++) {\n            const key = window.localStorage.key(i);\n            if (key !== null && key.startsWith(docPrefixDot)) {\n                toDelete.push(key);\n            }\n        }\n        for (const key of toDelete)\n            window.localStorage.removeItem(key);\n    }\n    /**\n     * Deletes all documents under [[keyPrefix]] from localStorage.\n     */\n    clear() {\n        // localStorage doesn't like concurrent iter/delete, so wait\n        // to delete until the end.\n        const toDelete = [];\n        for (let i = 0; i < window.localStorage.length; i++) {\n            const key = window.localStorage.key(i);\n            if (key !== null && key.startsWith(this.keyPrefixDot)) {\n                toDelete.push(key);\n            }\n        }\n        for (const key of toDelete)\n            window.localStorage.removeItem(key);\n    }\n    /**\n     * Returns all `docID`s that have state stored under our [[keyPrefix]].\n     */\n    docIDs() {\n        const docIDs = new Set();\n        for (let i = 0; i < window.localStorage.length; i++) {\n            const key = window.localStorage.key(i);\n            if (key !== null && key.startsWith(this.keyPrefixDot)) {\n                const suffix = key.slice(this.keyPrefixDot.length);\n                const nextDot = suffix.indexOf(\".\");\n                if (nextDot === -1)\n                    continue;\n                const escapedDocID = suffix.slice(0, nextDot);\n                const docID = unescapeDots(escapedDocID);\n                if (docID !== null)\n                    docIDs.add(docID);\n            }\n        }\n        return docIDs;\n    }\n}\n//# sourceMappingURL=local_storage_doc_store.js.map","import { ReplicaIDs } from \"@collabs/collabs\";\nimport { EventEmitter, nonNull } from \"@collabs/core\";\n/**\n * Syncs updates to Collabs documents across different tabs for the same origin,\n * using BroadcastChannel.\n *\n * By default, this only forwards *local* operations to other tabs. Updates from other sources (e.g., a remote server via\n * [@collabs/ws-client](https://www.npmjs.com/package/@collabs/ws-client))\n * are not sent over the BroadcastChannel, since we expect that other tabs will\n * get a copy from their own sources. You can override this with the `allUpdates`\n * constructor option.\n *\n * Likewise, our other providers do not forward or store\n * operations from TabSyncNetwork. Instead, it is expected that\n * each tab sets up its own providers to forward/store updates.\n */\nexport class TabSyncNetwork extends EventEmitter {\n    /**\n     * Constructs a TabSyncNetwork.\n     *\n     * You typically only need one TabSyncNetwork per app, since it\n     * can [[subscribe]] multiple documents.\n     *\n     * @param options.bcName The name of the BroadcastChannel to use.\n     * Default: \"@collabs/tab-sync\".\n     * @param options.allUpdates Set to true to forward all doc updates over\n     * the BroadcastChannel, not just local operations.\n     */\n    constructor(options = {}) {\n        var _a, _b;\n        super();\n        this.subs = new Map();\n        /** Inverse map docID -> Doc. */\n        this.docsByID = new Map();\n        this.closed = false;\n        this.isTabSyncNetwork = true;\n        this.bcName = (_a = options.bcName) !== null && _a !== void 0 ? _a : \"@collabs/tab-sync\";\n        this.allUpdates = (_b = options.allUpdates) !== null && _b !== void 0 ? _b : false;\n        this.objID = ReplicaIDs.random();\n        this.bc = new BroadcastChannel(this.bcName);\n        this.bc.addEventListener(\"message\", (e) => this.bcReceive(e.data));\n        this.bc.addEventListener(\"messageerror\", (e) => this.emit(\"Error\", { err: e }));\n    }\n    sendInternal(message) {\n        this.bc.postMessage(message);\n    }\n    /**\n     * Subscribes `doc` to updates for `docID`.\n     *\n     * `doc` will send and receive updates with other tabs\n     * that are subscribed to `docID`. It will also sync initial states with\n     * other tabs, to ensure that they start up-to-date.\n     *\n     * @param doc The document to subscribe.\n     * @param docID An arbitrary string that identifies which updates to use.\n     * @throws If `doc` is already subscribed to a docID.\n     * @throws If another doc is subscribed to `docID`.\n     */\n    subscribe(doc, docID) {\n        if (this.closed)\n            throw new Error(\"Already closed\");\n        if (this.subs.has(doc)) {\n            throw new Error(\"doc is already subscribed to a docID\");\n        }\n        if (this.docsByID.has(docID)) {\n            throw new Error(\"Unsupported: multiple docs with same docID\");\n        }\n        const info = { docID };\n        this.subs.set(doc, info);\n        this.docsByID.set(docID, doc);\n        // Call save() in a separate task, to match other networks\n        // (in particular, they don't block for long during subscribe()).\n        setTimeout(() => {\n            if (info.unsubscribed)\n                return;\n            // Broadcast our current state.\n            // We will get a reply from each other peer with their current\n            // state, bringing us up-to-date.\n            this.sendInternal({\n                type: \"join\",\n                senderID: this.objID,\n                docID,\n                savedState: doc.save(),\n            });\n            // Subscribe to future updates.\n            info.off = doc.on(\"Update\", (e) => {\n                // Skip updates that we delivered.\n                if (e.caller === this)\n                    return;\n                // Skip non-local updates unless allUpdates is true.\n                if (!(this.allUpdates || e.isLocalOp))\n                    return;\n                this.sendInternal({\n                    type: \"update\",\n                    docID,\n                    updateType: e.updateType,\n                    update: e.update,\n                });\n            });\n            // Note: the above pattern (initial state-based sync followed by\n            // update forwarding) is a good strategy for peer-to-peer\n            // networks in general.\n        }, 0);\n    }\n    /**\n     * Unsubscribes `doc` from its subscribed `docID` (if any).\n     *\n     * `doc` will no longer send or receive updates with other tabs.\n     */\n    unsubscribe(doc) {\n        const info = this.subs.get(doc);\n        if (info === undefined)\n            return;\n        info.unsubscribed = true;\n        this.subs.delete(doc);\n        this.docsByID.delete(info.docID);\n        if (info.off !== undefined)\n            info.off();\n    }\n    bcReceive(message) {\n        const doc = this.docsByID.get(message.docID);\n        if (doc === undefined)\n            return;\n        const info = nonNull(this.subs.get(doc));\n        switch (message.type) {\n            case \"join\":\n                // Reply with our state.\n                // OPT: use a delta on top of the peer's state instead.\n                this.sendInternal({\n                    type: \"joinReply\",\n                    targetID: message.senderID,\n                    docID: message.docID,\n                    savedState: doc.save(),\n                });\n                // Merge the new peer's state into ours.\n                // Do it in a separate task to avoid blocking for too long.\n                setTimeout(() => {\n                    if (info.unsubscribed)\n                        return;\n                    doc.load(message.savedState, this);\n                });\n                break;\n            case \"joinReply\":\n                if (message.targetID !== this.objID)\n                    return;\n                // Merge the peer's state into ours.\n                doc.load(message.savedState, this);\n                break;\n            case \"update\":\n                // Apply the update.\n                switch (message.updateType) {\n                    case \"message\":\n                        doc.receive(message.update, this);\n                        break;\n                    case \"savedState\":\n                        doc.load(message.update, this);\n                        break;\n                    default:\n                        this.emit(\"Error\", {\n                            err: `Unrecognized message.updateType ${message.updateType} on ${message}`,\n                        });\n                }\n                break;\n            default:\n                this.emit(\"Error\", {\n                    err: `Unrecognized message.type ${message.type} on ${message}`,\n                });\n        }\n    }\n    /**\n     * Closes our BroadcastChannel and unsubscribes all documents.\n     *\n     * Future [[subscribe]] calls will throw an error.\n     */\n    close() {\n        if (this.closed)\n            return;\n        this.closed = true;\n        // Unsubscribe all docs.\n        for (const doc of this.subs.keys())\n            this.unsubscribe(doc);\n        // Close our BroadcastChannel.\n        this.bc.close();\n    }\n}\n//# sourceMappingURL=tab_sync_network.js.map","/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\nimport * as $protobuf from \"protobufjs/minimal\";\n\n// Common aliases\nconst $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n// Exported root namespace\nconst $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\nexport const Subscribe = $root.Subscribe = (() => {\n\n    /**\n     * Properties of a Subscribe.\n     * @exports ISubscribe\n     * @interface ISubscribe\n     * @property {Array.<string>|null} [docIDs] Subscribe docIDs\n     */\n\n    /**\n     * Constructs a new Subscribe.\n     * @exports Subscribe\n     * @classdesc Represents a Subscribe.\n     * @implements ISubscribe\n     * @constructor\n     * @param {ISubscribe=} [properties] Properties to set\n     */\n    function Subscribe(properties) {\n        this.docIDs = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * Subscribe docIDs.\n     * @member {Array.<string>} docIDs\n     * @memberof Subscribe\n     * @instance\n     */\n    Subscribe.prototype.docIDs = $util.emptyArray;\n\n    /**\n     * Creates a new Subscribe instance using the specified properties.\n     * @function create\n     * @memberof Subscribe\n     * @static\n     * @param {ISubscribe=} [properties] Properties to set\n     * @returns {Subscribe} Subscribe instance\n     */\n    Subscribe.create = function create(properties) {\n        return new Subscribe(properties);\n    };\n\n    /**\n     * Encodes the specified Subscribe message. Does not implicitly {@link Subscribe.verify|verify} messages.\n     * @function encode\n     * @memberof Subscribe\n     * @static\n     * @param {ISubscribe} message Subscribe message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Subscribe.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.docIDs != null && message.docIDs.length)\n            for (let i = 0; i < message.docIDs.length; ++i)\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.docIDs[i]);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified Subscribe message, length delimited. Does not implicitly {@link Subscribe.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Subscribe\n     * @static\n     * @param {ISubscribe} message Subscribe message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Subscribe.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a Subscribe message from the specified reader or buffer.\n     * @function decode\n     * @memberof Subscribe\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Subscribe} Subscribe\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Subscribe.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Subscribe();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                if (!(message.docIDs && message.docIDs.length))\n                    message.docIDs = [];\n                message.docIDs.push(reader.string());\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a Subscribe message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Subscribe\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Subscribe} Subscribe\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Subscribe.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a Subscribe message.\n     * @function verify\n     * @memberof Subscribe\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    Subscribe.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.docIDs != null && message.hasOwnProperty(\"docIDs\")) {\n            if (!Array.isArray(message.docIDs))\n                return \"docIDs: array expected\";\n            for (let i = 0; i < message.docIDs.length; ++i)\n                if (!$util.isString(message.docIDs[i]))\n                    return \"docIDs: string[] expected\";\n        }\n        return null;\n    };\n\n    /**\n     * Creates a Subscribe message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Subscribe\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {Subscribe} Subscribe\n     */\n    Subscribe.fromObject = function fromObject(object) {\n        if (object instanceof $root.Subscribe)\n            return object;\n        let message = new $root.Subscribe();\n        if (object.docIDs) {\n            if (!Array.isArray(object.docIDs))\n                throw TypeError(\".Subscribe.docIDs: array expected\");\n            message.docIDs = [];\n            for (let i = 0; i < object.docIDs.length; ++i)\n                message.docIDs[i] = String(object.docIDs[i]);\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a Subscribe message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Subscribe\n     * @static\n     * @param {Subscribe} message Subscribe\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Subscribe.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults)\n            object.docIDs = [];\n        if (message.docIDs && message.docIDs.length) {\n            object.docIDs = [];\n            for (let j = 0; j < message.docIDs.length; ++j)\n                object.docIDs[j] = message.docIDs[j];\n        }\n        return object;\n    };\n\n    /**\n     * Converts this Subscribe to JSON.\n     * @function toJSON\n     * @memberof Subscribe\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Subscribe.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return Subscribe;\n})();\n\nexport const Unsubscribe = $root.Unsubscribe = (() => {\n\n    /**\n     * Properties of an Unsubscribe.\n     * @exports IUnsubscribe\n     * @interface IUnsubscribe\n     * @property {string} docID Unsubscribe docID\n     */\n\n    /**\n     * Constructs a new Unsubscribe.\n     * @exports Unsubscribe\n     * @classdesc Represents an Unsubscribe.\n     * @implements IUnsubscribe\n     * @constructor\n     * @param {IUnsubscribe=} [properties] Properties to set\n     */\n    function Unsubscribe(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * Unsubscribe docID.\n     * @member {string} docID\n     * @memberof Unsubscribe\n     * @instance\n     */\n    Unsubscribe.prototype.docID = \"\";\n\n    /**\n     * Creates a new Unsubscribe instance using the specified properties.\n     * @function create\n     * @memberof Unsubscribe\n     * @static\n     * @param {IUnsubscribe=} [properties] Properties to set\n     * @returns {Unsubscribe} Unsubscribe instance\n     */\n    Unsubscribe.create = function create(properties) {\n        return new Unsubscribe(properties);\n    };\n\n    /**\n     * Encodes the specified Unsubscribe message. Does not implicitly {@link Unsubscribe.verify|verify} messages.\n     * @function encode\n     * @memberof Unsubscribe\n     * @static\n     * @param {IUnsubscribe} message Unsubscribe message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Unsubscribe.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        writer.uint32(/* id 1, wireType 2 =*/10).string(message.docID);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified Unsubscribe message, length delimited. Does not implicitly {@link Unsubscribe.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Unsubscribe\n     * @static\n     * @param {IUnsubscribe} message Unsubscribe message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Unsubscribe.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes an Unsubscribe message from the specified reader or buffer.\n     * @function decode\n     * @memberof Unsubscribe\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Unsubscribe} Unsubscribe\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Unsubscribe.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Unsubscribe();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.docID = reader.string();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        if (!message.hasOwnProperty(\"docID\"))\n            throw $util.ProtocolError(\"missing required 'docID'\", { instance: message });\n        return message;\n    };\n\n    /**\n     * Decodes an Unsubscribe message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Unsubscribe\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Unsubscribe} Unsubscribe\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Unsubscribe.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies an Unsubscribe message.\n     * @function verify\n     * @memberof Unsubscribe\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    Unsubscribe.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (!$util.isString(message.docID))\n            return \"docID: string expected\";\n        return null;\n    };\n\n    /**\n     * Creates an Unsubscribe message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Unsubscribe\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {Unsubscribe} Unsubscribe\n     */\n    Unsubscribe.fromObject = function fromObject(object) {\n        if (object instanceof $root.Unsubscribe)\n            return object;\n        let message = new $root.Unsubscribe();\n        if (object.docID != null)\n            message.docID = String(object.docID);\n        return message;\n    };\n\n    /**\n     * Creates a plain object from an Unsubscribe message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Unsubscribe\n     * @static\n     * @param {Unsubscribe} message Unsubscribe\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Unsubscribe.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.defaults)\n            object.docID = \"\";\n        if (message.docID != null && message.hasOwnProperty(\"docID\"))\n            object.docID = message.docID;\n        return object;\n    };\n\n    /**\n     * Converts this Unsubscribe to JSON.\n     * @function toJSON\n     * @memberof Unsubscribe\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Unsubscribe.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return Unsubscribe;\n})();\n\nexport const Welcome = $root.Welcome = (() => {\n\n    /**\n     * Properties of a Welcome.\n     * @exports IWelcome\n     * @interface IWelcome\n     * @property {string} docID Welcome docID\n     * @property {Uint8Array|null} [savedState] Welcome savedState\n     * @property {Array.<Uint8Array>|null} [updates] Welcome updates\n     * @property {Array.<number>|null} [updateTypes] Welcome updateTypes\n     */\n\n    /**\n     * Constructs a new Welcome.\n     * @exports Welcome\n     * @classdesc Represents a Welcome.\n     * @implements IWelcome\n     * @constructor\n     * @param {IWelcome=} [properties] Properties to set\n     */\n    function Welcome(properties) {\n        this.updates = [];\n        this.updateTypes = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * Welcome docID.\n     * @member {string} docID\n     * @memberof Welcome\n     * @instance\n     */\n    Welcome.prototype.docID = \"\";\n\n    /**\n     * Welcome savedState.\n     * @member {Uint8Array} savedState\n     * @memberof Welcome\n     * @instance\n     */\n    Welcome.prototype.savedState = $util.newBuffer([]);\n\n    /**\n     * Welcome updates.\n     * @member {Array.<Uint8Array>} updates\n     * @memberof Welcome\n     * @instance\n     */\n    Welcome.prototype.updates = $util.emptyArray;\n\n    /**\n     * Welcome updateTypes.\n     * @member {Array.<number>} updateTypes\n     * @memberof Welcome\n     * @instance\n     */\n    Welcome.prototype.updateTypes = $util.emptyArray;\n\n    /**\n     * Creates a new Welcome instance using the specified properties.\n     * @function create\n     * @memberof Welcome\n     * @static\n     * @param {IWelcome=} [properties] Properties to set\n     * @returns {Welcome} Welcome instance\n     */\n    Welcome.create = function create(properties) {\n        return new Welcome(properties);\n    };\n\n    /**\n     * Encodes the specified Welcome message. Does not implicitly {@link Welcome.verify|verify} messages.\n     * @function encode\n     * @memberof Welcome\n     * @static\n     * @param {IWelcome} message Welcome message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Welcome.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        writer.uint32(/* id 1, wireType 2 =*/10).string(message.docID);\n        if (message.savedState != null && Object.hasOwnProperty.call(message, \"savedState\"))\n            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.savedState);\n        if (message.updates != null && message.updates.length)\n            for (let i = 0; i < message.updates.length; ++i)\n                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.updates[i]);\n        if (message.updateTypes != null && message.updateTypes.length) {\n            writer.uint32(/* id 4, wireType 2 =*/34).fork();\n            for (let i = 0; i < message.updateTypes.length; ++i)\n                writer.uint32(message.updateTypes[i]);\n            writer.ldelim();\n        }\n        return writer;\n    };\n\n    /**\n     * Encodes the specified Welcome message, length delimited. Does not implicitly {@link Welcome.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Welcome\n     * @static\n     * @param {IWelcome} message Welcome message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Welcome.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a Welcome message from the specified reader or buffer.\n     * @function decode\n     * @memberof Welcome\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Welcome} Welcome\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Welcome.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Welcome();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.docID = reader.string();\n                break;\n            case 2:\n                message.savedState = reader.bytes();\n                break;\n            case 3:\n                if (!(message.updates && message.updates.length))\n                    message.updates = [];\n                message.updates.push(reader.bytes());\n                break;\n            case 4:\n                if (!(message.updateTypes && message.updateTypes.length))\n                    message.updateTypes = [];\n                if ((tag & 7) === 2) {\n                    let end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.updateTypes.push(reader.uint32());\n                } else\n                    message.updateTypes.push(reader.uint32());\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        if (!message.hasOwnProperty(\"docID\"))\n            throw $util.ProtocolError(\"missing required 'docID'\", { instance: message });\n        return message;\n    };\n\n    /**\n     * Decodes a Welcome message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Welcome\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Welcome} Welcome\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Welcome.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a Welcome message.\n     * @function verify\n     * @memberof Welcome\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    Welcome.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (!$util.isString(message.docID))\n            return \"docID: string expected\";\n        if (message.savedState != null && message.hasOwnProperty(\"savedState\"))\n            if (!(message.savedState && typeof message.savedState.length === \"number\" || $util.isString(message.savedState)))\n                return \"savedState: buffer expected\";\n        if (message.updates != null && message.hasOwnProperty(\"updates\")) {\n            if (!Array.isArray(message.updates))\n                return \"updates: array expected\";\n            for (let i = 0; i < message.updates.length; ++i)\n                if (!(message.updates[i] && typeof message.updates[i].length === \"number\" || $util.isString(message.updates[i])))\n                    return \"updates: buffer[] expected\";\n        }\n        if (message.updateTypes != null && message.hasOwnProperty(\"updateTypes\")) {\n            if (!Array.isArray(message.updateTypes))\n                return \"updateTypes: array expected\";\n            for (let i = 0; i < message.updateTypes.length; ++i)\n                if (!$util.isInteger(message.updateTypes[i]))\n                    return \"updateTypes: integer[] expected\";\n        }\n        return null;\n    };\n\n    /**\n     * Creates a Welcome message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Welcome\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {Welcome} Welcome\n     */\n    Welcome.fromObject = function fromObject(object) {\n        if (object instanceof $root.Welcome)\n            return object;\n        let message = new $root.Welcome();\n        if (object.docID != null)\n            message.docID = String(object.docID);\n        if (object.savedState != null)\n            if (typeof object.savedState === \"string\")\n                $util.base64.decode(object.savedState, message.savedState = $util.newBuffer($util.base64.length(object.savedState)), 0);\n            else if (object.savedState.length)\n                message.savedState = object.savedState;\n        if (object.updates) {\n            if (!Array.isArray(object.updates))\n                throw TypeError(\".Welcome.updates: array expected\");\n            message.updates = [];\n            for (let i = 0; i < object.updates.length; ++i)\n                if (typeof object.updates[i] === \"string\")\n                    $util.base64.decode(object.updates[i], message.updates[i] = $util.newBuffer($util.base64.length(object.updates[i])), 0);\n                else if (object.updates[i].length)\n                    message.updates[i] = object.updates[i];\n        }\n        if (object.updateTypes) {\n            if (!Array.isArray(object.updateTypes))\n                throw TypeError(\".Welcome.updateTypes: array expected\");\n            message.updateTypes = [];\n            for (let i = 0; i < object.updateTypes.length; ++i)\n                message.updateTypes[i] = object.updateTypes[i] >>> 0;\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a Welcome message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Welcome\n     * @static\n     * @param {Welcome} message Welcome\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Welcome.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults) {\n            object.updates = [];\n            object.updateTypes = [];\n        }\n        if (options.defaults) {\n            object.docID = \"\";\n            if (options.bytes === String)\n                object.savedState = \"\";\n            else {\n                object.savedState = [];\n                if (options.bytes !== Array)\n                    object.savedState = $util.newBuffer(object.savedState);\n            }\n        }\n        if (message.docID != null && message.hasOwnProperty(\"docID\"))\n            object.docID = message.docID;\n        if (message.savedState != null && message.hasOwnProperty(\"savedState\"))\n            object.savedState = options.bytes === String ? $util.base64.encode(message.savedState, 0, message.savedState.length) : options.bytes === Array ? Array.prototype.slice.call(message.savedState) : message.savedState;\n        if (message.updates && message.updates.length) {\n            object.updates = [];\n            for (let j = 0; j < message.updates.length; ++j)\n                object.updates[j] = options.bytes === String ? $util.base64.encode(message.updates[j], 0, message.updates[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.updates[j]) : message.updates[j];\n        }\n        if (message.updateTypes && message.updateTypes.length) {\n            object.updateTypes = [];\n            for (let j = 0; j < message.updateTypes.length; ++j)\n                object.updateTypes[j] = message.updateTypes[j];\n        }\n        return object;\n    };\n\n    /**\n     * Converts this Welcome to JSON.\n     * @function toJSON\n     * @memberof Welcome\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Welcome.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return Welcome;\n})();\n\nexport const SubscribeDenied = $root.SubscribeDenied = (() => {\n\n    /**\n     * Properties of a SubscribeDenied.\n     * @exports ISubscribeDenied\n     * @interface ISubscribeDenied\n     * @property {string} docID SubscribeDenied docID\n     */\n\n    /**\n     * Constructs a new SubscribeDenied.\n     * @exports SubscribeDenied\n     * @classdesc Represents a SubscribeDenied.\n     * @implements ISubscribeDenied\n     * @constructor\n     * @param {ISubscribeDenied=} [properties] Properties to set\n     */\n    function SubscribeDenied(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * SubscribeDenied docID.\n     * @member {string} docID\n     * @memberof SubscribeDenied\n     * @instance\n     */\n    SubscribeDenied.prototype.docID = \"\";\n\n    /**\n     * Creates a new SubscribeDenied instance using the specified properties.\n     * @function create\n     * @memberof SubscribeDenied\n     * @static\n     * @param {ISubscribeDenied=} [properties] Properties to set\n     * @returns {SubscribeDenied} SubscribeDenied instance\n     */\n    SubscribeDenied.create = function create(properties) {\n        return new SubscribeDenied(properties);\n    };\n\n    /**\n     * Encodes the specified SubscribeDenied message. Does not implicitly {@link SubscribeDenied.verify|verify} messages.\n     * @function encode\n     * @memberof SubscribeDenied\n     * @static\n     * @param {ISubscribeDenied} message SubscribeDenied message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    SubscribeDenied.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        writer.uint32(/* id 1, wireType 2 =*/10).string(message.docID);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified SubscribeDenied message, length delimited. Does not implicitly {@link SubscribeDenied.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof SubscribeDenied\n     * @static\n     * @param {ISubscribeDenied} message SubscribeDenied message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    SubscribeDenied.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a SubscribeDenied message from the specified reader or buffer.\n     * @function decode\n     * @memberof SubscribeDenied\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {SubscribeDenied} SubscribeDenied\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    SubscribeDenied.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SubscribeDenied();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.docID = reader.string();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        if (!message.hasOwnProperty(\"docID\"))\n            throw $util.ProtocolError(\"missing required 'docID'\", { instance: message });\n        return message;\n    };\n\n    /**\n     * Decodes a SubscribeDenied message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof SubscribeDenied\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {SubscribeDenied} SubscribeDenied\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    SubscribeDenied.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a SubscribeDenied message.\n     * @function verify\n     * @memberof SubscribeDenied\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    SubscribeDenied.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (!$util.isString(message.docID))\n            return \"docID: string expected\";\n        return null;\n    };\n\n    /**\n     * Creates a SubscribeDenied message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof SubscribeDenied\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {SubscribeDenied} SubscribeDenied\n     */\n    SubscribeDenied.fromObject = function fromObject(object) {\n        if (object instanceof $root.SubscribeDenied)\n            return object;\n        let message = new $root.SubscribeDenied();\n        if (object.docID != null)\n            message.docID = String(object.docID);\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a SubscribeDenied message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof SubscribeDenied\n     * @static\n     * @param {SubscribeDenied} message SubscribeDenied\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    SubscribeDenied.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.defaults)\n            object.docID = \"\";\n        if (message.docID != null && message.hasOwnProperty(\"docID\"))\n            object.docID = message.docID;\n        return object;\n    };\n\n    /**\n     * Converts this SubscribeDenied to JSON.\n     * @function toJSON\n     * @memberof SubscribeDenied\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    SubscribeDenied.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return SubscribeDenied;\n})();\n\nexport const Send = $root.Send = (() => {\n\n    /**\n     * Properties of a Send.\n     * @exports ISend\n     * @interface ISend\n     * @property {string} docID Send docID\n     * @property {Uint8Array} update Send update\n     * @property {number} updateType UpdateType enum.\n     * @property {number} localCounter Send localCounter\n     */\n\n    /**\n     * Constructs a new Send.\n     * @exports Send\n     * @classdesc Represents a Send.\n     * @implements ISend\n     * @constructor\n     * @param {ISend=} [properties] Properties to set\n     */\n    function Send(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * Send docID.\n     * @member {string} docID\n     * @memberof Send\n     * @instance\n     */\n    Send.prototype.docID = \"\";\n\n    /**\n     * Send update.\n     * @member {Uint8Array} update\n     * @memberof Send\n     * @instance\n     */\n    Send.prototype.update = $util.newBuffer([]);\n\n    /**\n     * UpdateType enum.\n     * @member {number} updateType\n     * @memberof Send\n     * @instance\n     */\n    Send.prototype.updateType = 0;\n\n    /**\n     * Send localCounter.\n     * @member {number} localCounter\n     * @memberof Send\n     * @instance\n     */\n    Send.prototype.localCounter = 0;\n\n    /**\n     * Creates a new Send instance using the specified properties.\n     * @function create\n     * @memberof Send\n     * @static\n     * @param {ISend=} [properties] Properties to set\n     * @returns {Send} Send instance\n     */\n    Send.create = function create(properties) {\n        return new Send(properties);\n    };\n\n    /**\n     * Encodes the specified Send message. Does not implicitly {@link Send.verify|verify} messages.\n     * @function encode\n     * @memberof Send\n     * @static\n     * @param {ISend} message Send message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Send.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        writer.uint32(/* id 1, wireType 2 =*/10).string(message.docID);\n        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.update);\n        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.updateType);\n        writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.localCounter);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified Send message, length delimited. Does not implicitly {@link Send.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Send\n     * @static\n     * @param {ISend} message Send message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Send.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a Send message from the specified reader or buffer.\n     * @function decode\n     * @memberof Send\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Send} Send\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Send.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Send();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.docID = reader.string();\n                break;\n            case 2:\n                message.update = reader.bytes();\n                break;\n            case 3:\n                message.updateType = reader.uint32();\n                break;\n            case 4:\n                message.localCounter = reader.uint32();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        if (!message.hasOwnProperty(\"docID\"))\n            throw $util.ProtocolError(\"missing required 'docID'\", { instance: message });\n        if (!message.hasOwnProperty(\"update\"))\n            throw $util.ProtocolError(\"missing required 'update'\", { instance: message });\n        if (!message.hasOwnProperty(\"updateType\"))\n            throw $util.ProtocolError(\"missing required 'updateType'\", { instance: message });\n        if (!message.hasOwnProperty(\"localCounter\"))\n            throw $util.ProtocolError(\"missing required 'localCounter'\", { instance: message });\n        return message;\n    };\n\n    /**\n     * Decodes a Send message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Send\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Send} Send\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Send.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a Send message.\n     * @function verify\n     * @memberof Send\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    Send.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (!$util.isString(message.docID))\n            return \"docID: string expected\";\n        if (!(message.update && typeof message.update.length === \"number\" || $util.isString(message.update)))\n            return \"update: buffer expected\";\n        if (!$util.isInteger(message.updateType))\n            return \"updateType: integer expected\";\n        if (!$util.isInteger(message.localCounter))\n            return \"localCounter: integer expected\";\n        return null;\n    };\n\n    /**\n     * Creates a Send message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Send\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {Send} Send\n     */\n    Send.fromObject = function fromObject(object) {\n        if (object instanceof $root.Send)\n            return object;\n        let message = new $root.Send();\n        if (object.docID != null)\n            message.docID = String(object.docID);\n        if (object.update != null)\n            if (typeof object.update === \"string\")\n                $util.base64.decode(object.update, message.update = $util.newBuffer($util.base64.length(object.update)), 0);\n            else if (object.update.length)\n                message.update = object.update;\n        if (object.updateType != null)\n            message.updateType = object.updateType >>> 0;\n        if (object.localCounter != null)\n            message.localCounter = object.localCounter >>> 0;\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a Send message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Send\n     * @static\n     * @param {Send} message Send\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Send.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.defaults) {\n            object.docID = \"\";\n            if (options.bytes === String)\n                object.update = \"\";\n            else {\n                object.update = [];\n                if (options.bytes !== Array)\n                    object.update = $util.newBuffer(object.update);\n            }\n            object.updateType = 0;\n            object.localCounter = 0;\n        }\n        if (message.docID != null && message.hasOwnProperty(\"docID\"))\n            object.docID = message.docID;\n        if (message.update != null && message.hasOwnProperty(\"update\"))\n            object.update = options.bytes === String ? $util.base64.encode(message.update, 0, message.update.length) : options.bytes === Array ? Array.prototype.slice.call(message.update) : message.update;\n        if (message.updateType != null && message.hasOwnProperty(\"updateType\"))\n            object.updateType = message.updateType;\n        if (message.localCounter != null && message.hasOwnProperty(\"localCounter\"))\n            object.localCounter = message.localCounter;\n        return object;\n    };\n\n    /**\n     * Converts this Send to JSON.\n     * @function toJSON\n     * @memberof Send\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Send.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return Send;\n})();\n\nexport const Receive = $root.Receive = (() => {\n\n    /**\n     * Properties of a Receive.\n     * @exports IReceive\n     * @interface IReceive\n     * @property {string} docID Receive docID\n     * @property {Uint8Array} update Receive update\n     * @property {number} updateType UpdateType enum.\n     */\n\n    /**\n     * Constructs a new Receive.\n     * @exports Receive\n     * @classdesc Represents a Receive.\n     * @implements IReceive\n     * @constructor\n     * @param {IReceive=} [properties] Properties to set\n     */\n    function Receive(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * Receive docID.\n     * @member {string} docID\n     * @memberof Receive\n     * @instance\n     */\n    Receive.prototype.docID = \"\";\n\n    /**\n     * Receive update.\n     * @member {Uint8Array} update\n     * @memberof Receive\n     * @instance\n     */\n    Receive.prototype.update = $util.newBuffer([]);\n\n    /**\n     * UpdateType enum.\n     * @member {number} updateType\n     * @memberof Receive\n     * @instance\n     */\n    Receive.prototype.updateType = 0;\n\n    /**\n     * Creates a new Receive instance using the specified properties.\n     * @function create\n     * @memberof Receive\n     * @static\n     * @param {IReceive=} [properties] Properties to set\n     * @returns {Receive} Receive instance\n     */\n    Receive.create = function create(properties) {\n        return new Receive(properties);\n    };\n\n    /**\n     * Encodes the specified Receive message. Does not implicitly {@link Receive.verify|verify} messages.\n     * @function encode\n     * @memberof Receive\n     * @static\n     * @param {IReceive} message Receive message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Receive.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        writer.uint32(/* id 1, wireType 2 =*/10).string(message.docID);\n        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.update);\n        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.updateType);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified Receive message, length delimited. Does not implicitly {@link Receive.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Receive\n     * @static\n     * @param {IReceive} message Receive message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Receive.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a Receive message from the specified reader or buffer.\n     * @function decode\n     * @memberof Receive\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Receive} Receive\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Receive.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Receive();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.docID = reader.string();\n                break;\n            case 2:\n                message.update = reader.bytes();\n                break;\n            case 3:\n                message.updateType = reader.uint32();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        if (!message.hasOwnProperty(\"docID\"))\n            throw $util.ProtocolError(\"missing required 'docID'\", { instance: message });\n        if (!message.hasOwnProperty(\"update\"))\n            throw $util.ProtocolError(\"missing required 'update'\", { instance: message });\n        if (!message.hasOwnProperty(\"updateType\"))\n            throw $util.ProtocolError(\"missing required 'updateType'\", { instance: message });\n        return message;\n    };\n\n    /**\n     * Decodes a Receive message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Receive\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Receive} Receive\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Receive.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a Receive message.\n     * @function verify\n     * @memberof Receive\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    Receive.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (!$util.isString(message.docID))\n            return \"docID: string expected\";\n        if (!(message.update && typeof message.update.length === \"number\" || $util.isString(message.update)))\n            return \"update: buffer expected\";\n        if (!$util.isInteger(message.updateType))\n            return \"updateType: integer expected\";\n        return null;\n    };\n\n    /**\n     * Creates a Receive message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Receive\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {Receive} Receive\n     */\n    Receive.fromObject = function fromObject(object) {\n        if (object instanceof $root.Receive)\n            return object;\n        let message = new $root.Receive();\n        if (object.docID != null)\n            message.docID = String(object.docID);\n        if (object.update != null)\n            if (typeof object.update === \"string\")\n                $util.base64.decode(object.update, message.update = $util.newBuffer($util.base64.length(object.update)), 0);\n            else if (object.update.length)\n                message.update = object.update;\n        if (object.updateType != null)\n            message.updateType = object.updateType >>> 0;\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a Receive message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Receive\n     * @static\n     * @param {Receive} message Receive\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Receive.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.defaults) {\n            object.docID = \"\";\n            if (options.bytes === String)\n                object.update = \"\";\n            else {\n                object.update = [];\n                if (options.bytes !== Array)\n                    object.update = $util.newBuffer(object.update);\n            }\n            object.updateType = 0;\n        }\n        if (message.docID != null && message.hasOwnProperty(\"docID\"))\n            object.docID = message.docID;\n        if (message.update != null && message.hasOwnProperty(\"update\"))\n            object.update = options.bytes === String ? $util.base64.encode(message.update, 0, message.update.length) : options.bytes === Array ? Array.prototype.slice.call(message.update) : message.update;\n        if (message.updateType != null && message.hasOwnProperty(\"updateType\"))\n            object.updateType = message.updateType;\n        return object;\n    };\n\n    /**\n     * Converts this Receive to JSON.\n     * @function toJSON\n     * @memberof Receive\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Receive.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return Receive;\n})();\n\nexport const Ack = $root.Ack = (() => {\n\n    /**\n     * Properties of an Ack.\n     * @exports IAck\n     * @interface IAck\n     * @property {string} docID Ack docID\n     * @property {number} localCounter Ack localCounter\n     * @property {string|null} [checkpointRequest] Ack checkpointRequest\n     */\n\n    /**\n     * Constructs a new Ack.\n     * @exports Ack\n     * @classdesc Represents an Ack.\n     * @implements IAck\n     * @constructor\n     * @param {IAck=} [properties] Properties to set\n     */\n    function Ack(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * Ack docID.\n     * @member {string} docID\n     * @memberof Ack\n     * @instance\n     */\n    Ack.prototype.docID = \"\";\n\n    /**\n     * Ack localCounter.\n     * @member {number} localCounter\n     * @memberof Ack\n     * @instance\n     */\n    Ack.prototype.localCounter = 0;\n\n    /**\n     * Ack checkpointRequest.\n     * @member {string} checkpointRequest\n     * @memberof Ack\n     * @instance\n     */\n    Ack.prototype.checkpointRequest = \"\";\n\n    /**\n     * Creates a new Ack instance using the specified properties.\n     * @function create\n     * @memberof Ack\n     * @static\n     * @param {IAck=} [properties] Properties to set\n     * @returns {Ack} Ack instance\n     */\n    Ack.create = function create(properties) {\n        return new Ack(properties);\n    };\n\n    /**\n     * Encodes the specified Ack message. Does not implicitly {@link Ack.verify|verify} messages.\n     * @function encode\n     * @memberof Ack\n     * @static\n     * @param {IAck} message Ack message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Ack.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        writer.uint32(/* id 1, wireType 2 =*/10).string(message.docID);\n        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.localCounter);\n        if (message.checkpointRequest != null && Object.hasOwnProperty.call(message, \"checkpointRequest\"))\n            writer.uint32(/* id 3, wireType 2 =*/26).string(message.checkpointRequest);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified Ack message, length delimited. Does not implicitly {@link Ack.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Ack\n     * @static\n     * @param {IAck} message Ack message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Ack.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes an Ack message from the specified reader or buffer.\n     * @function decode\n     * @memberof Ack\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Ack} Ack\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Ack.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ack();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.docID = reader.string();\n                break;\n            case 2:\n                message.localCounter = reader.uint32();\n                break;\n            case 3:\n                message.checkpointRequest = reader.string();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        if (!message.hasOwnProperty(\"docID\"))\n            throw $util.ProtocolError(\"missing required 'docID'\", { instance: message });\n        if (!message.hasOwnProperty(\"localCounter\"))\n            throw $util.ProtocolError(\"missing required 'localCounter'\", { instance: message });\n        return message;\n    };\n\n    /**\n     * Decodes an Ack message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Ack\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Ack} Ack\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Ack.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies an Ack message.\n     * @function verify\n     * @memberof Ack\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    Ack.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (!$util.isString(message.docID))\n            return \"docID: string expected\";\n        if (!$util.isInteger(message.localCounter))\n            return \"localCounter: integer expected\";\n        if (message.checkpointRequest != null && message.hasOwnProperty(\"checkpointRequest\"))\n            if (!$util.isString(message.checkpointRequest))\n                return \"checkpointRequest: string expected\";\n        return null;\n    };\n\n    /**\n     * Creates an Ack message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Ack\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {Ack} Ack\n     */\n    Ack.fromObject = function fromObject(object) {\n        if (object instanceof $root.Ack)\n            return object;\n        let message = new $root.Ack();\n        if (object.docID != null)\n            message.docID = String(object.docID);\n        if (object.localCounter != null)\n            message.localCounter = object.localCounter >>> 0;\n        if (object.checkpointRequest != null)\n            message.checkpointRequest = String(object.checkpointRequest);\n        return message;\n    };\n\n    /**\n     * Creates a plain object from an Ack message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Ack\n     * @static\n     * @param {Ack} message Ack\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Ack.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.defaults) {\n            object.docID = \"\";\n            object.localCounter = 0;\n            object.checkpointRequest = \"\";\n        }\n        if (message.docID != null && message.hasOwnProperty(\"docID\"))\n            object.docID = message.docID;\n        if (message.localCounter != null && message.hasOwnProperty(\"localCounter\"))\n            object.localCounter = message.localCounter;\n        if (message.checkpointRequest != null && message.hasOwnProperty(\"checkpointRequest\"))\n            object.checkpointRequest = message.checkpointRequest;\n        return object;\n    };\n\n    /**\n     * Converts this Ack to JSON.\n     * @function toJSON\n     * @memberof Ack\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Ack.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return Ack;\n})();\n\nexport const CheckpointResponse = $root.CheckpointResponse = (() => {\n\n    /**\n     * Properties of a CheckpointResponse.\n     * @exports ICheckpointResponse\n     * @interface ICheckpointResponse\n     * @property {string} docID CheckpointResponse docID\n     * @property {Uint8Array} savedState CheckpointResponse savedState\n     * @property {string} checkpointRequest CheckpointResponse checkpointRequest\n     */\n\n    /**\n     * Constructs a new CheckpointResponse.\n     * @exports CheckpointResponse\n     * @classdesc Represents a CheckpointResponse.\n     * @implements ICheckpointResponse\n     * @constructor\n     * @param {ICheckpointResponse=} [properties] Properties to set\n     */\n    function CheckpointResponse(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * CheckpointResponse docID.\n     * @member {string} docID\n     * @memberof CheckpointResponse\n     * @instance\n     */\n    CheckpointResponse.prototype.docID = \"\";\n\n    /**\n     * CheckpointResponse savedState.\n     * @member {Uint8Array} savedState\n     * @memberof CheckpointResponse\n     * @instance\n     */\n    CheckpointResponse.prototype.savedState = $util.newBuffer([]);\n\n    /**\n     * CheckpointResponse checkpointRequest.\n     * @member {string} checkpointRequest\n     * @memberof CheckpointResponse\n     * @instance\n     */\n    CheckpointResponse.prototype.checkpointRequest = \"\";\n\n    /**\n     * Creates a new CheckpointResponse instance using the specified properties.\n     * @function create\n     * @memberof CheckpointResponse\n     * @static\n     * @param {ICheckpointResponse=} [properties] Properties to set\n     * @returns {CheckpointResponse} CheckpointResponse instance\n     */\n    CheckpointResponse.create = function create(properties) {\n        return new CheckpointResponse(properties);\n    };\n\n    /**\n     * Encodes the specified CheckpointResponse message. Does not implicitly {@link CheckpointResponse.verify|verify} messages.\n     * @function encode\n     * @memberof CheckpointResponse\n     * @static\n     * @param {ICheckpointResponse} message CheckpointResponse message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    CheckpointResponse.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        writer.uint32(/* id 1, wireType 2 =*/10).string(message.docID);\n        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.savedState);\n        writer.uint32(/* id 3, wireType 2 =*/26).string(message.checkpointRequest);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified CheckpointResponse message, length delimited. Does not implicitly {@link CheckpointResponse.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof CheckpointResponse\n     * @static\n     * @param {ICheckpointResponse} message CheckpointResponse message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    CheckpointResponse.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a CheckpointResponse message from the specified reader or buffer.\n     * @function decode\n     * @memberof CheckpointResponse\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CheckpointResponse} CheckpointResponse\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CheckpointResponse.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CheckpointResponse();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.docID = reader.string();\n                break;\n            case 2:\n                message.savedState = reader.bytes();\n                break;\n            case 3:\n                message.checkpointRequest = reader.string();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        if (!message.hasOwnProperty(\"docID\"))\n            throw $util.ProtocolError(\"missing required 'docID'\", { instance: message });\n        if (!message.hasOwnProperty(\"savedState\"))\n            throw $util.ProtocolError(\"missing required 'savedState'\", { instance: message });\n        if (!message.hasOwnProperty(\"checkpointRequest\"))\n            throw $util.ProtocolError(\"missing required 'checkpointRequest'\", { instance: message });\n        return message;\n    };\n\n    /**\n     * Decodes a CheckpointResponse message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof CheckpointResponse\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {CheckpointResponse} CheckpointResponse\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CheckpointResponse.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a CheckpointResponse message.\n     * @function verify\n     * @memberof CheckpointResponse\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    CheckpointResponse.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (!$util.isString(message.docID))\n            return \"docID: string expected\";\n        if (!(message.savedState && typeof message.savedState.length === \"number\" || $util.isString(message.savedState)))\n            return \"savedState: buffer expected\";\n        if (!$util.isString(message.checkpointRequest))\n            return \"checkpointRequest: string expected\";\n        return null;\n    };\n\n    /**\n     * Creates a CheckpointResponse message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof CheckpointResponse\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {CheckpointResponse} CheckpointResponse\n     */\n    CheckpointResponse.fromObject = function fromObject(object) {\n        if (object instanceof $root.CheckpointResponse)\n            return object;\n        let message = new $root.CheckpointResponse();\n        if (object.docID != null)\n            message.docID = String(object.docID);\n        if (object.savedState != null)\n            if (typeof object.savedState === \"string\")\n                $util.base64.decode(object.savedState, message.savedState = $util.newBuffer($util.base64.length(object.savedState)), 0);\n            else if (object.savedState.length)\n                message.savedState = object.savedState;\n        if (object.checkpointRequest != null)\n            message.checkpointRequest = String(object.checkpointRequest);\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a CheckpointResponse message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof CheckpointResponse\n     * @static\n     * @param {CheckpointResponse} message CheckpointResponse\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    CheckpointResponse.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.defaults) {\n            object.docID = \"\";\n            if (options.bytes === String)\n                object.savedState = \"\";\n            else {\n                object.savedState = [];\n                if (options.bytes !== Array)\n                    object.savedState = $util.newBuffer(object.savedState);\n            }\n            object.checkpointRequest = \"\";\n        }\n        if (message.docID != null && message.hasOwnProperty(\"docID\"))\n            object.docID = message.docID;\n        if (message.savedState != null && message.hasOwnProperty(\"savedState\"))\n            object.savedState = options.bytes === String ? $util.base64.encode(message.savedState, 0, message.savedState.length) : options.bytes === Array ? Array.prototype.slice.call(message.savedState) : message.savedState;\n        if (message.checkpointRequest != null && message.hasOwnProperty(\"checkpointRequest\"))\n            object.checkpointRequest = message.checkpointRequest;\n        return object;\n    };\n\n    /**\n     * Converts this CheckpointResponse to JSON.\n     * @function toJSON\n     * @memberof CheckpointResponse\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    CheckpointResponse.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return CheckpointResponse;\n})();\n\nexport const WSMessage = $root.WSMessage = (() => {\n\n    /**\n     * Properties of a WSMessage.\n     * @exports IWSMessage\n     * @interface IWSMessage\n     * @property {ISubscribe|null} [subscribe] WSMessage subscribe\n     * @property {IUnsubscribe|null} [unsubscribe] WSMessage unsubscribe\n     * @property {IWelcome|null} [welcome] WSMessage welcome\n     * @property {ISubscribeDenied|null} [subscribeDenied] WSMessage subscribeDenied\n     * @property {ISend|null} [send] WSMessage send\n     * @property {IReceive|null} [receive] WSMessage receive\n     * @property {IAck|null} [ack] WSMessage ack\n     * @property {ICheckpointResponse|null} [checkpointResponse] WSMessage checkpointResponse\n     */\n\n    /**\n     * Constructs a new WSMessage.\n     * @exports WSMessage\n     * @classdesc Represents a WSMessage.\n     * @implements IWSMessage\n     * @constructor\n     * @param {IWSMessage=} [properties] Properties to set\n     */\n    function WSMessage(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * WSMessage subscribe.\n     * @member {ISubscribe|null|undefined} subscribe\n     * @memberof WSMessage\n     * @instance\n     */\n    WSMessage.prototype.subscribe = null;\n\n    /**\n     * WSMessage unsubscribe.\n     * @member {IUnsubscribe|null|undefined} unsubscribe\n     * @memberof WSMessage\n     * @instance\n     */\n    WSMessage.prototype.unsubscribe = null;\n\n    /**\n     * WSMessage welcome.\n     * @member {IWelcome|null|undefined} welcome\n     * @memberof WSMessage\n     * @instance\n     */\n    WSMessage.prototype.welcome = null;\n\n    /**\n     * WSMessage subscribeDenied.\n     * @member {ISubscribeDenied|null|undefined} subscribeDenied\n     * @memberof WSMessage\n     * @instance\n     */\n    WSMessage.prototype.subscribeDenied = null;\n\n    /**\n     * WSMessage send.\n     * @member {ISend|null|undefined} send\n     * @memberof WSMessage\n     * @instance\n     */\n    WSMessage.prototype.send = null;\n\n    /**\n     * WSMessage receive.\n     * @member {IReceive|null|undefined} receive\n     * @memberof WSMessage\n     * @instance\n     */\n    WSMessage.prototype.receive = null;\n\n    /**\n     * WSMessage ack.\n     * @member {IAck|null|undefined} ack\n     * @memberof WSMessage\n     * @instance\n     */\n    WSMessage.prototype.ack = null;\n\n    /**\n     * WSMessage checkpointResponse.\n     * @member {ICheckpointResponse|null|undefined} checkpointResponse\n     * @memberof WSMessage\n     * @instance\n     */\n    WSMessage.prototype.checkpointResponse = null;\n\n    // OneOf field names bound to virtual getters and setters\n    let $oneOfFields;\n\n    /**\n     * WSMessage type.\n     * @member {\"subscribe\"|\"unsubscribe\"|\"welcome\"|\"subscribeDenied\"|\"send\"|\"receive\"|\"ack\"|\"checkpointResponse\"|undefined} type\n     * @memberof WSMessage\n     * @instance\n     */\n    Object.defineProperty(WSMessage.prototype, \"type\", {\n        get: $util.oneOfGetter($oneOfFields = [\"subscribe\", \"unsubscribe\", \"welcome\", \"subscribeDenied\", \"send\", \"receive\", \"ack\", \"checkpointResponse\"]),\n        set: $util.oneOfSetter($oneOfFields)\n    });\n\n    /**\n     * Creates a new WSMessage instance using the specified properties.\n     * @function create\n     * @memberof WSMessage\n     * @static\n     * @param {IWSMessage=} [properties] Properties to set\n     * @returns {WSMessage} WSMessage instance\n     */\n    WSMessage.create = function create(properties) {\n        return new WSMessage(properties);\n    };\n\n    /**\n     * Encodes the specified WSMessage message. Does not implicitly {@link WSMessage.verify|verify} messages.\n     * @function encode\n     * @memberof WSMessage\n     * @static\n     * @param {IWSMessage} message WSMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    WSMessage.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.subscribe != null && Object.hasOwnProperty.call(message, \"subscribe\"))\n            $root.Subscribe.encode(message.subscribe, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n        if (message.unsubscribe != null && Object.hasOwnProperty.call(message, \"unsubscribe\"))\n            $root.Unsubscribe.encode(message.unsubscribe, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n        if (message.welcome != null && Object.hasOwnProperty.call(message, \"welcome\"))\n            $root.Welcome.encode(message.welcome, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n        if (message.subscribeDenied != null && Object.hasOwnProperty.call(message, \"subscribeDenied\"))\n            $root.SubscribeDenied.encode(message.subscribeDenied, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n        if (message.send != null && Object.hasOwnProperty.call(message, \"send\"))\n            $root.Send.encode(message.send, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n        if (message.receive != null && Object.hasOwnProperty.call(message, \"receive\"))\n            $root.Receive.encode(message.receive, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n        if (message.ack != null && Object.hasOwnProperty.call(message, \"ack\"))\n            $root.Ack.encode(message.ack, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();\n        if (message.checkpointResponse != null && Object.hasOwnProperty.call(message, \"checkpointResponse\"))\n            $root.CheckpointResponse.encode(message.checkpointResponse, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();\n        return writer;\n    };\n\n    /**\n     * Encodes the specified WSMessage message, length delimited. Does not implicitly {@link WSMessage.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof WSMessage\n     * @static\n     * @param {IWSMessage} message WSMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    WSMessage.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a WSMessage message from the specified reader or buffer.\n     * @function decode\n     * @memberof WSMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {WSMessage} WSMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    WSMessage.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.WSMessage();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.subscribe = $root.Subscribe.decode(reader, reader.uint32());\n                break;\n            case 2:\n                message.unsubscribe = $root.Unsubscribe.decode(reader, reader.uint32());\n                break;\n            case 3:\n                message.welcome = $root.Welcome.decode(reader, reader.uint32());\n                break;\n            case 4:\n                message.subscribeDenied = $root.SubscribeDenied.decode(reader, reader.uint32());\n                break;\n            case 5:\n                message.send = $root.Send.decode(reader, reader.uint32());\n                break;\n            case 6:\n                message.receive = $root.Receive.decode(reader, reader.uint32());\n                break;\n            case 7:\n                message.ack = $root.Ack.decode(reader, reader.uint32());\n                break;\n            case 8:\n                message.checkpointResponse = $root.CheckpointResponse.decode(reader, reader.uint32());\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a WSMessage message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof WSMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {WSMessage} WSMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    WSMessage.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a WSMessage message.\n     * @function verify\n     * @memberof WSMessage\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    WSMessage.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        let properties = {};\n        if (message.subscribe != null && message.hasOwnProperty(\"subscribe\")) {\n            properties.type = 1;\n            {\n                let error = $root.Subscribe.verify(message.subscribe);\n                if (error)\n                    return \"subscribe.\" + error;\n            }\n        }\n        if (message.unsubscribe != null && message.hasOwnProperty(\"unsubscribe\")) {\n            if (properties.type === 1)\n                return \"type: multiple values\";\n            properties.type = 1;\n            {\n                let error = $root.Unsubscribe.verify(message.unsubscribe);\n                if (error)\n                    return \"unsubscribe.\" + error;\n            }\n        }\n        if (message.welcome != null && message.hasOwnProperty(\"welcome\")) {\n            if (properties.type === 1)\n                return \"type: multiple values\";\n            properties.type = 1;\n            {\n                let error = $root.Welcome.verify(message.welcome);\n                if (error)\n                    return \"welcome.\" + error;\n            }\n        }\n        if (message.subscribeDenied != null && message.hasOwnProperty(\"subscribeDenied\")) {\n            if (properties.type === 1)\n                return \"type: multiple values\";\n            properties.type = 1;\n            {\n                let error = $root.SubscribeDenied.verify(message.subscribeDenied);\n                if (error)\n                    return \"subscribeDenied.\" + error;\n            }\n        }\n        if (message.send != null && message.hasOwnProperty(\"send\")) {\n            if (properties.type === 1)\n                return \"type: multiple values\";\n            properties.type = 1;\n            {\n                let error = $root.Send.verify(message.send);\n                if (error)\n                    return \"send.\" + error;\n            }\n        }\n        if (message.receive != null && message.hasOwnProperty(\"receive\")) {\n            if (properties.type === 1)\n                return \"type: multiple values\";\n            properties.type = 1;\n            {\n                let error = $root.Receive.verify(message.receive);\n                if (error)\n                    return \"receive.\" + error;\n            }\n        }\n        if (message.ack != null && message.hasOwnProperty(\"ack\")) {\n            if (properties.type === 1)\n                return \"type: multiple values\";\n            properties.type = 1;\n            {\n                let error = $root.Ack.verify(message.ack);\n                if (error)\n                    return \"ack.\" + error;\n            }\n        }\n        if (message.checkpointResponse != null && message.hasOwnProperty(\"checkpointResponse\")) {\n            if (properties.type === 1)\n                return \"type: multiple values\";\n            properties.type = 1;\n            {\n                let error = $root.CheckpointResponse.verify(message.checkpointResponse);\n                if (error)\n                    return \"checkpointResponse.\" + error;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Creates a WSMessage message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof WSMessage\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {WSMessage} WSMessage\n     */\n    WSMessage.fromObject = function fromObject(object) {\n        if (object instanceof $root.WSMessage)\n            return object;\n        let message = new $root.WSMessage();\n        if (object.subscribe != null) {\n            if (typeof object.subscribe !== \"object\")\n                throw TypeError(\".WSMessage.subscribe: object expected\");\n            message.subscribe = $root.Subscribe.fromObject(object.subscribe);\n        }\n        if (object.unsubscribe != null) {\n            if (typeof object.unsubscribe !== \"object\")\n                throw TypeError(\".WSMessage.unsubscribe: object expected\");\n            message.unsubscribe = $root.Unsubscribe.fromObject(object.unsubscribe);\n        }\n        if (object.welcome != null) {\n            if (typeof object.welcome !== \"object\")\n                throw TypeError(\".WSMessage.welcome: object expected\");\n            message.welcome = $root.Welcome.fromObject(object.welcome);\n        }\n        if (object.subscribeDenied != null) {\n            if (typeof object.subscribeDenied !== \"object\")\n                throw TypeError(\".WSMessage.subscribeDenied: object expected\");\n            message.subscribeDenied = $root.SubscribeDenied.fromObject(object.subscribeDenied);\n        }\n        if (object.send != null) {\n            if (typeof object.send !== \"object\")\n                throw TypeError(\".WSMessage.send: object expected\");\n            message.send = $root.Send.fromObject(object.send);\n        }\n        if (object.receive != null) {\n            if (typeof object.receive !== \"object\")\n                throw TypeError(\".WSMessage.receive: object expected\");\n            message.receive = $root.Receive.fromObject(object.receive);\n        }\n        if (object.ack != null) {\n            if (typeof object.ack !== \"object\")\n                throw TypeError(\".WSMessage.ack: object expected\");\n            message.ack = $root.Ack.fromObject(object.ack);\n        }\n        if (object.checkpointResponse != null) {\n            if (typeof object.checkpointResponse !== \"object\")\n                throw TypeError(\".WSMessage.checkpointResponse: object expected\");\n            message.checkpointResponse = $root.CheckpointResponse.fromObject(object.checkpointResponse);\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a WSMessage message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof WSMessage\n     * @static\n     * @param {WSMessage} message WSMessage\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    WSMessage.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (message.subscribe != null && message.hasOwnProperty(\"subscribe\")) {\n            object.subscribe = $root.Subscribe.toObject(message.subscribe, options);\n            if (options.oneofs)\n                object.type = \"subscribe\";\n        }\n        if (message.unsubscribe != null && message.hasOwnProperty(\"unsubscribe\")) {\n            object.unsubscribe = $root.Unsubscribe.toObject(message.unsubscribe, options);\n            if (options.oneofs)\n                object.type = \"unsubscribe\";\n        }\n        if (message.welcome != null && message.hasOwnProperty(\"welcome\")) {\n            object.welcome = $root.Welcome.toObject(message.welcome, options);\n            if (options.oneofs)\n                object.type = \"welcome\";\n        }\n        if (message.subscribeDenied != null && message.hasOwnProperty(\"subscribeDenied\")) {\n            object.subscribeDenied = $root.SubscribeDenied.toObject(message.subscribeDenied, options);\n            if (options.oneofs)\n                object.type = \"subscribeDenied\";\n        }\n        if (message.send != null && message.hasOwnProperty(\"send\")) {\n            object.send = $root.Send.toObject(message.send, options);\n            if (options.oneofs)\n                object.type = \"send\";\n        }\n        if (message.receive != null && message.hasOwnProperty(\"receive\")) {\n            object.receive = $root.Receive.toObject(message.receive, options);\n            if (options.oneofs)\n                object.type = \"receive\";\n        }\n        if (message.ack != null && message.hasOwnProperty(\"ack\")) {\n            object.ack = $root.Ack.toObject(message.ack, options);\n            if (options.oneofs)\n                object.type = \"ack\";\n        }\n        if (message.checkpointResponse != null && message.hasOwnProperty(\"checkpointResponse\")) {\n            object.checkpointResponse = $root.CheckpointResponse.toObject(message.checkpointResponse, options);\n            if (options.oneofs)\n                object.type = \"checkpointResponse\";\n        }\n        return object;\n    };\n\n    /**\n     * Converts this WSMessage to JSON.\n     * @function toJSON\n     * @memberof WSMessage\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    WSMessage.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return WSMessage;\n})();\n\nexport { $root as default };\n","/**\n * Enum of possible types for updates in the (uncompacted) log.\n */\nexport var UpdateType;\n(function (UpdateType) {\n    UpdateType[UpdateType[\"Message\"] = 1] = \"Message\";\n    UpdateType[UpdateType[\"SavedState\"] = 2] = \"SavedState\";\n})(UpdateType || (UpdateType = {}));\nexport function stringToEnum(updateType) {\n    return updateType === \"message\" ? UpdateType.Message : UpdateType.SavedState;\n}\n//# sourceMappingURL=update_type.js.map","import { EventEmitter, mergeMessages, } from \"@collabs/collabs\";\nimport { nonNull, protobufHas } from \"@collabs/core\";\nimport { WSMessage, } from \"../generated/proto_compiled\";\nimport { UpdateType, stringToEnum } from \"./update_type\";\n/**\n * Syncs updates to Collabs documents via a server over\n * WebSockets.\n *\n * The server is in package [@collabs/ws-server](https://www.npmjs.com/package/@collabs/ws-server).\n *\n * This class is designed to work seamlessly with other sources of updates,\n * such as [@collabs/indexeddb](https://www.npmjs.com/package/@collabs/indexeddb).\n * In particular, updates from those sources will be synced to the server\n * alongside local operations.\n * - Exception: Updates from other tabs via\n * [@collabs/tab-sync](https://www.npmjs.com/package/@collabs/tab-sync) are not\n * sent, since the source tab should send them.\n */\nexport class WebSocketNetwork extends EventEmitter {\n    /**\n     * Constructs a WebSocketNetwork.\n     *\n     * You typically only need one WebSocketNetwork per app, since it\n     * can [[subscribe]] multiple documents.\n     *\n     * @param url The WebSocket url to connect to.\n     * @param options.connect Set to false to skip connecting in the constructor.\n     * If so, you will need to call [[connect]] later.\n     */\n    constructor(url, options = {}) {\n        var _a;\n        super();\n        this.url = url;\n        this.ws = null;\n        /** A counter for our sent messages across all docs. */\n        this.localCounter = 0;\n        this.subs = new Map();\n        /** Inverse map docID -> Doc. */\n        this.docsByID = new Map();\n        this.closed = false;\n        if ((_a = options.connect) !== null && _a !== void 0 ? _a : true)\n            this.connect();\n    }\n    // Doc: may call multiple times, e.g., reconnecting.\n    // Okay to call if already connected.\n    // E.g. net.on(\"Disconnect\", () => setTimeout(net.connect(), 2000))\n    // will (repeatedly) try to reconnect after a disconnection.\n    /**\n     * Connects to the server.\n     *\n     * Once connected, all subscribed docs sync their current states with\n     * the server, then send and receive further updates as they occur.\n     *\n     * If we disconnect due to a network error, you will need to call this method\n     * again to reconnect. E.g., to try to reconnect every 2 seconds after\n     * a disconnection:\n     * ```ts\n     * wsNetwork.on(\"Disconnect\", () => setTimeout(wsNetwork.connect(), 2000));\n     * ```\n     * (Since failed connection attempts also emit a \"Disconnect\" event, this will\n     * repeat until a connection succeeds.)\n     */\n    connect() {\n        if (this.closed)\n            throw new Error(\"Already closed\");\n        if (this.connected)\n            return;\n        const ws = new WebSocket(this.url);\n        ws.binaryType = \"arraybuffer\";\n        this.ws = ws;\n        ws.addEventListener(\"open\", () => {\n            if (ws !== this.ws)\n                return;\n            // (Re-) subscribe to all docIDs.\n            if (this.docsByID.size !== 0) {\n                this.sendInternal({\n                    subscribe: {\n                        docIDs: [...this.docsByID.keys()],\n                    },\n                });\n            }\n            // Emit event.\n            this.emit(\"Connect\", {});\n        });\n        ws.addEventListener(\"message\", (e) => this.wsReceive(e.data));\n        ws.addEventListener(\"close\", (e) => this.wsDisconnect(ws, \"close\", e));\n        ws.addEventListener(\"error\", (e) => this.wsDisconnect(ws, \"error\", e));\n    }\n    wsDisconnect(caller, cause, e) {\n        if (caller !== this.ws)\n            return;\n        this.ws = null;\n        this.emit(\"Disconnect\", { cause, wsEvent: e });\n    }\n    /**\n     * Disconnects from the server or aborts an in-progress connection attempt.\n     *\n     * You may reconnect later by calling [[connect]].\n     */\n    disconnect() {\n        var _a;\n        (_a = this.ws) === null || _a === void 0 ? void 0 : _a.close();\n        // Note that changing this.ws right away will cause wsDisconnect to\n        // ignore the WebSocket close event, which is dispatched async.\n        // We instead emit our own Disconnect event.\n        this.ws = null;\n        this.emit(\"Disconnect\", { cause: \"manual\", wsEvent: null });\n    }\n    /**\n     * Whether we have an open WebSocket connection to the server.\n     */\n    get connected() {\n        return this.ws !== null && this.ws.readyState === WebSocket.OPEN;\n    }\n    /**\n     * Sends the given message if the connection is open.\n     *\n     * We do not guarantee eventual receipt - if the server is not open,\n     * or if sending fails, the message will not reach the server.\n     * So make sure to re-do message's effect on open.\n     */\n    sendInternal(message) {\n        if (this.ws != null && this.ws.readyState == WebSocket.OPEN) {\n            this.ws.send(WSMessage.encode(message).finish());\n        }\n    }\n    /**\n     * Subscribes `doc` to updates for `docID`.\n     *\n     * `doc` will send and receive updates with the server's copy of `docID`.\n     * It will also sync initial states with\n     * the server, to ensure that `doc` and the server start up-to-date.\n     *\n     * @param doc The document to subscribe.\n     * @param docID An arbitrary string that identifies which updates to use.\n     * @param options.batchRemoteMS If set, remote updates to doc are\n     * delivered at most once every `batchRemoteMS` ms, emitting only a single\n     * doc \"Change\" event. This limits render frequency.\n     * @param options.batchSendMS **Experimental** If set, local updates to\n     * doc are pushed to the server at most once every `batchSendMS` ms.\n     * This reduces the load on the server and on remote users, but increases\n     * the time before a local update is saved and visible remotely.\n     * @throws If `doc` is already subscribed to a docID.\n     * @throws If another doc is subscribed to `docID`.\n     */\n    subscribe(doc, docID, options = {}) {\n        var _a, _b;\n        if (this.closed)\n            throw new Error(\"Already closed\");\n        if (this.subs.has(doc)) {\n            throw new Error(\"doc is already subscribed to a docID\");\n        }\n        if (this.docsByID.has(docID)) {\n            throw new Error(\"Unsupported: multiple docs with same docID\");\n        }\n        this.subs.set(doc, {\n            docID,\n            lastSent: 0,\n            nextRemoteBatch: [],\n            nextSendBatch: [],\n            batchRemoteMS: (_a = options.batchRemoteMS) !== null && _a !== void 0 ? _a : null,\n            batchSendMS: (_b = options.batchSendMS) !== null && _b !== void 0 ? _b : null,\n        });\n        this.docsByID.set(docID, doc);\n        this.sendInternal({ subscribe: { docIDs: [docID] } });\n        // Wait to subscribe to doc updates until after the first time\n        // we send our whole state (on Welcome).\n    }\n    /**\n     * **Experimental**\n     *\n     * Changes the `batchSendMS` for a subscribed doc.\n     *\n     * See [[subscribe]]'s `options.batchSendMS`.\n     */\n    setBatchSendMS(doc, batchSendMS) {\n        var _a;\n        const info = this.subs.get(doc);\n        if (info === undefined)\n            return;\n        if (batchSendMS === null || batchSendMS < ((_a = info.batchSendMS) !== null && _a !== void 0 ? _a : 0)) {\n            // The new batch length is shorter than the old one.\n            // To prevent unexpected delays, send the current batch now.\n            if (info.sendBatchTimeout !== undefined) {\n                clearTimeout(info.sendBatchTimeout);\n            }\n            this.sendBatch(info);\n        }\n        info.batchSendMS = batchSendMS;\n    }\n    sendBatch(info) {\n        // Skip if we've been unsubscribed already.\n        if (info.unsubscribed)\n            return;\n        if (info.nextSendBatch.length === 0)\n            return;\n        const merged = mergeMessages(info.nextSendBatch);\n        info.nextSendBatch = [];\n        info.sendBatchTimeout = undefined;\n        this.sendInternal({\n            send: {\n                docID: info.docID,\n                update: merged,\n                updateType: UpdateType.Message,\n                localCounter: ++this.localCounter,\n            },\n        });\n        info.lastSent = this.localCounter;\n    }\n    /**\n     * Unsubscribes `doc` from its subscribed `docID` (if any).\n     *\n     * `doc` will no longer send or receive updates with the server.\n     */\n    unsubscribe(doc) {\n        const info = this.subs.get(doc);\n        if (info === undefined || info.unsubscribed)\n            return;\n        // Push out the pending send batch.\n        this.sendBatch(info);\n        info.unsubscribed = true;\n        this.subs.delete(doc);\n        this.docsByID.delete(info.docID);\n        if (info.off !== undefined)\n            info.off();\n        this.sendInternal({ unsubscribe: { docID: info.docID } });\n    }\n    wsReceive(encoded) {\n        const message = WSMessage.decode(new Uint8Array(encoded));\n        switch (message.type) {\n            case \"welcome\":\n                this.onWelcome(message.welcome);\n                break;\n            case \"subscribeDenied\":\n                this.onSubscribeDenied(message.subscribeDenied);\n                break;\n            case \"receive\":\n                this.onReceive(message.receive);\n                break;\n            case \"ack\": {\n                this.onAck(message.ack);\n                break;\n            }\n            default:\n                throw new Error(\"Unexpected WebSocketNetwork message type: \" + message.type);\n        }\n    }\n    onWelcome(message) {\n        const doc = this.docsByID.get(message.docID);\n        if (doc === undefined)\n            return;\n        const info = nonNull(this.subs.get(doc));\n        const ourOldState = doc.save();\n        if (info.off === undefined) {\n            // Subscribe to future doc updates (not included in ourOldState)\n            // and forward them to the server.\n            // This includes both local operations and updates that we learn\n            // of from other network/storage tools.\n            const docID = message.docID;\n            info.off = doc.on(\"Update\", (e) => {\n                // Skip updates that we delivered.\n                if (e.caller === this)\n                    return;\n                // Skip updates delivered by other tabs; they should be sending\n                // their updates to the server themselves.\n                if (typeof e.caller === \"object\" &&\n                    e.caller.isTabSyncNetwork === true)\n                    return;\n                if (info.batchSendMS !== null) {\n                    if (e.updateType === \"message\") {\n                        // Just add to the pending send batch.\n                        if (info.nextSendBatch.length === 0) {\n                            // Schedule send.\n                            info.sendBatchTimeout = setTimeout(() => this.sendBatch(info), info.batchSendMS);\n                        }\n                        info.nextSendBatch.push(e.update);\n                        return;\n                    }\n                    else {\n                        // Send immediately as usual (below).\n                        // To guarantee causal-order sending, first push out the pending\n                        // send batch early.\n                        this.sendBatch(info);\n                    }\n                }\n                // OPT: if it's a saved state, only send the delta on top of our\n                // old state to the server (skipping the delta computation if disconnected).\n                this.sendInternal({\n                    send: {\n                        docID,\n                        update: e.update,\n                        updateType: stringToEnum(e.updateType),\n                        localCounter: ++this.localCounter,\n                    },\n                });\n                info.lastSent = this.localCounter;\n            });\n        }\n        // After the above save(), do the load() in a separate task, to avoid\n        // blocking for too long.\n        setTimeout(() => {\n            // Skip if we've been unsubscribed already.\n            if (info.unsubscribed)\n                return;\n            doc.batchRemoteUpdates(() => {\n                // Make us up-to-date with the server:\n                //   1. Load the welcome state.\n                if (protobufHas(message, \"savedState\")) {\n                    doc.load(message.savedState, this);\n                }\n                //   2. Load the further updates.\n                for (let i = 0; i < message.updates.length; i++) {\n                    const update = message.updates[i];\n                    const updateType = message.updateTypes[i];\n                    switch (updateType) {\n                        case UpdateType.Message:\n                            doc.receive(update, this);\n                            break;\n                        case UpdateType.SavedState:\n                            doc.load(update, this);\n                            break;\n                        default:\n                            throw new Error(\"Unrecognized UpdateType: \" + updateType);\n                    }\n                }\n            });\n            this.emit(\"Load\", { doc, docID: message.docID });\n            // Make the server up-to-date with us.\n            // OPT: use a delta on top of ourOldState instead,\n            // or mergeMessages applied to all not-acked updates.\n            // OPT: cancel pending send batch?\n            this.sendInternal({\n                send: {\n                    docID: message.docID,\n                    update: ourOldState,\n                    updateType: UpdateType.SavedState,\n                    localCounter: ++this.localCounter,\n                },\n            });\n            info.lastSent = this.localCounter;\n        }, 0);\n    }\n    onSubscribeDenied(message) {\n        const doc = this.docsByID.get(message.docID);\n        if (doc === undefined)\n            return;\n        const info = nonNull(this.subs.get(doc));\n        if (info.subscribeDenied === undefined) {\n            // First we've heard of it.\n            this.emit(\"SubscribeDenied\", { doc, docID: message.docID });\n            // If the server disconnects and reconnects, don't emit another event.\n            info.subscribeDenied = true;\n        }\n    }\n    onReceive(message) {\n        const doc = this.docsByID.get(message.docID);\n        if (doc === undefined)\n            return;\n        const info = nonNull(this.subs.get(doc));\n        if (info.batchRemoteMS === null)\n            this.deliver(doc, message);\n        else {\n            if (info.nextRemoteBatch.length === 0) {\n                // Start of a new batch.\n                setTimeout(() => this.deliverRemoteBatch(doc, info), info.batchRemoteMS);\n            }\n            info.nextRemoteBatch.push(message);\n        }\n    }\n    deliverRemoteBatch(doc, info) {\n        if (info.unsubscribed)\n            return;\n        doc.batchRemoteUpdates(() => {\n            for (const message of info.nextRemoteBatch)\n                try {\n                    this.deliver(doc, message);\n                }\n                catch (err) {\n                    // We display this error but let future messages go through,\n                    // to match non-batched behavior.\n                    console.error(err);\n                }\n        });\n        info.nextRemoteBatch = [];\n    }\n    deliver(doc, message) {\n        // Note: it is guaranteed that this method is only ever called with\n        // causally-ready messages. Indeed:\n        // 1. Other WebSocketNetwork clients only send/forward messages to the\n        // server after sending all of their causal dependencies.\n        // 2. The server echos messages in the order it receives them, which\n        // is in causal order by (1).\n        // 3. The server always sends the Welcome (encompassing all prior updates)\n        // before echoing any new messages.\n        // 4. Our batching preserves message order.\n        //\n        // Thus it is safe to use CRuntime's causalityGuaranteed option\n        // if WebSocketNetwork is your only network.\n        switch (message.updateType) {\n            case UpdateType.Message:\n                doc.receive(message.update, this);\n                break;\n            case UpdateType.SavedState:\n                doc.load(message.update, this);\n                break;\n            default:\n                throw new Error(\"Unrecognized UpdateType: \" + message.updateType);\n        }\n    }\n    onAck(message) {\n        const doc = this.docsByID.get(message.docID);\n        if (doc === undefined)\n            return;\n        const info = nonNull(this.subs.get(doc));\n        if (message.localCounter === info.lastSent) {\n            // The ack'd update is the last one we sent to the server.\n            // So doc's state is now completely saved.\n            this.emit(\"Save\", { doc, docID: message.docID });\n        }\n        if (protobufHas(message, \"checkpointRequest\")) {\n            // The server requests that we send our current saved state.\n            // It will use this as a \"checkpoint\", replacing its message log\n            // (up to the point that we've saved).\n            this.sendInternal({\n                checkpointResponse: {\n                    docID: message.docID,\n                    savedState: doc.save(),\n                    checkpointRequest: message.checkpointRequest,\n                },\n            });\n        }\n    }\n    /**\n     * Closes our WebSocket and unsubscribes all documents.\n     *\n     * Future method calls will throw an error.\n     */\n    close() {\n        if (this.closed)\n            return;\n        this.closed = true;\n        // Unsubscribe all docs.\n        for (const doc of this.subs.keys())\n            this.unsubscribe(doc);\n        // Close our WebSocket.\n        this.disconnect();\n    }\n}\n//# sourceMappingURL=web_socket_network.js.map","import * as collabs             from \"@collabs/collabs\";\nimport { IndexedDBDocStore }    from \"@collabs/indexeddb\";\nimport { LocalStorageDocStore } from \"@collabs/local-storage\";\nimport { TabSyncNetwork }       from \"@collabs/tab-sync\";\nimport { WebSocketNetwork }     from \"@collabs/ws-client\";\n\nconst Collabs = {\n  collabs, \n  IndexedDBDocStore, LocalStorageDocStore,\n  TabSyncNetwork, WebSocketNetwork,\n}\n\n// @ts-ignore allow \"window.collabs\"\nwindow.collabs = Collabs\n\ndocument.dispatchEvent(\n  new CustomEvent('collabs',{ detail:Collabs })\n)\n"],"names":["eventName","handler","options","unsubscribe","event","caller","set","err","x","name","parent","EventEmitter","init","messageStack","metaRequests","replicaID","rootCallback","rootCollab","collab","id","descendant","ancestor","current","collabIDPath","i","rng","length","arr","value","collabCallback","child","meta","childSaves","savedStateTree","childSave","startIndex","message","metaRequest","savedState","Base","Mixin","args","position","index","searchElement","callbackfn","thisArg","ans","start","end","len","fromIndex","key","b64","validLen","placeHoldersLen","tmp","lens","curByte","num","uint8","output","extraBytes","parts","maxChunkLength","len2","list","cursor","fn","ctx","params","offset","pending","resolve","reject","base64","exports","string","p","n","s64","buffer","chunk","j","t","invalidEncoding","c","on","evt","off","listeners","emit","f32","f8b","le","writeFloat_f32_cpy","val","buf","pos","writeFloat_f32_rev","readFloat_f32_cpy","readFloat_f32_rev","writeFloat_ieee754","writeUint","sign","exponent","mantissa","readFloat_ieee754","readUint","uint","f64","writeDouble_f64_cpy","writeDouble_f64_rev","readDouble_f64_cpy","readDouble_f64_rev","writeDouble_ieee754","off0","off1","readDouble_ieee754","lo","hi","e","utf8","c1","c2","alloc","slice","size","SIZE","MAX","slab","LongBits","util","require$$0","zero","zeroHash","unsigned","charCodeAt","hash","mask","part0","part1","part2","require$$1","require$$2","require$$3","require$$4","require$$5","require$$6","require$$7","global","this","obj","prop","Buffer","sizeOrArray","bits","merge","dst","src","ifNotSet","keys","str","newError","CustomError","properties","fieldNames","fieldMap","encoding","Writer","BufferWriter","writer","create","push","write_uint32","write_int32","write_sint32","write_uint64","write_sint64","write_bool","write_fixed32","write_fixed64","write_float","write_double","writeBytes_set","writeBytes_for","write_bytes","write_string","fork","reset","ldelim","head","tail","finish","BufferWriter_","write_bytes_buffer","write_string_buffer","Reader","BufferReader","reader","writeLength","create_typed_array","create_array","read_uint32_setup","read_int32","read_sint32","read_bool","read_fixed32","read_sfixed32","read_float","read_double","read_bytes","read_string","bytes","skip","wireType","BufferReader_","read_string_buffer","rpcImpl","requestDelimited","responseDelimited","rpcCall","method","requestCtor","responseCtor","request","callback","self","response","endedByRPC","rpc","protobuf","configure","$Reader","$protobuf.Reader","$Writer","$protobuf.Writer","$util","$protobuf.util","$protobuf.roots","MessageStacksMessage","tag","end2","object","SavedStateTreeMessage","error","ArrayMessage","ObjectMessage","keys2","DefaultSerializerMessage","$oneOfFields","PairSerializerMessage","CollabIDMessage","OptionalMessage","_a","targetObject","_b","element","constructor","property","decoded","serialized","optionalValue","utf8.length","utf8.write","utf8.read","valueSerializer","values","existingWeak","existing","ret","oneSerializer","twoSerializer","_value","_message","isPresent","valueIfPresent","other","f","children","edgeLabels","edgeParents","messageStackIDs","useCache","parentMap","cachedID","messageStacks","nextID","edgeLabelLengths","packedLength","edgeLabel","edgeLabelsPacked","signedLength","tree","childrenKeys","childrenValues","deref","entry","valueDeref","valueConstructor","fromByteArray","toByteArray","keyString","update","nontrivialStart","_key","delta","encoded","CSetMessage","CSetSave","TotalOrderCreateMessage","TotalOrderSave","LocalListSave","SpanLogPartialSpanMessage","SpanLogSaveMessage","ValueListInsertMessage","ValueListMessage","MessageSerializerMergeInfo","CRDTMessageMetaMessage","long","CausalMessageBufferSave","CounterMessage","CounterSave","PresenceSetMessage","PresenceMessage","PresenceInfoSave","PresenceSave","MultiValueMapMessage","MultiValueMapItemsSave","MultiValueMapSave","RADIX","lastMessage","crdtMeta","serializedArgs","newValue","senderID","senderCounter","comma","dot","senderCounterStr","created","argsSerialized","saveMessage","existed","keyAsString","previousValue","newItems","needsSort","item","keyAsBytes","a","b","entries","senders","indexBySender","itemsRaw","items","sender","localItems","remoteItems","decodedSenders","addedRemote","remoteMap","localItem","defaultAggregator","multiValue","keySerializer","argsSerializer","valueInit","oldConflicts","propertyValue","updates","_crdtMeta","info","time","ttlRemaining","state","infoSave","initialValue","aggregator","winner","counter","parentWaypoint","parentValueIndex","isRight","prevPosition","nextPosition","count","prevWaypoint","prevValueIndex","nextWaypoint","nextValueIndex","extendValueIndex","existingRight","aWaypoint","aValueIndex","bWaypoint","bValueIndex","waypoint","valueIndex","firstChild","ourArray","newWaypoint","valueAndSide","parentWaypointSender","parentWaypointCounter","senderWaypoints","sibling1","sibling2","bySender","replicaIDs","replicaCounts","startIndices","waypoints","parentWaypoints","parentValueIndexAndSides","_meta","counterStarts","statesWaypoints","replicaStartIndex","replicaCount","byID","counterStart","source","remaining","curItem","deleteCount","firstPos","waypointValuesBefore","waypointValues","searchDir","valuesBefore","waypointLoop","next","stack","valuesOrChild","childIndex","startValueIndex","itemSize","endValueIndex","total","valueArraySerializer","replicaIDsInv","replicaIDIndices","counters","totals","seens","itemsLengths","itemSizes","replicaIDIndex","sizesIndex","valuesIndex","valueCallback","initialPosition","entryInit","previousIndex","toDelete","toArchive","insertionIndex","positions","toMove","formatSerializer","span","startPos","endPos","endClosed","senderIDs","lengths","spans","lamports","senderSpans","spanIndex","lastLamport","lamport","insert","firstNewPos","insertMessage","remote","deleteEvents","remoteSeen","insertEvents","insertedSoFar","localSeen","sliceBuilder","data","previousValueOpen","previousValueClosed","slices","prevIndex","prevSpan","newSpan","oldSpan","format","endPosClosed","endPosOpen","endIndex","actualEndIndex","dataIndex","dataPos","positionsIter","includeClosed","equals","startClosed","nextPos","nextClosed","prevSlice","toAdd","oldValue","incoming","vcEntries","actualVC","causallyMaximalVCKeys","actualWallClockTime","actualLamportTimestamp","clock","maximalVCKeyCount","wallClockTime","lamportTimestamp","replicaIDEncoder","vcKeysMaybeEncoded","vcValues","replicaIDDecoder","vc","vcKey","localVCEntries","remoteVCEntries","localLamportTimestamp","remoteLamportTimestamp","MessageType","allMessageStacks","trMessages","footer","nextStart","tr","causalityGuaranteed","deliver","delivered","recheck","senderEntry","vcKeys","bufferMessages","oldLocalVC","oldLocalLamportTimestamp","remoteVC","remoteMaximalVCKeys","localValue","remoteValue","childCallback","autoEndTransaction","anyDelivered","trMessage","loadCRDTMeta","isRedundant","vectorClock","redundant","local","messages","originals","debugReplicaID","runtime","appQueue","oldApp","oldAppQueue","queue","recipients","senderMap","recipient","queued","updatesBeforeCheckpoint","checkpointInterval","doc","openRequest","docID","db","savedStates","objectStore","includedUpdates","addRequest","results","trID","docPrefix","docPrefixDot","ourPrefix","lastDot","suffix","checkpointKey","docIDs","nextDot","escapedDocID","Subscribe","Unsubscribe","Welcome","SubscribeDenied","Send","Receive","Ack","CheckpointResponse","WSMessage","UpdateType","updateType","url","ws","cause","batchSendMS","merged","ourOldState"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78]}